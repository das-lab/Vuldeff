diff --git a/lib/RT/Interface/Web.pm b/lib/RT/Interface/Web.pm
index 29deaa47714..4c74b6afa6d 100755
--- a/lib/RT/Interface/Web.pm
+++ b/lib/RT/Interface/Web.pm
@@ -207,13 +207,29 @@ sub HandleRequest {
     unless ( _UserLoggedIn() ) {
         _ForceLogout();
 
-        # If the user is logging in, let's authenticate
-        if ( defined $ARGS->{user} && defined $ARGS->{pass} ) {
-            AttemptPasswordAuthentication($ARGS);
-        } else {
-            # if no credentials then show him login page
-            $HTML::Mason::Commands::m->comp( '/Elements/Login', %$ARGS );
-            $HTML::Mason::Commands::m->abort;
+        # Authenticate if the user is trying to login via user/pass query args
+        my ($authed, $msg) = AttemptPasswordAuthentication($ARGS);
+
+        unless ($authed) {
+            my $m = $HTML::Mason::Commands::m;
+
+            # REST urls get a special 401 response
+            if ($m->request_comp->path =~ '^/REST/\d+\.\d+/') {
+                $HTML::Mason::Commands::r->content_type("text/plain");
+                $m->error_format("text");
+                $m->out("RT/$RT::VERSION 401 Credentials required\n");
+                $m->out("\n$msg\n") if $msg;
+                $m->abort;
+            }
+            # Specially handle /index.html so that we get a nicer URL
+            elsif ( $m->request_comp->path eq '/index.html' ) {
+                my $next = SetNextPage(RT->Config->Get('WebURL'));
+                $m->comp('/NoAuth/Login.html', next => $next, actions => [$msg]);
+                $m->abort;
+            }
+            else {
+                TangentForLogin(results => ($msg ? LoginError($msg) : undef));
+            }
         }
     }
 
@@ -245,6 +261,108 @@ sub _UserLoggedIn {
 
 }
 
+=head2 LoginError ERROR
+
+Pushes a login error into the Actions session store and returns the hash key.
+
+=cut
+
+sub LoginError {
+    my $new = shift;
+    my $key = Digest::MD5::md5_hex( rand(1024) );
+    push @{ $HTML::Mason::Commands::session{"Actions"}->{$key} ||= [] }, $new;
+    $HTML::Mason::Commands::session{'i'}++;
+    return $key;
+}
+
+=head2 SetNextPage [PATH]
+
+Intuits and stashes the next page in the sesssion hash.  If PATH is
+specified, uses that instead of the value of L<IntuitNextPage()>.  Returns
+the hash value.
+
+=cut
+
+sub SetNextPage {
+    my $next = shift || IntuitNextPage();
+    my $hash = Digest::MD5::md5_hex($next . $$ . rand(1024));
+
+    $HTML::Mason::Commands::session{'NextPage'}->{$hash} = $next;
+    $HTML::Mason::Commands::session{'i'}++;
+    
+    SendSessionCookie();
+    return $hash;
+}
+
+
+=head2 TangentForLogin [HASH]
+
+Redirects to C</NoAuth/Login.html>, setting the value of L<IntuitNextPage> as
+the next page.  Optionally takes a hash which is dumped into query params.
+
+=cut
+
+sub TangentForLogin {
+    my $hash  = SetNextPage();
+    my %query = (@_, next => $hash);
+    my $login = RT->Config->Get('WebURL') . 'NoAuth/Login.html?';
+    $login .= $HTML::Mason::Commands::m->comp('/Elements/QueryString', %query);
+    Redirect($login);
+}
+
+=head2 TangentForLoginWithError ERROR
+
+Localizes the passed error message, stashes it with L<LoginError> and then
+calls L<TangentForLogin> with the appropriate results key.
+
+=cut
+
+sub TangentForLoginWithError {
+    my $key = LoginError(HTML::Mason::Commands::loc(@_));
+    TangentForLogin( results => $key );
+}
+
+=head2 IntuitNextPage
+
+Attempt to figure out the path to which we should return the user after a
+tangent.  The current request URL is used, or failing that, the C<WebURL>
+configuration variable.
+
+=cut
+
+sub IntuitNextPage {
+    my $req_uri;
+
+    # This includes any query parameters.  Redirect will take care of making
+    # it an absolute URL.
+    if ($ENV{'REQUEST_URI'}) {
+        $req_uri = $ENV{'REQUEST_URI'};
+
+        # collapse multiple leading slashes so the first part doesn't look like
+        # a hostname of a schema-less URI
+        $req_uri =~ s{^/+}{/};
+    }
+
+    my $next = defined $req_uri ? $req_uri : RT->Config->Get('WebURL');
+
+    # sanitize $next
+    my $uri = URI->new($next);
+
+    # You get undef scheme with a relative uri like "/Search/Build.html"
+    unless (!defined($uri->scheme) || $uri->scheme eq 'http' || $uri->scheme eq 'https') {
+        $next = RT->Config->Get('WebURL');
+    }
+
+    # Make sure we're logging in to the same domain
+    # You can get an undef authority with a relative uri like "index.html"
+    my $uri_base_url = URI->new(RT->Config->Get('WebBaseURL'));
+    unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority) {
+        $next = RT->Config->Get('WebURL');
+    }
+
+    return $next;
+}
+
 =head2 MaybeShowInstallModePage 
 
 This function, called exclusively by RT's autohandler, dispatches
@@ -284,6 +402,10 @@ sub MaybeShowNoAuthPage {
 
     return unless $m->base_comp->path =~ RT->Config->Get('WebNoAuthRegex');
 
+    # Don't show the login page to logged in users
+    Redirect(RT->Config->Get('WebURL'))
+        if $m->base_comp->path eq '/NoAuth/Login.html' and _UserLoggedIn();
+
     # If it's a noauth file, don't ask for auth.
     SendSessionCookie();
     $m->comp( { base_comp => $m->request_comp }, $m->fetch_next, %$ARGS );
@@ -386,9 +508,12 @@ sub AttemptExternalAuth {
 
                 # we failed to successfully create the user. abort abort abort.
                 delete $HTML::Mason::Commands::session{'CurrentUser'};
-                $m->comp( '/Elements/Login', %$ARGS, Error => HTML::Mason::Commands::loc( 'Cannot create user: [_1]', $msg ) )
-                    if RT->Config->Get('WebFallbackToInternalAuth');;
-                $m->abort();
+
+                if (RT->Config->Get('WebFallbackToInternalAuth')) {
+                    TangentForLoginWithError('Cannot create user: [_1]', $msg);
+                } else {
+                    $m->abort();
+                }
             }
         }
 
@@ -399,15 +524,13 @@ sub AttemptExternalAuth {
             $user = $orig_user;
 
             if ( RT->Config->Get('WebExternalOnly') ) {
-                $m->comp( '/Elements/Login', %$ARGS, Error => HTML::Mason::Commands::loc('You are not an authorized user') );
-                $m->abort();
+                TangentForLoginWithError('You are not an authorized user');
             }
         }
     } elsif ( RT->Config->Get('WebFallbackToInternalAuth') ) {
         unless ( defined $HTML::Mason::Commands::session{'CurrentUser'} ) {
             # XXX unreachable due to prior defaulting in HandleRequest (check c34d108)
-            $m->comp( '/Elements/Login', %$ARGS, Error => HTML::Mason::Commands::loc('You are not an authorized user') );
-            $m->abort();
+            TangentForLoginWithError('You are not an authorized user');
         }
     } else {
 
@@ -420,7 +543,9 @@ sub AttemptExternalAuth {
 }
 
 sub AttemptPasswordAuthentication {
-    my $ARGS     = shift;
+    my $ARGS = shift;
+    return unless defined $ARGS->{user} && defined $ARGS->{pass};
+
     my $user_obj = RT::CurrentUser->new();
     $user_obj->Load( $ARGS->{user} );
 
@@ -428,15 +553,34 @@ sub AttemptPasswordAuthentication {
 
     unless ( $user_obj->id && $user_obj->IsPassword( $ARGS->{pass} ) ) {
         $RT::Logger->error("FAILED LOGIN for @{[$ARGS->{user}]} from $ENV{'REMOTE_ADDR'}");
-        $m->comp( '/Elements/Login', %$ARGS, Error => HTML::Mason::Commands::loc('Your username or password is incorrect'), );
         $m->callback( %$ARGS, CallbackName => 'FailedLogin', CallbackPage => '/autohandler' );
-        $m->abort;
+        return (0, HTML::Mason::Commands::loc('Your username or password is incorrect'));
     }
+    else {
+        $RT::Logger->info("Successful login for @{[$ARGS->{user}]} from $ENV{'REMOTE_ADDR'}");
+
+        # It's important to nab the next page from the session before we blow
+        # the session away
+        my $next = delete $HTML::Mason::Commands::session{'NextPage'}->{$ARGS->{'next'} || ''};
 
-    $RT::Logger->info("Successful login for @{[$ARGS->{user}]} from $ENV{'REMOTE_ADDR'}");
-    InstantiateNewSession();
-    $HTML::Mason::Commands::session{'CurrentUser'} = $user_obj;
-    $m->callback( %$ARGS, CallbackName => 'SuccessfulLogin', CallbackPage => '/autohandler' );
+        InstantiateNewSession();
+        $HTML::Mason::Commands::session{'CurrentUser'} = $user_obj;
+        SendSessionCookie();
+
+        $m->callback( %$ARGS, CallbackName => 'SuccessfulLogin', CallbackPage => '/autohandler' );
+
+        # Really the only time we don't want to redirect here is if we were
+        # passed user and pass as query params in the URL.
+        if ($next) {
+            Redirect($next);
+        }
+        elsif ($ARGS->{'next'}) {
+            # Invalid hash, but still wants to go somewhere, take them to /
+            Redirect(RT->Config->Get('WebURL'));
+        }
+
+        return (1, HTML::Mason::Commands::loc('Logged in'));
+    }
 }
 
 =head2 LoadSessionFromCookie
@@ -503,6 +647,13 @@ sub Redirect {
     untie $HTML::Mason::Commands::session;
     my $uri        = URI->new($redir_to);
     my $server_uri = URI->new( RT->Config->Get('WebURL') );
+    
+    # Make relative URIs absolute from the server host and scheme
+    $uri->scheme($server_uri->scheme) if not defined $uri->scheme;
+    if (not defined $uri->host) {
+        $uri->host($server_uri->host);
+        $uri->port($server_uri->port);
+    }
 
     # If the user is coming in via a non-canonical
     # hostname, don't redirect them to the canonical host,
diff --git a/share/html/Elements/ListActions b/share/html/Elements/ListActions
index de7584b7a42..1e76bfe25e1 100755
--- a/share/html/Elements/ListActions
+++ b/share/html/Elements/ListActions
@@ -46,7 +46,7 @@
 %# 
 %# END BPS TAGGED BLOCK }}}
 <div class="results">
-<&| /Widgets/TitleBox, title => loc('Results') &>
+<&| /Widgets/TitleBox, title => loc('Results'), %{$titlebox || {}} &>
   <ul class="action-results">
 % foreach my $action (@actions) {
     <li><%$action%></li>
@@ -90,5 +90,6 @@ return unless @actions;
 
 </%init>
 <%ARGS>
+$titlebox => {}
 @actions => undef
 </%ARGS>
diff --git a/share/html/Elements/Login b/share/html/Elements/Login
index 00a8ab80e66..a7820c3bd90 100755
--- a/share/html/Elements/Login
+++ b/share/html/Elements/Login
@@ -45,42 +45,6 @@
 %# those contributions and any derivatives thereof.
 %# 
 %# END BPS TAGGED BLOCK }}}
-<%INIT>
-if ($m->request_comp->path =~ '^/REST/\d+\.\d+/') {
-    $r->content_type("text/plain");
-    $m->error_format("text");
-    $m->out("RT/$RT::VERSION 401 Credentials required\n");
-    $m->out("\n$Error\n") if $Error;
-    $m->abort;
-}
-
-my $req_uri;
-
-if (UNIVERSAL::can($r, 'uri') and $r->uri =~ m{.*/(.*)}) {
-    $req_uri = $1;
-}
-
-my $form_action = defined $goto             ? $goto
-                : defined $req_uri          ? $req_uri
-                :                             RT->Config->Get('WebPath')
-                ;
-
-# sanitize $form_action
-my $uri = URI->new($form_action);
-
-# You get undef scheme with a relative uri like "/Search/Build.html"
-unless (!defined($uri->scheme) || $uri->scheme eq 'http' || $uri->scheme eq 'https') {
-    $form_action = RT->Config->Get('WebPath');
-}
-
-# Make sure we're logging in to the same domain
-# You can get an undef authority with a relative uri like "index.html"
-my $uri_base_url = URI->new(RT->Config->Get('WebBaseURL'));
-unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority) {
-    $form_action = RT->Config->Get('WebPath');
-}
-</%INIT>
-
 % $m->callback( %ARGS, CallbackName => 'Header' );
 <& /Elements/Header, Title => loc('Login'), Focus => 'user' &>
 
@@ -89,11 +53,12 @@ unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority
 </div>
 
 <div id="body" class="login-body">
-% if ($Error) {
-<&| "/Widgets/TitleBox", title => loc('Error'), hideable => 0, class => 'error'  &>
-<% $Error %>
-</&>
-% }
+
+<& /Elements/ListActions,
+    title       => loc('Error'),
+    titlebox    => { class => 'error', hideable => 0 },
+    actions     => $actions
+&>
 
 % $m->callback( %ARGS, CallbackName => 'BeforeForm' );
 
@@ -101,7 +66,7 @@ unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority
 <&| /Widgets/TitleBox, title => loc('Login'), titleright => $RT::VERSION, hideable => 0 &>
 
 % unless (RT->Config->Get('WebExternalAuth') and !RT->Config->Get('WebFallbackToInternalAuth')) {
-<form id="login" name="login" method="post" action="<% $form_action %>">
+<form id="login" name="login" method="post" action="<% RT->Config->Get('WebPath') %>/NoAuth/Login.html">
 
 <div class="input-row">
     <span class="label"><&|/l&>Username</&>:</span>
@@ -113,6 +78,8 @@ unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority
     <span class="input"><input type="password" name="pass" autocomplete="off" /></span>
 </div>
 
+<input type="hidden" name="next" value="<% $next %>" />
+
 <div class="button-row">
     <span class="input"><input type="submit" class="button" value="<&|/l&>Login</&>" /></span>
 </div>
@@ -120,25 +87,6 @@ unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority
 %# Give callbacks a chance to add more control elements
 % $m->callback( %ARGS );
 
-% # From mason 1.0.1 forward, this doesn't work. in fact, it breaks things.
-% # But on Mason 1.15 it's fixed again, so we still use it.
-% # The code below iterates through everything in the passed in arguments
-% # Preserving all the old parameters
-% # This would be easier, except mason is 'smart' and calls multiple values
-% # arrays rather than multiple hash keys
-% my $key; my $val;
-% foreach $key (keys %ARGS) {
-%  if (($key ne 'user') and ($key ne 'pass')) {
-% 	if (ref($ARGS{$key}) =~ /ARRAY/) {
-% 		foreach $val (@{$ARGS{$key}}) {
-<input type="hidden" class="hidden" name="<%$key %>" value="<% $val %>" />
-% 		}
-% 	}
-%	else {
-<input type="hidden" class="hidden" name="<% $key %>" value="<% $ARGS{$key} %>" />
-% 	}
-%  }
-% }
 </form>
 % }
 </&>
@@ -147,8 +95,7 @@ unless (!defined($uri->authority) || $uri->authority eq $uri_base_url->authority
 </div><!-- #login-body -->
 <& /Elements/Footer, Menu => 0 &>
 <%ARGS>
+$next => ''
 $user => ""
-$pass => undef
-$goto => undef
-$Error => undef
+$actions => undef
 </%ARGS>
diff --git a/share/html/NoAuth/Login.html b/share/html/NoAuth/Login.html
new file mode 100755
index 00000000000..6a3084a00eb
--- /dev/null
+++ b/share/html/NoAuth/Login.html
@@ -0,0 +1,52 @@
+%# BEGIN BPS TAGGED BLOCK {{{
+%# 
+%# COPYRIGHT:
+%# 
+%# This software is Copyright (c) 1996-2010 Best Practical Solutions, LLC
+%#                                          <jesse@bestpractical.com>
+%# 
+%# (Except where explicitly superseded by other copyright notices)
+%# 
+%# 
+%# LICENSE:
+%# 
+%# This work is made available to you under the terms of Version 2 of
+%# the GNU General Public License. A copy of that license should have
+%# been provided with this software, but in any event can be snarfed
+%# from www.gnu.org.
+%# 
+%# This work is distributed in the hope that it will be useful, but
+%# WITHOUT ANY WARRANTY; without even the implied warranty of
+%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+%# General Public License for more details.
+%# 
+%# You should have received a copy of the GNU General Public License
+%# along with this program; if not, write to the Free Software
+%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+%# 02110-1301 or visit their web page on the internet at
+%# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
+%# 
+%# 
+%# CONTRIBUTION SUBMISSION POLICY:
+%# 
+%# (The following paragraph is not intended to limit the rights granted
+%# to you to modify and distribute this software under the terms of
+%# the GNU General Public License and is only of importance to you if
+%# you choose to contribute your changes and enhancements to the
+%# community by submitting them to Best Practical Solutions, LLC.)
+%# 
+%# By intentionally submitting any modifications, corrections or
+%# derivatives to this work, or any other work intended for use with
+%# Request Tracker, to Best Practical Solutions, LLC, you confirm that
+%# you are the copyright holder for those contributions and you grant
+%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
+%# royalty-free, perpetual, license to use, copy, create derivative
+%# works based on those contributions, and sublicense and distribute
+%# those contributions and any derivatives thereof.
+%# 
+%# END BPS TAGGED BLOCK }}}
+<%init>
+my ($good, $msg) = RT::Interface::Web::AttemptPasswordAuthentication(\%ARGS);
+$ARGS{'actions'} = [$msg] if not $good and $msg;
+</%init>
+<& /Elements/Login, %ARGS &>
diff --git a/share/html/NoAuth/css/web2/login.css b/share/html/NoAuth/css/web2/login.css
index 7aaf6b1f4c4..5cee01692ff 100644
--- a/share/html/NoAuth/css/web2/login.css
+++ b/share/html/NoAuth/css/web2/login.css
@@ -45,6 +45,10 @@
 %# those contributions and any derivatives thereof.
 %# 
 %# END BPS TAGGED BLOCK }}}
+.login-body .action-results {
+    list-style: none;
+}
+
 #login-box hr {
  display: none;
 }
diff --git a/t/web/redirect-after-login.t b/t/web/redirect-after-login.t
new file mode 100644
index 00000000000..d39bb58c8fc
--- /dev/null
+++ b/t/web/redirect-after-login.t
@@ -0,0 +1,243 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+
+use RT::Test tests => 120;
+
+my ($baseurl, $agent) = RT::Test->started_ok;
+
+my $url = $agent->rt_base_url;
+diag $url if $ENV{TEST_VERBOSE};
+
+# test a login from the main page
+{
+    $agent->get_ok($url);
+    is($agent->{'status'}, 200, "Loaded a page");
+    is($agent->uri, $url, "didn't redirect to /NoAuth/Login.html for base URL");
+    ok($agent->current_form->find_input('user'));
+    ok($agent->current_form->find_input('pass'));
+    like($agent->current_form->action, qr{/NoAuth/Login\.html$}, "login form action is correct");
+
+    ok($agent->content =~ /username:/i);
+    $agent->field( 'user' => 'root' );
+    $agent->field( 'pass' => 'password' );
+
+    # the field isn't named, so we have to click link 0
+    $agent->click(0);
+    is( $agent->status, 200, "Fetched the page ok");
+    ok( $agent->content =~ /Logout/i, "Found a logout link");
+    is( $agent->uri, $url, "right URL" );
+    like( $agent->{redirected_uri}, qr{/NoAuth/Login\.html$}, "We redirected from login");
+    $agent->logout();
+}
+
+# test a bogus login from the main page
+{
+    $agent->get_ok($url);
+    is($agent->{'status'}, 200, "Loaded a page");
+    is($agent->uri, $url, "didn't redirect to /NoAuth/Login.html for base URL");
+    ok($agent->current_form->find_input('user'));
+    ok($agent->current_form->find_input('pass'));
+    like($agent->current_form->action, qr{/NoAuth/Login\.html$}, "login form action is correct");
+
+    ok($agent->content =~ /username:/i);
+    $agent->field( 'user' => 'root' );
+    $agent->field( 'pass' => 'wrongpass' );
+
+    # the field isn't named, so we have to click link 0
+    $agent->click(0);
+    is( $agent->status, 200, "Fetched the page ok");
+
+    ok( $agent->content =~ /Your username or password is incorrect/i, "Found the error message");
+    like( $agent->uri, qr{/NoAuth/Login\.html$}, "now on /NoAuth/Login.html" );
+    $agent->logout();
+
+    # Handle the warning after we're done with the page, since this leaves us
+    # with a completely different $mech
+    $agent->warning_like(qr/FAILED LOGIN for root/, "got failed login warning");
+}
+
+# test a login from a non-front page, both with a double leading slash and without
+for my $path (qw(Prefs/Other.html /Prefs/Other.html)) {
+    my $requested = $url.$path;
+    $agent->get_ok($requested);
+    is($agent->status, 200, "Loaded a page");
+    like($agent->uri, qr'/NoAuth/Login\.html\?next=[a-z0-9]{32}', "on login page, with next page hash");
+    is($agent->{redirected_uri}, $requested, "redirected from our requested page");
+
+    ok($agent->current_form->find_input('user'));
+    ok($agent->current_form->find_input('pass'));
+    ok($agent->current_form->find_input('next'));
+    like($agent->value('next'), qr/^[a-z0-9]{32}$/i, "next page argument is a hash");
+    like($agent->current_form->action, qr{/NoAuth/Login\.html$}, "login form action is correct");
+
+    ok($agent->content =~ /username:/i);
+    $agent->field( 'user' => 'root' );
+    $agent->field( 'pass' => 'password' );
+
+    # the field isn't named, so we have to click link 0
+    $agent->click(0);
+    is( $agent->status, 200, "Fetched the page ok");
+    ok( $agent->content =~ /Logout/i, "Found a logout link");
+
+    if ($path =~ m{/}) {
+        (my $collapsed = $path) =~ s{^/}{};
+        is( $agent->uri, $url.$collapsed, "right URL, with leading slashes in path collapsed" );
+    } else {
+        is( $agent->uri, $requested, "right URL" );
+    }
+
+    like( $agent->{redirected_uri}, qr{/NoAuth/Login\.html}, "We redirected from login");
+    $agent->logout();
+}
+
+# test a bogus login from a non-front page
+{
+    my $requested = $url.'Prefs/Other.html';
+    $agent->get_ok($requested);
+    is($agent->status, 200, "Loaded a page");
+    like($agent->uri, qr'/NoAuth/Login\.html\?next=[a-z0-9]{32}', "on login page, with next page hash");
+    is($agent->{redirected_uri}, $requested, "redirected from our requested page");
+
+    ok($agent->current_form->find_input('user'));
+    ok($agent->current_form->find_input('pass'));
+    ok($agent->current_form->find_input('next'));
+    like($agent->value('next'), qr/^[a-z0-9]{32}$/i, "next page argument is a hash");
+    like($agent->current_form->action, qr{/NoAuth/Login\.html$}, "login form action is correct");
+
+    ok($agent->content =~ /username:/i);
+    $agent->field( 'user' => 'root' );
+    $agent->field( 'pass' => 'wrongpass' );
+
+    # the field isn't named, so we have to click link 0
+    $agent->click(0);
+    is( $agent->status, 200, "Fetched the page ok");
+
+    ok( $agent->content =~ /Your username or password is incorrect/i, "Found the error message");
+    like( $agent->uri, qr{/NoAuth/Login\.html$}, "still on /NoAuth/Login.html" );
+
+    # try to login again
+    ok($agent->current_form->find_input('user'));
+    ok($agent->current_form->find_input('pass'));
+    ok($agent->current_form->find_input('next'));
+    like($agent->value('next'), qr/^[a-z0-9]{32}$/i, "next page argument is a hash");
+    like($agent->current_form->action, qr{/NoAuth/Login\.html$}, "login form action is correct");
+
+    ok($agent->content =~ /username:/i);
+    $agent->field( 'user' => 'root' );
+    $agent->field( 'pass' => 'password' );
+
+    # the field isn't named, so we have to click link 0
+    $agent->click(0);
+    is( $agent->status, 200, "Fetched the page ok");
+
+    # check out where we got to
+    is( $agent->uri, $requested, "right URL" );
+    like( $agent->{redirected_uri}, qr{/NoAuth/Login\.html}, "We redirected from login");
+    $agent->logout();
+
+    # Handle the warning after we're done with the page, since this leaves us
+    # with a completely different $mech
+    $agent->warning_like(qr/FAILED LOGIN for root/, "got failed login warning");
+}
+
+# test a login from the main page with query params
+{
+    my $requested = $url."?user=root;pass=password";
+    $agent->get_ok($requested);
+    is($agent->{'status'}, 200, "Loaded a page");
+    is($agent->uri, $requested, "didn't redirect to /NoAuth/Login.html for base URL");
+    ok($agent->content =~ /Logout/i, "Found a logout link - we're logged in");
+    $agent->logout();
+}
+
+# test a bogus login from the main page with query params
+{
+    my $requested = $url."?user=root;pass=wrongpass";
+    $agent->get_ok($requested);
+    is($agent->{'status'}, 200, "Loaded a page");
+    is($agent->uri, $requested, "didn't redirect to /NoAuth/Login.html for base URL");
+    
+    ok($agent->content =~ /Your username or password is incorrect/i, "Found the error message");
+    ok($agent->current_form->find_input('user'));
+    ok($agent->current_form->find_input('pass'));
+    like($agent->current_form->action, qr{/NoAuth/Login\.html$}, "login form action is correct");
+    
+    # Handle the warning after we're done with the page, since this leaves us
+    # with a completely different $mech
+    $agent->warning_like(qr/FAILED LOGIN for root/, "got failed login warning");
+}
+
+# test a bogus login from a non-front page with query params
+{
+    my $requested = $url."Prefs/Other.html?user=root;pass=wrongpass";
+    $agent->get_ok($requested);
+    is($agent->status, 200, "Loaded a page");
+    like($agent->uri, qr'/NoAuth/Login\.html\?next=[a-z0-9]{32}', "on login page, with next page hash");
+    is($agent->{redirected_uri}, $requested, "redirected from our requested page");
+    ok( $agent->content =~ /Your username or password is incorrect/i, "Found the error message");
+
+    ok($agent->current_form->find_input('user'));
+    ok($agent->current_form->find_input('pass'));
+    ok($agent->current_form->find_input('next'));
+    like($agent->value('next'), qr/^[a-z0-9]{32}$/i, "next page argument is a hash");
+    like($agent->current_form->action, qr{/NoAuth/Login\.html$}, "login form action is correct");
+
+    # Try to login again
+    ok($agent->content =~ /username:/i);
+    $agent->field( 'user' => 'root' );
+    $agent->field( 'pass' => 'password' );
+
+    # the field isn't named, so we have to click link 0
+    $agent->click(0);
+    is( $agent->status, 200, "Fetched the page ok");
+
+    # check out where we got to
+    is( $agent->uri, $requested, "right URL" );
+    like( $agent->{redirected_uri}, qr{/NoAuth/Login\.html}, "We redirected from login");
+    $agent->logout();
+
+    # Handle the warning after we're done with the page, since this leaves us
+    # with a completely different $mech
+    $agent->warning_like(qr/FAILED LOGIN for root/, "got failed login warning");
+}
+
+# test REST login response
+{
+    my $requested = $url."REST/1.0/?user=root;pass=password";
+    $agent->get($requested);
+    is($agent->status, 200, "Loaded a page");
+    is($agent->uri, $requested, "didn't redirect to /NoAuth/Login.html for REST");
+    $agent->get_ok($url);
+    $agent->logout();
+}
+
+# test REST login response for wrong pass
+{
+    my $requested = $url."REST/1.0/?user=root;pass=passwrong";
+    $agent->get_ok($requested);
+    is($agent->status, 200, "Loaded a page");
+    is($agent->uri, $requested, "didn't redirect to /NoAuth/Login.html for REST");
+    like($agent->content, qr/401 Credentials required/i, "got error status");
+    like($agent->content, qr/Your username or password is incorrect/, "got error message");
+    
+    # Handle the warning after we're done with the page, since this leaves us
+    # with a completely different $mech
+    $agent->warning_like(qr/FAILED LOGIN for root/, "got failed login warning");
+}
+
+# test REST login response for no creds
+{
+    my $requested = $url."REST/1.0/";
+    $agent->get_ok($requested);
+    is($agent->status, 200, "Loaded a page");
+    is($agent->uri, $requested, "didn't redirect to /NoAuth/Login.html for REST");
+    like($agent->content, qr/401 Credentials required/i, "got error status");
+    unlike($agent->content, qr/Your username or password is incorrect/, "didn't get any error message");
+}
+
+# XXX TODO: we should also be testing WebExternalAuth here, but we don't have
+# the framework for dealing with that
+
+1;

diff --git a/src/goahead.h b/src/goahead.h
index 46f5fcc0..8929df68 100644
--- a/src/goahead.h
+++ b/src/goahead.h
@@ -2713,6 +2713,18 @@ PUBLIC int websUrlParse(char *url, char **buf, char **protocol, char **host, cha
  */
 PUBLIC bool websValid(Webs *wp);
 
+/**
+    Validate a URI path as expected in a HTTP request line
+    @description This expects a URI beginning with "/" and containing only valid URI characters.
+    The URI is decoded, and normalized removing "../" and "." segments.
+    The URI must begin with a "/" both before and after decoding and normalization.
+    @param uri URI to validate.
+    @return A validated, normalized URI path
+    @ingroup Webs
+    @stability Evolving
+ */
+PUBLIC char *websValidateUriPath(char *uri);
+
 /**
     Write a set of standard response headers
     @param wp Webs request object
diff --git a/src/http.c b/src/http.c
index 905708a3..32cb3fee 100644
--- a/src/http.c
+++ b/src/http.c
@@ -966,7 +966,7 @@ static void parseFirstLine(Webs *wp)
         websError(wp, HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG, "Bad URL");
         return;
     }
-    if ((wp->path = websNormalizeUriPath(path)) == 0) {
+    if ((wp->path = websValidateUriPath(path)) == 0) {
         error("Cannot normalize URL: %s", url);
         websError(wp, HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG, "Bad URL");
         wfree(buf);
@@ -3100,7 +3100,7 @@ PUBLIC int websUrlParse(char *url, char **pbuf, char **pscheme, char **phost, ch
 {
     char    *tok, *delim, *host, *path, *port, *scheme, *reference, *query, *ext, *buf, *buf2;
     ssize   buflen, ulen, len;
-    int     rc;
+    int     rc, sep;
 
     assert(pbuf);
     if (url == 0) {
@@ -3128,6 +3128,7 @@ PUBLIC int websUrlParse(char *url, char **pbuf, char **pscheme, char **phost, ch
     query = 0;
     reference = 0;
     tok = buf;
+    sep = '/';
 
     /*
         [scheme://][hostname[:port]][/path[.ext]][#ref][?query]
@@ -3188,6 +3189,7 @@ PUBLIC int websUrlParse(char *url, char **pbuf, char **pscheme, char **phost, ch
            Terminate hostname. This zeros the leading path slash.
            This will be repaired before returning if ppath is set 
          */
+        sep = *tok;
         *tok++ = '\0';
         path = tok;
         /* path[.ext[/extra]] */
@@ -3230,12 +3232,14 @@ PUBLIC int websUrlParse(char *url, char **pbuf, char **pscheme, char **phost, ch
             /* Copy path to reinsert leading slash */
             scopy(&buf2[1], len - 1, path);
             path = buf2;
-            *path = '/';
+            *path = sep;
+#if UNUSED && MOVED 
             if (!websValidUriChars(path)) {
                 rc = -1;
             } else {
                 websDecodeUrl(path, path, -1);
             }
+#endif
         }
         *ppath = path;
     }
@@ -3256,8 +3260,9 @@ PUBLIC int websUrlParse(char *url, char **pbuf, char **pscheme, char **phost, ch
 
 
 /*
-    Normalize a URI path to remove "./",  "../" and redundant separators. Note: this does not make an abs path and 
-    does not map separators nor change case. 
+    Normalize a URI path to remove "./",  "../" and redundant separators. 
+    Note: this does not make an abs path and does not map separators nor change case. 
+    This validates the URI and expects it to begin with "/".
  */
 PUBLIC char *websNormalizeUriPath(char *pathArg)
 {
@@ -3296,20 +3301,19 @@ PUBLIC char *websNormalizeUriPath(char *pathArg)
         if (sp[0] == '.') {
             if (sp[1] == '\0')  {
                 if ((i+1) == nseg) {
+                    /* Trim trailing "." */
                     segments[j] = "";
                 } else {
                     j--;
                 }
             } else if (sp[1] == '.' && sp[2] == '\0')  {
-                if (i == 1 && *segments[0] == '\0') {
-                    j = 0;
-                } else if ((i+1) == nseg) {
-                    if (--j >= 0) {
-                        segments[j] = "";
-                    }
-                } else {
-                    j = max(j - 2, -1);
+                j = max(j - 2, -1);
+                if ((i+1) == nseg) {
+                    nseg--;
                 }
+            } else {
+                /* .more-chars */
+                segments[j] = segments[i];
             }
         } else {
             segments[j] = segments[i];
@@ -3337,6 +3341,31 @@ PUBLIC char *websNormalizeUriPath(char *pathArg)
 }
 
 
+/*
+    Validate a URI path for use in a HTTP request line
+    The URI must contain only valid characters and must being with "/" both before and after decoding.
+    A decoded, normalized URI path is returned.
+    The uri is modified.
+ */
+PUBLIC char *websValidateUriPath(char *uri)
+{
+    if (uri == 0 || *uri != '/') {
+        return 0;
+    }
+    if (!websValidUriChars(uri)) {
+        return 0;
+    }
+    websDecodeUrl(uri, uri, -1);
+    if ((uri = websNormalizeUriPath(uri)) == 0) {
+        return 0;
+    }
+    if (*uri != '/' || strchr(uri, '\\')) {
+        return 0;
+    }
+    return uri;
+}
+
+
 /*
     Open a web page. filename is the local filename. path is the URL path name.
  */
diff --git a/test/security/dos.tst b/test/security/dos.tst
index 1bf94612..cf4dbe58 100644
--- a/test/security/dos.tst
+++ b/test/security/dos.tst
@@ -2,7 +2,7 @@
     Denial of service testing
  */
 
-const HTTP: Uri = App.config.uris.http || "127.0.0.1:4100"
+const HTTP: Uri = App.config.uris.http || "127.0.0.1:8080"
 
 //  Check server available
 http = new Http
diff --git a/test/security/huge-uri.tst b/test/security/huge-uri.tst
index 80e5a18b..ed13fb88 100644
--- a/test/security/huge-uri.tst
+++ b/test/security/huge-uri.tst
@@ -1,7 +1,7 @@
 /*
     Very large URI test
  */ 
-const HTTP: Uri = App.config.uris.http || "127.0.0.1:4100"
+const HTTP: Uri = App.config.uris.http || "127.0.0.1:8080"
 
 //  This writes a ~100K URI. LimitUri should be less than 100K for this unit test.
 
diff --git a/test/security/traversal.tst b/test/security/traversal.tst
new file mode 100644
index 00000000..07bcbb0b
--- /dev/null
+++ b/test/security/traversal.tst
@@ -0,0 +1,29 @@
+/*
+    Test directory traversal
+ */
+
+const HTTP: Uri = App.config.uris.http || "127.0.0.1:8080"
+
+http = new Http
+http.get(HTTP + "/../../appweb.conf")
+assert(http.status == 400)
+http.close()
+
+http.get(HTTP + "/../../index.html")
+assert(http.status == 400)
+http.close()
+
+/* Test windows '\' delimiter */
+http.get(HTTP + "/..%5Cappweb.conf")
+if (Config.OS == 'windows') {
+    /* for windows, the "..\\" is an invalid filename */
+    assert(http.status == 404)
+} else {
+    assert(http.status == 400)
+}
+http.close()
+
+http.get(HTTP + "/../../../../../.x/.x/.x/.x/.x/.x/etc/passwd")
+assert(http.status == 400)
+http.close()
+
diff --git a/test/security/uri.tst b/test/security/uri.tst
new file mode 100644
index 00000000..6f143b14
--- /dev/null
+++ b/test/security/uri.tst
@@ -0,0 +1,32 @@
+/*
+    Uri validation
+ */
+
+const HTTP: Uri = App.config.uris.http || "127.0.0.1:8080"
+
+function get(uri): String {
+    let s = new Socket
+    s.connect(HTTP.address)
+    let count = 0
+    try {
+        count += s.write("GET " + uri + " HTTP/1.0\r\n\r\n")
+    } catch {
+        tfail("Write failed. Wrote  " + count + " of " + data.length + " bytes.")
+    }
+    let response = new ByteArray
+    while ((n = s.read(response, -1)) != null ) {}
+    s.close()
+    return response.toString()
+}
+
+/*
+let response
+response = get('index.html')
+assert(response.toString().contains('Not Found'))
+
+response = get('/\x01index.html')
+assert(response.toString().contains('Bad Request'))
+*/
+
+response = get('\\index.html')
+assert(response.toString().contains('Bad Request'))

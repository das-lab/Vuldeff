#!/usr/bin/perl -w
#
# Copyright (c) 2006, 2007 Michael Schroeder, Novell Inc.
# Copyright (c) 2008 Adrian Schroeter, Novell Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################
#
# The Source Server
#

BEGIN {
  my ($wd) = $0 =~ m-(.*)/- ;
  $wd ||= '.';
  chdir($wd);
  unshift @INC,  "$wd/build";
  unshift @INC,  "$wd";
}

use XML::Structured ':bytes';
use POSIX;
use Digest::MD5 ();
use Data::Dumper;
use Storable ();
use Symbol;
use MIME::Base64 ();
use JSON::XS ();

use BSConfiguration;
use BSRPC ':https';
use BSServer;
use BSUtil;
use BSFileDB;
use BSXML;
use BSProductXML;
use BSVerify;
use BSHandoff;
use BSWatcher ':https';
use BSXPath;
use BSStdServer;
use BSSrcdiff;
use Build;
use BSNotify;

use BSXPath;
use BSXPathKeys;
use BSDB;
use BSDBIndex;

$Build::Rpm::unfilteredprereqs = 1 if defined $Build::Rpm::unfilteredprereqs;

use strict;

my $port = 5352;	#'SR'
$port = $1 if $BSConfig::srcserver =~ /:(\d+)$/;
my $proxy;
$proxy = $BSConfig::proxy if defined($BSConfig::proxy);

BSUtil::set_fdatasync_before_rename() unless $BSConfig::disable_data_sync || $BSConfig::disable_data_sync;

my $projectsdir = "$BSConfig::bsdir/projects";
my $eventdir = "$BSConfig::bsdir/events";
my $srcrep = "$BSConfig::bsdir/sources";
my $treesdir = $BSConfig::nosharedtrees ? "$BSConfig::bsdir/trees" : $srcrep;
my $requestsdir = "$BSConfig::bsdir/requests";
my $oldrequestsdir = "$BSConfig::bsdir/requests.old";
my $rundir = $BSConfig::rundir || "$BSConfig::bsdir/run";
my $diffcache = "$BSConfig::bsdir/diffcache";

my $reqindexdb = "$BSConfig::bsdir/db/request";
my $extrepodb = "$BSConfig::bsdir/db/published";
my $sourcedb = "$BSConfig::bsdir/db/source";

my $remotecache = "$BSConfig::bsdir/remotecache";
my $notificationpayloaddir = "$BSConfig::bsdir/notificationpayload";

my $srcrevlay = [qw{rev vrev srcmd5 version time user comment requestid}];
my $eventlay = [qw{number time type project package repository arch}];
my $notificationlay = [qw{number type time data []}];


my $ajaxsocket = "$rundir/bs_srcserver.ajax";
my $uploaddir = "$srcrep/:upload";

my @binsufs = qw{rpm deb pkg.tar.gz pkg.tar.xz};
my $binsufsre = join('|', map {"\Q$_\E"} @binsufs);

my $repoid;
my %packagequota;

# This is the md5sum of an empty file
my $emptysrcmd5 = 'd41d8cd98f00b204e9800998ecf8427e';

# remote getrev cache
my $collect_remote_getrev;
my $remote_getrev_todo;
my %remote_getrev_cache;
my $frozenlinks_cache;

sub notify {
  my ($type, $p) = @_;
  my $time = $p->{'time'} || time();
  delete $p->{'time'};
  if ($type eq 'PACKTRACK' && BSServer::have_content()) {
    my $payload = Storable::thaw(BSServer::read_data());
    if ($payload) {
      my $json_payload = JSON::XS::encode_json($payload);
      my $payloadkey = "$time.".Digest::MD5::md5_hex($json_payload);
      mkdir_p($notificationpayloaddir);
      writestr("$notificationpayloaddir/.$payloadkey", "$notificationpayloaddir/$payloadkey", $json_payload);
      $p->{'payload'} = $payloadkey;
      print "notification payload for $p->{'project'}/$p->{'repo'} stored in $payloadkey\n" if $p->{'project'} && $p->{'repo'};
    }
  }
  my @n = map {"$_=$p->{$_}"} grep {defined($p->{$_}) && !ref($p->{$_})} sort keys %{$p || {}};
  mkdir_p($eventdir);
  BSFileDB::fdb_add_i("$eventdir/lastnotifications", $notificationlay, {'type' => $type, 'time' => $time, 'data' => \@n});
}

sub prune_notificationpayloads {
  my ($cuttime) = @_;
  my @pl = ls($notificationpayloaddir);
  for my $p (@pl) {
    next unless $p =~ /^(\d+)\./;
    unlink("$notificationpayloaddir/$p") if $1 < $cuttime;
  }
}

sub prune_lastnotifications {
  my ($cutoff) = @_;
  local *F;
  return unless BSUtil::lockopen(\*F, '<', "$eventdir/lastnotifications", 1);
  my $filter = sub { $_[0]->{'number'} >= $cutoff ? 1 : 0 };
  my @l = BSFileDB::fdb_getall("$eventdir/lastnotifications", $notificationlay, undef, $filter);
  if (@l) {
    unlink("$eventdir/.lastnotifications.$$");
    if (! -e "$eventdir/.lastnotifications.$$") {
      BSFileDB::fdb_add_multiple("$eventdir/.lastnotifications.$$", $notificationlay, @l);
      rename("$eventdir/.lastnotifications.$$", "$eventdir/lastnotifications") || die("rename $eventdir/.lastnotifications.$$ $eventdir/lastnotifications: $!\n");
      prune_notificationpayloads($l[0]->{'time'} - 240 * 3600) if -d $notificationpayloaddir;	# keep 10 days
    }
  }
  close F;
}

sub lastnotifications {
  my ($cgi) = @_;
  my $view = $cgi->{'view'};
  die("unsupported view\n") if $view && $view ne 'json';
  if (!$cgi->{'start'}) {
    # just fetch the current event number
    my $lastev = BSFileDB::fdb_getlast("$eventdir/lastnotifications", $notificationlay);
    my $lastno = $lastev ? $lastev->{'number'} : 0;
    my $ret = {'next' => $lastno + 1, 'sync' => 'lost'};
    return (JSON::XS::encode_json($ret), 'Content-Type: application/json') if $view && $view eq 'json';
    return ($ret, $BSXML::notifications);
  }
  # check if we need to prune
  if (!$BSStdServer::isajax && !$cgi->{'noprune'}) {
    my $firstev = (BSFileDB::fdb_getall("$eventdir/lastnotifications", $notificationlay, undef, sub {-1}))[0];
    if ($firstev && $cgi->{'start'} - $firstev->{'number'} > 1000) {
      my $lastev = BSFileDB::fdb_getlast("$eventdir/lastnotifications", $notificationlay);
      prune_lastnotifications($cgi->{'start'} - 500) if $lastev && $cgi->{'start'} <= $lastev->{'number'} + 1;
    }
  }
  my $filter = sub { $cgi->{'start'} > $_[0]->{'number'} ? -2 : 1 };
  my @l = BSFileDB::fdb_getall_reverse("$eventdir/lastnotifications", $notificationlay, undef, $filter);
  if ($cgi->{'block'} && !@l) {
    # pass on to AJAX
    if (!$BSStdServer::isajax) {
      my @args;
      push @args, "start=$cgi->{'start'}";
      push @args, "block=1";
      BSHandoff::handoff($ajaxsocket, '/lastnotifications', undef, @args);
      exit(0);
    }
    # wait untill we have a winner
    BSWatcher::addfilewatcher("$eventdir/lastnotifications");
    my $lastev = BSFileDB::fdb_getlast("$eventdir/lastnotifications", $notificationlay);
    return undef if !$lastev || $lastev->{'number'} < $cgi->{'start'};
    if ($cgi->{'start'} == $lastev->{'number'}) {
      @l = ($lastev);
    } else {
      @l = BSFileDB::fdb_getall_reverse("$eventdir/lastnotifications", $notificationlay, undef, $filter);
      return undef unless @l;
    }
  }
  my $res = {};
  @l = reverse @l;
  if (@l) {
    $res->{'next'} = $l[-1]->{'number'} + 1;
  } else {
    my $lastev = BSFileDB::fdb_getlast("$eventdir/lastnotifications", $notificationlay);
    my $no = ($lastev->{'number'} || 0);
    $no = $cgi->{'start'} - 1 if $no >= $cgi->{'start'};
    $res->{'next'} = $no + 1;
  }
  if (@l && $l[0]->{'number'} > $cgi->{'start'}) {
    $res->{'sync'} = 'lost';
    @l = ();
  }
  # don't send more than 1000 notifications to the poor api
  if (@l > 1000) {
    $res->{'limit_reached'} = 1; # tell the api that there is more
    $res->{'next'} = $l[1000]->{'number'};
    @l = splice(@l, 0, 1000);
  }
  $res->{'notification'} = \@l;
  delete $_->{'number'} for @l;		# XXX: why?
  if ($view && $view eq 'json') {
    for my $l (@l) {
      my %d;
      for (@{$l->{'data'} || []}) {
        my @s = split('=', $_, 2);
        $d{$s[0]} = $s[1];
      }
      $l->{'data'} = \%d;
    }
    return (JSON::XS::encode_json($res), 'Content-Type: application/json');
  }
  for my $l (@l) {
    for (@{$l->{'data'} || []}) {
      my @s = split('=', $_, 2);
      $_ = {'key' => $s[0]};
      $_->{'_content'} = $s[1] if defined $s[1];
    }
  }
  return ($res, $BSXML::notifications);
}

sub getnotificationpayload {
  my ($cgi, $payloadkey) = @_;
  my $file = "$notificationpayloaddir/$payloadkey";
  die("404 payload does not exist!\n") unless -e $file;
  return (readstr($file), 'Content-Type: application/json');
}

sub deletenotificationpayload {
  my ($cgi, $payloadkey) = @_;
  unlink("$notificationpayloaddir/$payloadkey");
  return $BSStdServer::return_ok;
}

sub notify_repservers {
  my ($type, $projid, $packid) = @_;

  my $ev = {'type' => $type, 'project' => $projid};
  $ev->{'package'} = $packid if defined $packid;
  addevent($ev);

  my @args = ("type=$type", "project=$projid");
  push @args, "package=$packid" if defined $packid;
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $param = {
    'uri' => "$reposerver/event",
    'request'   => 'POST',
    'background' => 1,
  };
  eval {
    BSWatcher::rpc($param, undef, @args);
  };
  print "warning: $reposerver: $@" if $@;
}

# this is only used from getfilelist_ajax.
# as projid is a remote project, we don't know which reposerver
# we need to notify. so send the event to all of them.
# we also do not call addevent in this specific case.
sub notify_all_repservers {
  my ($type, $projid, $packid) = @_;

  my %reposervers;
  if ($BSConfig::partitioning) {
    %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);
  } else {
    %reposervers = ($BSConfig::reposerver => 1);
  }
  my @args = ("type=$type", "project=$projid");
  push @args, "package=$packid" if defined $packid;
  for my $reposerver (sort keys %reposervers) {
    my $param = {
      'uri' => "$reposerver/event",
      'request'   => 'POST',
      'background' => 1,
    };
    eval {
      BSWatcher::rpc($param, undef, @args);
    };
    print "warning: $reposerver: $@" if $@;
  }
}

# check if a service run is needed for the upcoming commit
sub genservicemark {
  my ($projid, $packid, $files, $rev, $force) = @_;
  
  return undef if $BSConfig::old_style_services;

  return undef if $packid eq '_project';	# just in case...
  return undef if defined $rev;	# don't mark if upload/repository/internal
  return undef if $packid eq '_pattern' || $packid eq '_product';	# for now...
  return undef if $files->{'/SERVICE'};	# already marked

  # check if we really need to run the service
  if (!$files->{'_service'} && !$force) {
    # XXX: getprojectservices may die!
    my ($projectservices, undef) = getprojectservices({}, $projid, $packid);
    return undef unless $projectservices && $projectservices->{'service'} && @{$projectservices->{'service'}};
  }

  # argh, somewhat racy. luckily we just need something unique...
  # (files is not unique enough because we want a different id
  # for each commit, even if it has the same srcmd5)
  # (maybe we should use the same time as in the upcoming rev)
  my $smd5 = "sourceservice/$projid/$packid/".time()."\n";
  eval {
    my $rev_old = getrev($projid, $packid);
    $smd5 .= "$rev_old->{'rev'}" if $rev_old->{'rev'};
  };
  $smd5 .= "$files->{$_}  $_\n" for sort keys %$files;
  $smd5 = Digest::MD5::md5_hex($smd5);

  # return the mark
  return $smd5;
}

# called from runservice when the service run is finished. it
# either does the service commit (old style), or creates the
# xsrcmd5 service revision (new style).
sub addrev_service {
  my ($cgi, $rev, $files, $error) = @_;

  if ($error) {
    chomp $error;
    $error ||= 'unknown service error';
  }
  my $projid = $rev->{'project'};
  my $packid = $rev->{'package'};
  if (!$files->{'/SERVICE'}) {
    # old style, do a commit
    if ($error) {
      mkdir_p($uploaddir);
      writestr("$uploaddir/_service_error$$", undef, "$error\n");
      $files->{'_service_error'} = addfile($projid, $packid, "$uploaddir/_service_error$$", '_service_error');
    }
    addrev({%{$cgi || {}}, 'user' => '_service', 'comment' => 'generated via source service', 'noservice' => 1}, $projid, $packid, $files);
    return;
  }
  # new style services
  if ($files->{'_service_error'} && !$error) {
    $error = repreadstr($rev, '_service_error', $files->{'_service_error'});
    chomp $error;
    $error ||= 'unknown service error';
  }
  my $srcmd5 = $files->{'/SERVICE'};
  if ($error) {
    addmeta_serviceerror($projid, $packid, $srcmd5, $error);
    $error =~ s/[\r\n]+$//s;
    $error =~ s/.*[\r\n]//s;
    $error = str2utf8xml($error) || 'unknown service error';
  } else {
    addmeta_service($projid, $packid, $files, $srcmd5, $rev->{'srcmd5'});
  }
  my $user = $cgi->{'user'};
  my $comment = $cgi->{'comment'};
  my $requestid = $cgi->{'requestid'};
  $user = '' unless defined $user;
  $user = 'unknown' if $user eq '';
  $user = str2utf8xml($user);
  $comment = '' unless defined $comment;
  $comment = str2utf8xml($comment);
  if ($error) {
    notify('SRCSRV_SERVICE_FAIL', {project => $projid, package => $packid,
				   error => $error, rev => $rev->{'rev'},
				   user => $user, comment => $comment,
				   'requestid' => $requestid});
  } else {
    notify('SRCSRV_SERVICE_SUCCESS', {project => $projid, package => $packid,
				      rev => $rev->{'rev'},
				      user => $user, comment => $comment,
				      'requestid' => $requestid});
  }
}

# store the faked result of a service run. Note that this is done before
# the addrev call that stores the reference to the run.
# only used for new style services.
sub fake_service_run {
  my ($projid, $packid, $files, $sfiles, $servicemark) = @_;
  $files->{'/SERVICE'} = $servicemark;
  $sfiles->{'/SERVICE'} = $servicemark;
  my $nsrcmd5 = calcsrcmd5($files);
  addrev_service({}, {'project' => $projid, 'package' => $packid, 'srcmd5' => $nsrcmd5}, $sfiles);
  delete $files->{'/SERVICE'};
  delete $sfiles->{'/SERVICE'};
}

# called *after* addrev to trigger service run
sub runservice {
  my ($cgi, $rev, $files) = @_;

  return if !$BSConfig::old_style_services && !$files->{'/SERVICE'};

  my $projid = $rev->{'project'};
  my $packid = $rev->{'package'};
  die("No project defined for source update!") unless defined $projid;
  die("No package defined for source update!") unless defined $packid;
  return if $packid eq '_project';

  my $oldfiles = {};
  if ($files->{'/SERVICE'}) {
    # check serialization
    return unless addmeta_serialize_servicerun($rev->{'project'}, $rev->{'package'}, $files->{'/SERVICE'});
    # get last servicerun result into oldfiles hash
    my $revno = $rev->{'rev'};
    if (length($revno || '') >= 32) {
      # argh, find commit for that srcmd5
      $revno = (findlastrev($rev) || {})->{'rev'};
    }
    while ($revno && $revno > 1) {
      $revno = $revno - 1;	# get the commit before this one
      eval {
        my $oldfilerev = getrev($projid, $packid, $revno);
	$oldfiles = lsrev_service($oldfilerev) || {};
      };
      if ($@) {
        warn($@);
        next if $@ =~ /service in progress/;
      }
      $oldfiles = {} if !$oldfiles || $oldfiles->{'_service_error'};
      # strip all non-service results;
      delete $oldfiles->{$_} for grep {!/^_service:/} keys %$oldfiles;
      last;
    }
  }

  return if $packid eq '_project';
  return if $rev->{'rev'} && ($rev->{'rev'} eq 'repository' || $rev->{'rev'} eq 'upload');

  # die when a source service is still running
  my $lockfile = "$eventdir/service/${projid}::$packid";
  die("403 service still running\n") if $cgi->{'triggerservicerun'} && -e $lockfile;

  my $projectservices;
  eval {
    ($projectservices, undef) = getprojectservices({}, $projid, $packid);
  };
  if ($@) {
    addrev_service($cgi, $rev, $files, $@);
    return;
  }
  undef $projectservices unless $projectservices && $projectservices->{'service'} && @{$projectservices->{'service'}};

  # collect current sources to POST them
  if (!$files->{'_service'} && !$projectservices) {
    die("404 no source service defined!\n") if $cgi->{'triggerservicerun'};
    # drop all existing service files
    my $dirty;
    for my $pfile (keys %$files) {
      if ($pfile =~ /^_service[_:]/) {
        delete $files->{$pfile};
        $dirty = 1;
      }
    }
    if ($dirty || $files->{'/SERVICE'}) {
      addrev_service($cgi, $rev, $files);
      notify_repservers('package', $projid, $packid);
    }
    return;
  }

  my $linkfiles;
  if ($files->{'_link'}) {
    # make sure it's a branch
    my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link, 1);
    if (!$l || !$l->{'patches'} || @{$l->{'patches'}->{''} || []} != 1 || (keys %{$l->{'patches'}->{''}->[0]})[0] ne 'branch') {
      #addrev_service($cgi, $rev, $files, "services only work on branches\n");
      #notify_repservers('package', $projid, $packid);
      #return;
      # uh oh, not a branch!
      $linkfiles = { %$files };
      delete $files->{'/SERVICE'};
      eval {
        $files = handlelinks({%$rev, 'linkrev' => 'base'}, $files);
        die("bad link: $files\n") unless ref $files;
      };
      if ($@) {
	if (($@ =~ /service in progress/) && $linkfiles->{'/SERVICE'}) {
	  # delay, hope for an event. remove lock for now to re-trigger the service run.
	  addmeta_serviceerror($rev->{'project'}, $rev->{'package'}, $linkfiles->{'/SERVICE'}, undef);
	  return;
	}
        $files = $linkfiles;
        addrev_service($cgi, $rev, $files, $@);
        notify_repservers('package', $projid, $packid);
        return;
      }
      $files->{'/SERVICE'} = $linkfiles->{'/SERVICE'} if $linkfiles->{'/SERVICE'}
    }
  }

  return unless $BSConfig::serviceserver;

  if (!$files->{'/SERVICE'}) {
    mkdir_p("$eventdir/service");
    BSUtil::touch($lockfile);
  }

  my @send = map {{'name' => $_, 'filename' => "$srcrep/$packid/$files->{$_}-$_"}} grep {$_ ne '/SERVICE'} sort(keys %$files);
  push @send, {'name' => '_serviceproject', 'data' => XMLout($BSXML::services, $projectservices)} if $projectservices;
  push @send, map {{'name' => $_, 'filename' => "$srcrep/$packid/$oldfiles->{$_}-$_"}} grep {!$files->{$_}} sort(keys %$oldfiles);

  # run the source update in own process (do not wait for it)
  my $pid = xfork();
  return if $pid;

  # child continues...
  my $odir = "$srcrep/:service/$$";
  BSUtil::cleandir($odir) if -d $odir;
  mkdir_p($odir);
  my $receive;
  eval {
    $receive = BSRPC::rpc({
      'uri'       => "$BSConfig::serviceserver/sourceupdate/$projid/$packid",
      'request'   => 'POST',
      'headers'   => [ 'Content-Type: application/x-cpio' ],
      'chunked'   => 1,
      'data'      => \&BSHTTP::cpio_sender,
      'cpiofiles' => \@send,
      'directory' => $odir,
      'timeout'   => 3600,
      'withmd5'   => 1,
      'receiver' => \&BSHTTP::cpio_receiver,
    }, undef);
  };

  my $error = $@;
  
  # make sure that there was no other commit in the meantime
  if (!$files->{'/SERVICE'}) {
    my $newrev = getrev($projid, $packid);
    if ($newrev->{'rev'} ne $rev->{'rev'}) {
      unlink($lockfile);
      exit(1);
    }
  }

  # and update source repository with the result
  if ($receive) {
    # drop all existing service files
    for my $pfile (keys %$files) {
      delete $files->{$pfile} if $pfile =~ /^_service[_:]/;
    }
    # add new service files
    eval {
      for my $pfile (ls($odir)) {
        if ($pfile eq '.errors') {
          my $e = readstr("$odir/.errors");
          $e ||= 'empty .errors file';
          die($e);
        }
	unless ($pfile =~ /^_service[_:]/) {
	  unlink($lockfile);
	  die("service returned a non-_service file: $pfile\n");
	}
	BSVerify::verify_filename($pfile);
	$files->{$pfile} = addfile($projid, $packid, "$odir/$pfile", $pfile);
      }
    };
    $error = $@ if $@;
  } else {
    $error ||= 'error';
    $error = "service daemon error:\n $error";
  }
  if ($linkfiles) {
    # argh, a link! put service run result in old filelist
    if (!$error) {
      $linkfiles->{$_} = $files->{$_} for grep {/^_service[_:]/} keys %$files;
    }
    $files = $linkfiles;
  }
  addrev_service($cgi, $rev, $files, $error);
  BSUtil::cleandir($odir);
  rmdir($odir);
  unlink($lockfile);
  notify_repservers('package', $projid, $packid);
  exit(0);
}

sub triggerservicerun {
  my ($cgi, $projid, $packid) = @_;
  my $rev = getrev($projid, $packid);
  my $linkinfo = {};
  my $files = lsrev($rev, $linkinfo);
  $cgi->{'triggerservicerun'} = 1;	# hack
  if ($BSConfig::old_style_services) {
    # old style, just run the service again...
    runservice($cgi, $rev, $files);
  } else {
    my $servicemark = genservicemark($projid, $packid, $files);
    if ($servicemark || $linkinfo->{'xservicemd5'} || $packid eq '_product') {
      # have to do a new commit...
      $cgi->{'comment'} ||= 'trigger service run';
      $cgi->{'servicemark'} = $servicemark;
      $rev = addrev($cgi, $projid, $packid, $files);
      runservice($cgi, $rev, $files);
    } else {
      die("404 no source service defined!\n");
    }
  }
  return $BSStdServer::return_ok;
}

#
# run the productconverter on _product to create/update/delete
# all _product:xxx packages
#
sub expandproduct {
  my ($projid, $packid, $rev, $files, $user, $fail) = @_;

  if (!$files) {
    # gone!
    # {} argument makes findpackages ignore packages from project links
    my @packages = grep {/^\Q${packid}:\E/} findpackages($projid, {});
    for my $opid (@packages) {
      unlink("$projectsdir/$projid.pkg/$opid.upload-MD5SUMS");
      unlink("$projectsdir/$projid.pkg/$opid.rev");
      unlink("$projectsdir/$projid.pkg/$opid.xml");
      notify_repservers('package', $projid, $opid);
    }
    return 1;
  }
  if ($files->{'_link'}) {
    eval {
      $files = handlelinks({ %$rev, 'project' => $projid, 'package' => $packid }, $files);
      die("$files\n") unless ref $files;
    };
    if ($@) {
      die($@) if $fail;
      return undef;
    }
  }
  my $dir = "$uploaddir/expandproduct_$$";
  BSUtil::cleandir($dir);
  mkdir_p($dir);
  for my $file (sort keys %$files) {
    link("$srcrep/$packid/$files->{$file}-$file", "$dir/$file") || die("link $srcrep/$packid/$files->{$file}-$file $dir/$file: $!\n");
  }
  my @prods = grep {/.product$/}  sort keys %$files;
  my %pids;
  for my $prod (@prods) {
    print "converting product $prod\n";
    my $odir = "$dir/$prod.out";
    my $olog = "$dir/$prod.logfile";
    system('rm', '-rf', $odir) if -d $odir;
    unlink($olog) if -e $olog;
    mkdir_p($odir);
    # run product converter and read stdout
    my $pid;
    if (!($pid = xfork())) {
      delete $SIG{'__DIE__'};
      open(STDOUT, '>>', $olog) || die("$olog: $!\n");
      open(STDERR, '>&STDOUT');
      $| = 1;
      exec("./bs_productconvert", "$dir/$prod", $odir, $projid);
      die("500 bs_productconvert: $!\n");
    }
    waitpid($pid, 0) == $pid || die("500 waitpid $pid: $!\n");
    if ($?) {
      my $s = readstr($olog);
      $s =~ s/^\n+//s;
      $s =~ s/\n+$//s;
      warn("bs_productconvert failed: $?\n");
      BSUtil::cleandir($dir);
      rmdir($dir);
      die("$s\n") if $fail;
      return undef;
    }
    my @out = sort(ls($odir));
    if (!@out) {
      warn("bs_productconvert produced nothing\n");
      BSUtil::cleandir($dir);
      rmdir($dir);
      return undef;
    }
    for my $p (@out) {
      my $pdir = "$odir/$p";
      my $pid = $p;
      $pid =~ s/^_product[_:]//;
      $pid =~ s/[:\000-\037]/_/sg;
      $pid = "$packid:$pid";
      $pids{$pid} = 1;
      my %pfiles;
      for my $pfile (sort(ls($pdir))) {
        next if $pfile eq '_meta';
	$pfiles{$pfile} = addfile($projid, $pid, "$pdir/$pfile", $pfile);
      }
      my $srcmd5 = addmeta($projid, $pid, \%pfiles);
      my @oldrevs = BSFileDB::fdb_getall("$projectsdir/$projid.pkg/$pid.rev", $srcrevlay);
      if (@oldrevs == 1 && $oldrevs[0]->{'srcmd5'} eq $srcmd5 && $oldrevs[0]->{'rev'}) {
	# we're lucky, no change
	next;
      }
      mkdir_p("$projectsdir/$projid.pkg");
      my $prev = {'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => 'autogenerated', 'version' => '1', 'vrev' => '1'};
      #unlink("$projectsdir/$projid.pkg/$pid.rev");
      #BSFileDB::fdb_add_i2("$projectsdir/$projid.pkg/$pid.rev", $srcrevlay, $prev, 'vrev', 'version', $prev->{'version'});
      BSFileDB::fdb_add_i("$projectsdir/$projid.pkg/$pid.rev", $srcrevlay, $prev);
      if (! -e "$projectsdir/$projid.pkg/$pid.xml") {
        my $pidpack = {
         'name' => $pid,
         'title' => $pid,
         'description' => "autogenerated from $packid by source server",
        };
	$pidpack = readxml("$pdir/_meta", $BSXML::pack, 0) if ( -e "$pdir/_meta" );
	writexml("$projectsdir/$projid.pkg/.$pid.xml", "$projectsdir/$projid.pkg/$pid.xml", $pidpack, $BSXML::pack);
      }
      rmdir($pdir);
      notify_repservers('package', $projid, $pid);
    }
    rmdir($odir);
  }
  BSUtil::cleandir($dir);
  rmdir($dir);
  # now do away with the old packages
  my @packages = grep {/^\Q${packid}:\E/} findpackages($projid, {});
  @packages = grep {!$pids{$_}} @packages;
  for my $opid (@packages) {
    unlink("$projectsdir/$projid.pkg/$opid.upload-MD5SUMS");
    unlink("$projectsdir/$projid.pkg/$opid.rev");
    unlink("$projectsdir/$projid.pkg/$opid.xml");
    notify_repservers('package', $projid, $opid);
  }
  return 1;
}

#
# return version and release of commit
#
sub getcommitinfo {
  my ($projid, $packid, $srcmd5, $files) = @_;

  # get version/release from rpm spec/deb dsc/kiwi xml file
  my $version = 'unknown';
  my $release;
  if ($files->{'_link'}) {
    # can't know the version/release of a link as it is
    # a moving target
    return ('unknown', '0');
  }
  my $cfile;
  $cfile = "$projectsdir/$projid.conf" if -e "$projectsdir/$projid.conf";
  my $bconf = Build::read_config('noarch', $cfile);
  for my $type ('spec', 'dsc', 'kiwi') {
    my $rev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $srcmd5};
    my (undef, $file) = findfile($rev, undef, $type, $files);
    next unless defined $file;
    my $d = Build::parse($bconf, "$srcrep/$packid/$files->{$file}-$file");
    next unless defined $d->{'version'};
    $version = $d->{'version'};
    $release = $d->{'release'} if defined $d->{'release'};
    $version = 'unknown' if $d->{'multiversion'};
    last;
  }
  if (defined($release)) {
    if ($release =~ /(\d+)\.<B_CNT>/) {
      $release = $1;
    } elsif ($release =~ /<RELEASE(\d+)>/) {
      $release = $1;
    } elsif ($release =~ /^(\d+)/) {
      $release = $1;
    } else {
      $release = '0';
    }
  }
  $release ||= '0';
  if ($bconf->{'cicntstart'} && $bconf->{'cicntstart'} =~ /(\d+)$/) {
    my $r = $release;
    $release = $bconf->{'cicntstart'};
    $release =~  s/\d+$/$r/ if $r > $1;
  }
  return ($version, $release);
}

sub checksourceaccess {
  my ($projid, $packid) = @_;

  my $proj = readproj($projid, 1);
  return unless $proj;
  my $pack = readpack($projid, $packid, 1);
  my $sourceaccess = 1;
  $sourceaccess = BSUtil::enabled('', $proj->{'sourceaccess'}, $sourceaccess, '');
  $sourceaccess = BSUtil::enabled('', $pack->{'sourceaccess'}, $sourceaccess, '') if $pack;
  die("403 source access denied\n") unless $sourceaccess;
  my $access = 1;
  $access = BSUtil::enabled('', $proj->{'access'}, $access, '');
  $access = BSUtil::enabled('', $pack->{'access'}, $access, '') if $pack;
  die("404 package '$packid' does not exist\n") unless $access;	# hmm...
  return 1;
}

###########################################################################
###
###  low level source handling: tree and revision management
###

sub repgitdir {
  my ($rev) = @_;
  my $projid = $rev->{'project'};
  my $packid = $rev->{'package'};
  my $gitdir = "$projectsdir/$projid.pkg/$packid.git";
  die("$projid/$packid is not a git repository\n") unless -d $gitdir;
  return $gitdir;
}

sub repstat_git {
  my ($rev, $filename, $id) = @_;
  my $gitdir = repgitdir($rev);
  open(F, '-|', 'git', "--git-dir=$gitdir", 'cat-file', '-s', $id) || return ();
  my $size= '';
  1 while sysread(F, $size, 4096, length($size));
  if (!close(F)) {
    $! = POSIX::ENOENT;
    return ();
  }
  my @s = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  $s[7] = 0 + $size;
  return @s;
}

sub repopen_git {
  my ($rev, $filename, $id, $fd) = @_;
  my $gitdir = repgitdir($rev);
  return open($fd, '-|', 'git', "--git-dir=$gitdir", 'cat-file', 'blob', $id);
}


sub repstat {
  my ($rev, $filename, $md5) = @_;
  return repstat_git($rev, $filename, $md5) if length($md5) == 40;
  return stat(repfilename($rev, $filename, $md5)) if $filename eq '_serviceerror';
  return stat("$srcrep/$rev->{'package'}/$md5-$filename");
}

sub repopen {
  my ($rev, $filename, $md5, $fd) = @_;
  return repopen_git($rev, $filename, $md5, $fd) if length($md5) == 40;
  return open($fd, '<', repfilename($rev, $filename, $md5)) if $filename eq '_serviceerror';
  return open($fd, '<', "$srcrep/$rev->{'package'}/$md5-$filename");
}

sub repreadstr {
  my ($rev, $filename, $md5, $nonfatal) = @_;
  my $packid = $rev->{'package'};
  return readstr("$srcrep/$packid/$md5-$filename", $nonfatal);
}

sub repreadxml {
  my ($rev, $filename, $md5, $dtd, $nonfatal) = @_;
  my $packid = $rev->{'package'};
  return readxml("$srcrep/$packid/$md5-$filename", $dtd, $nonfatal);
}

sub repfilename {
  my ($rev, $filename, $md5) = @_;
  if ($filename eq '_serviceerror') {
    # sigh, _serviceerror files live in the trees...
    my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$rev->{'project'}/$rev->{'package'}" : "$treesdir/$rev->{'package'}";
    return "$treedir/$md5-_serviceerror" if -e "$treedir/$md5-_serviceerror";
  }
  return "$srcrep/$rev->{'package'}/$md5-$filename";
}

#
# add a file to the repository
#
sub addfile {
  my ($projid, $packid, $tmpfile, $filename, $md5) = @_;

  if (!$md5) {
    open(F, '<', $tmpfile) || die("$tmpfile: $!\n");
    my $ctx = Digest::MD5->new;
    $ctx->addfile(*F);
    close F;
    $md5 = $ctx->hexdigest();
  }
  if (! -e "$srcrep/$packid/$md5-$filename") {
    if (!rename($tmpfile, "$srcrep/$packid/$md5-$filename")) {
      mkdir_p("$srcrep/$packid");
      if (!rename($tmpfile, "$srcrep/$packid/$md5-$filename")) {
        my $err = $!;
        if (! -e "$srcrep/$packid/$md5-$filename") {
          $! = $err;
          die("rename $tmpfile $srcrep/$packid/$md5-$filename: $!\n");
        }
      }
    }
  } else {
    unlink($tmpfile);
  }
  return $md5;
}

#
# make files available in oprojid/opackid available from projid/packid
#
sub copyfiles {
  my ($projid, $packid, $oprojid, $opackid, $files, $except) = @_;

  return if $packid eq $opackid;
  return unless %$files;
  mkdir_p("$srcrep/$packid");
  for my $f (sort keys %$files) {
    next if $except && $except->{$f};
    next if -e "$srcrep/$packid/$files->{$f}-$f";
    link("$srcrep/$opackid/$files->{$f}-$f", "$srcrep/$packid/$files->{$f}-$f");
    die("link error $srcrep/$opackid/$files->{$f}-$f\n") unless -e "$srcrep/$packid/$files->{$f}-$f";
  }
}

sub getrev_git {
  my ($projid, $packid, $rev) = @_;
  my $gitdir = "$projectsdir/$projid.pkg/$packid.git";
  die("$projid/$packid is not a git repository") unless -d $gitdir;
  if (!$rev) {
    my $master = readstr("$gitdir/refs/heads/master");
    chomp $master;
    $rev = $master;
  }
  die("revision is not a valid git id\n") unless $rev =~ /^[0-9a-f]{40}/s;
  open(F, '-|', 'git', "--git-dir=$gitdir", 'cat-file', 'commit', $rev) || return undef;
  my $commit = '';
  1 while sysread(F, $commit, 4096, length($commit));
  close F;
  $commit =~ s/.*?\n\n//;
  $rev = {'project' => $projid, 'package' => $packid, 'rev' => $rev, 'srcmd5' => $rev};
  $rev->{'comment'} = $commit if $commit ne '';
  return $rev;
}

sub get_frozenlinks {
  my ($projid) = @_;
  return $frozenlinks_cache->{$projid} if $frozenlinks_cache && exists $frozenlinks_cache->{$projid};
  my $rev = getrev_meta($projid);
  my $files = lsrev($rev);
  my $frozen;
  if ($files->{'_frozenlinks'}) {
    my $frozenx = repreadxml($rev, '_frozenlinks', $files->{'_frozenlinks'}, $BSXML::frozenlinks);
    $frozen = {};
    for my $fp (@{$frozenx->{'frozenlink'} || []}) {
      my $n = defined($fp->{'project'}) ? $fp->{'project'} : '/all';
      for my $p (@{$fp->{'package'} || []}) {
	my $pn = delete $p->{'name'};
        $frozen->{$n}->{$pn} = $p if defined($pn) && $p->{'srcmd5'};
      }
    }
  }
  $frozenlinks_cache->{$projid} = $frozen if $frozenlinks_cache;
  return $frozen;
}

#
# get a revision object from a revision identifier
#
sub getrev {
  my ($projid, $packid, $rev, $linked, $missingok) = @_;
  die("bad projid\n") if $projid =~ /\// || $projid =~ /^\./;
  die("bad packid\n") if $packid =~ /\// || $packid =~ /^\./;
  if ($packid ne '_project' && ! -e "$projectsdir/$projid.pkg/$packid.xml") {
    my $proj = readproj($projid, 1);
    if ($proj && $proj->{'link'}) {
      my $collect_error;
      $linked ||= [];
      my $frozen = get_frozenlinks($projid);
      for my $lprojid (map {$_->{'project'}} @{$proj->{'link'}}) {
	next if $lprojid eq $projid;
	next if grep {$_->{'project'} eq $lprojid && $_->{'package'} eq $packid} @$linked;
	push @$linked, {'project' => $lprojid, 'package' => $packid};
        my $frozenp = $frozen->{'/all'} || $frozen->{$lprojid};
	my $lrev;
        if ($frozenp->{$packid} && !($rev && $rev =~ /^[0-9a-f]{32}$/)) {
	  eval {
	    $lrev = getrev($lprojid, $packid, $frozenp->{$packid}->{'srcmd5'}, $linked, $missingok);
	    $lrev->{'vrev'} = $frozenp->{$packid}->{'vrev'} if defined $frozenp->{$packid}->{'vrev'};
	  };
	} else {
	  eval {
	    $lrev = getrev($lprojid, $packid, $rev, $linked, $missingok);
	  };
	}
	next if $collect_error;
	if ($@ && $@ !~ /^404/) {
	  if ($collect_remote_getrev && $@ =~ /collect_remote_getrev$/) {
	    # special case for project links, we don't know if the package exists yet,
	    # so collect from all link elements
	    $collect_error = $@;
	    next;
	  }
	  die($@);
	}
	if ($lrev) {
	  # make sure that we may access the sources of this package
	  checksourceaccess($lprojid, $packid);
	  my $files = lsrev($lrev);
	  copyfiles($projid, $packid, $lprojid, $packid, $files);
	  my $srcmd5 = $lrev->{'srcmd5'};
	  if ($BSConfig::nosharedtrees && $srcmd5 ne $emptysrcmd5) {
	    # copy the tree
	    my $treedir = "$treesdir/$projid/$packid";
	    if (! -e "$treedir/$srcmd5-MD5SUMS") {
	      my $ltreedir = "$treesdir/$lprojid/$packid";
	      $ltreedir = "$srcrep/$packid" if $BSConfig::nosharedtrees == 2 && ! -e "$ltreedir/$srcmd5-MD5SUMS";
	      if (-e "$ltreedir/$srcmd5-MD5SUMS") {
		my $meta = readstr("$ltreedir/$srcmd5-MD5SUMS");
	        mkdir_p($treedir);
		writestr("$uploaddir/$$", "$treedir/$srcmd5-MD5SUMS", $meta);
	      } else {
		addmeta($projid, $packid, $files);	# last resort...
	      }
	    }
	  }
	  $lrev->{'originproject'} ||= $lprojid;
	  $lrev->{'project'} = $projid;
	  return $lrev;
	}
      }
      die($collect_error) if $collect_error;
    }
    if (defined($rev) && $rev =~ /^[0-9a-f]{32}$/) {
      # getrev by srcmd5. we allow access to packages that were deleted.
      my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
      if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2 && ! -e "$treedir/$rev-MD5SUMS") {
	$treedir = "$srcrep/$packid";
      }
      if ($rev eq $emptysrcmd5 || -e "$treedir/$rev-MD5SUMS") {
        # tree exists. make sure we knew the project/package at one time in the past
        if (-e "$projectsdir/$projid.pkg/$packid.mrev.del" ||
            -e "$projectsdir/_deleted/$projid.pkg/$packid.mrev" ||
            -e "$projectsdir/_deleted/$projid.pkg/$packid.mrev.del") {
          return {'project' => $projid, 'package' => $packid, 'rev' => $rev, 'srcmd5' => $rev};
        }
      }
    }
    return remote_getrev($projid, $packid, $rev, $linked, $missingok);
  }
  undef $rev if $rev && ($rev eq 'latest' || $rev eq 'build');
  undef $rev if $rev && $rev eq 'upload' && ! -e "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS";
  if (!defined($rev)) {
    $rev = BSFileDB::fdb_getlast("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay);
    if (!$rev && -d "$projectsdir/$projid.pkg/$packid.git") {
      return getrev_git($projid, $packid);
    }
    if (!$rev && ($packid eq '_project' && -e "$projectsdir/$projid.conf")) {
      addrev_meta({'user' => 'internal', 'comment' => 'initial commit'}, $projid, undef, undef, undef, undef, 'rev');
      $rev = BSFileDB::fdb_getlast("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay);
    }
    $rev = {'srcmd5' => $emptysrcmd5} unless $rev;
  } elsif ($rev =~ /^[0-9a-f]{32}$/) {
    return undef unless -e "$projectsdir/$projid.pkg/$packid.rev" || -e "$projectsdir/$projid.pkg/$packid.mrev";
    $rev = {'srcmd5' => $rev, 'rev' => $rev};
  } elsif ($rev =~ /^[0-9a-f]{40}$/) {
    return getrev_git($projid, $packid, $rev);
  } elsif ($rev eq 'upload') {
    $rev = {'srcmd5' => 'upload', 'rev' => 'upload'}
  } elsif ($rev eq 'repository') {
    $rev = {'srcmd5' => $emptysrcmd5, 'rev' => 'repository'}
  } else {
    if ($rev eq '0') {
      $rev = {'srcmd5' => $emptysrcmd5};
    } else {
      $rev = BSFileDB::fdb_getmatch("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay, 'rev', $rev);
      die("no such revision\n") unless defined $rev;
    }
  }
  $rev->{'project'} = $projid;
  $rev->{'package'} = $packid;
  return $rev;
}

# get a revision object for a deleted project/package
# XXX: fold into getrev
sub getrev_deleted {
  my ($projid, $packid, $rev) = @_;
  undef $rev if $rev && ($rev eq 'latest' || $rev eq 'build');
  return getrev($projid, $packid, $rev) if defined($rev) && $rev !~ /^\d{1,31}$/;
  my $revfile = $packid ne '_project' ? "$projectsdir/$projid.pkg/$packid.rev.del" : "$projectsdir/_deleted/$projid.pkg/_project.rev";
  if ($packid ne '_project' && ! -e $revfile && ! -e "$projectsdir/$projid.xml" && -e "$projectsdir/_deleted/$projid.pkg") {
    $revfile = "$projectsdir/_deleted/$projid.pkg/$packid.rev";
  }
  if (!defined($rev)) {
    $rev = BSFileDB::fdb_getlast($revfile, $srcrevlay);
  } elsif ($rev eq '0') {
    $rev = {'srcmd5' => $emptysrcmd5};
  } else {
    $rev = BSFileDB::fdb_getmatch($revfile, $srcrevlay, 'rev', $rev);
  }
  die("no such revision\n") unless defined $rev;
  $rev->{'project'} = $projid;
  $rev->{'package'} = $packid;
  return $rev;
}

sub addmeta {
  my ($projid, $packid, $files, $rev) = @_;

  # calculate new meta sum
  my $meta = '';
  $meta .= "$files->{$_}  $_\n" for sort keys %$files;
  my $srcmd5 = Digest::MD5::md5_hex($meta);
  if ($rev && $rev eq 'upload') {
    mkdir_p($uploaddir);
    mkdir_p("$projectsdir/$projid.pkg");
    writestr("$uploaddir/addmeta$$", "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS", $meta);
  } else {
    my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
    if (! -e "$treedir/$srcmd5-MD5SUMS") {
      mkdir_p($uploaddir);
      mkdir_p($treedir);
      writestr("$uploaddir/addmeta$$", "$treedir/$srcmd5-MD5SUMS", $meta);
    }
  }
  return $srcmd5;
}

# used only in fake_service_run. must match addmeta
sub calcsrcmd5 {
  my ($files) = @_;
  my $meta = '';
  $meta .= "$files->{$_}  $_\n" for sort keys %$files;
  return Digest::MD5::md5_hex($meta);
}

# like addmeta, but adds link information. also stores
# under the "wrong" md5sum.
sub addmeta_link {
  my ($projid, $packid, $files, $srcmd5, $linkinfo) = @_;

  my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
  if (! -e "$treedir/$srcmd5-MD5SUMS") {
    my $meta = '';
    $meta .= "$files->{$_}  $_\n" for sort keys %$files;
    $meta .= "$linkinfo->{'srcmd5'}  /LINK\n";
    $meta .= "$linkinfo->{'lsrcmd5'}  /LOCAL\n";
    mkdir_p($uploaddir);
    mkdir_p($treedir);
    writestr("$uploaddir/$$", "$treedir/$srcmd5-MD5SUMS", $meta);
  }
}


# like addmeta, but adds service information after a source
# service finished successfully. stores under the "wrong" md5sum.
sub addmeta_service {
  my ($projid, $packid, $files, $srcmd5, $lservicemd5) = @_;
  my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
  return if -e "$treedir/$srcmd5-MD5SUMS";	# huh? why did we run twice?
  my $meta = '';
  $meta .= "$files->{$_}  $_\n" for grep {$_ ne '/SERVICE' && $_ ne '/LSERVICE'} sort keys %$files;
  $meta .= "$lservicemd5  /LSERVICE\n";
  mkdir_p($uploaddir);
  mkdir_p($treedir);
  writestr("$uploaddir/$$", "$treedir/$srcmd5-MD5SUMS", $meta);
  unlink("$treedir/$srcmd5-_serviceerror");
}

sub addmeta_serviceerror {
  my ($projid, $packid, $srcmd5, $error) = @_;
  my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
  if (!defined($error)) {
    unlink("$treedir/$srcmd5-_serviceerror");
  } else {
    # normalize the error
    $error =~ s/[\r\n]+$//s;
    $error ||= 'unknown service error';
    mkdir_p($treedir);
    writestr("$treedir/.$srcmd5-_serviceerror", "$treedir/$srcmd5-_serviceerror", "$error\n");
  }
}

sub addmeta_serialize_servicerun {
  my ($projid, $packid, $srcmd5) = @_;
  my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
  mkdir_p($treedir);
  local *FF;
  BSUtil::lockopen(\*FF, '+>>', "$treedir/$srcmd5-_serviceerror");
  if (-s FF) {
    # already running or failed!
    close FF;	# free lock
    return undef;
  }
  writestr("$treedir/.$srcmd5-_serviceerror", "$treedir/$srcmd5-_serviceerror", "service in progress\n");
  close FF;	# free lock
  return 1;
}

sub updatelinkinfodb {
  my ($projid, $packid, $rev, $files) = @_;

  mkdir_p($sourcedb) unless -d $sourcedb;
  my $linkdb = BSDB::opendb($sourcedb, 'linkinfo');
  my $linkinfo;
  if ($files && $files->{'_link'}) {
    my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link, 1);
    if ($l) {
      $linkinfo = {};
      $linkinfo->{'project'} = defined $l->{'project'} ? $l->{'project'} : $projid;
      $linkinfo->{'package'} = defined $l->{'package'} ? $l->{'package'} : $packid;
      $linkinfo->{'rev'} = $l->{'rev'} if defined $l->{'rev'};
    }
  }
  $linkdb->store("$projid/$packid", $linkinfo);
}

# ugly hack to support 'noservice' uploads. we fake a service run
# result and strip all files from the commit that look like they
# were generated by a service run.

sub can_reuse_oldservicemark {
  my ($projid, $packid, $files, $oldservicemark) = @_;

  my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
  return 0 if -e "$treedir/$oldservicemark-_serviceerror";
  my $oldmeta = readstr("$treedir/$oldservicemark-MD5SUMS", 1);
  # does not exist -> reuse it and hope for the best
  return 1 if !$oldmeta;
  # be extra carful here and make sure our data matches
  # calculate LSRCMD5 from file list
  my $nfiles = { %$files };
  delete $nfiles->{$_} for grep {/^_service[:_]/} keys %$nfiles;
  $nfiles->{'/SERVICE'} = $oldservicemark;
  my $meta = '';
  $meta .= "$nfiles->{$_}  $_\n" for sort keys %$nfiles;
  my $nsrcmd5 = Digest::MD5::md5_hex($meta);
  # calculate new meta
  $meta = '';
  $meta .= "$files->{$_}  $_\n" for grep {$_ ne '/SERVICE' && $_ ne '/LSERVICE'} sort keys %$files;
  $meta .= "$nsrcmd5  /LSERVICE\n";
  return 1 if $oldmeta eq $meta;
  return 0;
}

sub servicemark_noservice {
  my ($cgi, $projid, $packid, $files, $target, $oldservicemark) = @_;

  my $servicemark;
  if (exists($cgi->{'servicemark'})) {
    $servicemark = $cgi->{'servicemark'};
  } else {
    # if not given via cgi, autodetect
    if ($oldservicemark && can_reuse_oldservicemark($projid, $packid, $files, $oldservicemark)) {
      $servicemark = $oldservicemark;
    } else {
      if ($files->{'_service'} || grep {/^_service[:_]/} keys %$files) {
        $servicemark = genservicemark($projid, $packid, $files, $target, 1);
      }
    }
  }
  return (undef, $files) unless $servicemark;

  # ok, fake a service run
  my $nfiles = { %$files };
  delete $nfiles->{$_} for grep {/^_service[:_]/} keys %$nfiles;
  fake_service_run($projid, $packid, $nfiles, $files, $servicemark);
  return ($servicemark, $nfiles);
}

##
# generate_commit_flist($files_old, $files_new)
#
#   $files_old/$files_new are hash references as returned by lsrep
#
#   returns a list of changed files categorized similar to svn commit mails
#
sub generate_commit_flist {
  my $ret = "";
  my %categorized_files;
  my ($files_old, $files_new) = @_;
  my %files_all = (%$files_new, %$files_old);
  for my $fname (sort keys %files_all) {
    if(!$files_old->{$fname}) {
      my $flist = $categorized_files{"Added:"} ||= [];
      push(@$flist, $fname);
    } elsif(!$files_new->{$fname}) {
      my $flist = $categorized_files{"Deleted:"} ||= [];
      push(@$flist, $fname);
    } elsif($files_old->{$fname} ne $files_new->{$fname}) {
      my $flist = $categorized_files{"Modified:"} ||= [];
      push(@$flist, $fname);
    }
  }

  for my $cat (sort keys %categorized_files) {
    $ret .= "$cat\n";
    for my $fname (@{$categorized_files{$cat}}) {
      $ret .= "  $fname\n";
    }
    $ret .= "\n";
  }
  return $ret;
}

#
# create a new revision from a file list, returns revision object
#
sub addrev {
  my ($cgi, $projid, $packid, $files, $target) = @_;
  die("404 project '$projid' does not exist\n") unless -e "$projectsdir/$projid.xml";
  if ($packid =~ /^_product:/) {
    die("403 package '$packid' is read-only if a '_product' package exists\n") if -e "$projectsdir/$projid.pkg/_product.xml";
  }
  my $user = $cgi->{'user'};
  my $comment = $cgi->{'comment'};
  my $requestid = $cgi->{'requestid'};
  $user = '' unless defined $user;
  $user = 'unknown' if $user eq '';
  $comment = '' unless defined $comment;
  $user = str2utf8xml($user);
  $comment = str2utf8xml($comment);

  # check if the commit will need a service run
  my $servicemark;
  delete $files->{'/SERVICE'};	# just in case...
  if (!$BSConfig::old_style_services && $packid ne '_project') {
    if ($cgi->{'noservice'}) {
      ($servicemark, $files) = servicemark_noservice($cgi, $projid, $packid, $files, $target);
    } else {
      # we do not want any generated files in the commit!
      delete $files->{$_} for grep {/^_service[:_]/} keys %$files;
      $servicemark = exists($cgi->{'servicemark'}) ? $cgi->{'servicemark'} : genservicemark($projid, $packid, $files, $target);
    }
  }
  if ($packid eq '_pattern' && ! -e "$projectsdir/$projid.pkg/$packid.xml") {
    # upgrade pseudo _pattern package to real package
    my $pack = {
      'name' => $packid,
      'project' => $projid,
      'title' => 'pseudo package to store pattern information',
      'description' => "pseudo package to store pattern information\n",
    };
    mkdir_p($uploaddir);
    writexml("$uploaddir/$$.2", undef, $pack, $BSXML::pack);
    mkdir_p("$projectsdir/$projid.pkg");
    addrev_meta($cgi, $projid, $packid, "$uploaddir/$$.2", "$projectsdir/$projid.pkg/$packid.xml", '_meta');
  }
  die("404 package '$packid' does not exist\n") unless $packid eq '_project' || -e "$projectsdir/$projid.pkg/$packid.xml";
  if ($target && $target eq 'upload') {
    my $srcmd5 = addmeta($projid, $packid, $files, 'upload');
    my $filenames = join( ', ', keys %$files );
    notify("SRCSRV_UPLOAD", {project => $projid, package => $packid, filename => $filenames, comment => $comment, 
                             target => $target, requestid => $requestid, user => $user});
    return {'project' => $projid, 'package' => $packid, 'rev' => 'upload', 'srcmd5' => $srcmd5};
  } elsif ($target && $target eq 'repository') {
    # repository only upload.
    return {'project' => $projid, 'package' => $packid, 'rev' => 'repository', 'srcmd5' => $emptysrcmd5};
  } elsif (defined($target)) {
    # internal version only upload.
    my $srcmd5 = addmeta($projid, $packid, $files);
    return {'project' => $projid, 'package' => $packid, 'rev' => $srcmd5, 'srcmd5' => $srcmd5};
  }
  die("bad projid\n") if $projid =~ /\// || $projid =~ /^\./;
  die("bad packid\n") if $packid =~ /\// || $packid =~ /^\./;
  die("bad files (slash)\n") if grep {/\// && $_ ne '/SERVICE'} keys %$files;
  die("bad files (glyph)\n") if grep {!/^[0-9a-f]{32}$/} values %$files;

  if ($files->{'_patchinfo'}) {
    die("bad files in patchinfo container\n") if grep {$_ ne '_patchinfo'} keys %$files;
    my $p = repreadxml({'project' => $projid, 'package' => $packid}, '_patchinfo', $files->{'_patchinfo'}, $BSXML::patchinfo);
    BSVerify::verify_patchinfo($p);
  }

  # create tree entry
  $files->{'/SERVICE'} = $servicemark if $servicemark;
  my $srcmd5 = addmeta($projid, $packid, $files);
  delete $files->{'/SERVICE'};

  my $rev = {'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => $comment, 'requestid' => $requestid};

  if ($packid eq '_product') {
    expandproduct($projid, $packid, $rev, $files, $user, 1);
  }

  if ($packid ne '_project' && $packid ne '_pattern') {
    my ($version, $release) = getcommitinfo($projid, $packid, $srcmd5, $files);
    $rev->{'version'} = $version;
    $rev->{'vrev'} = $release;
  }
  
  my $rev_old = getrev($projid, $packid);
  $rev_old->{'keepsignkey'} = 1;
  my $files_old = lsrev($rev_old);
  delete $rev_old->{'keepsignkey'};
  my $filestr = generate_commit_flist($files_old, $files);

  $rev->{'version'} = $cgi->{'version'} if defined $cgi->{'version'};
  $rev->{'vrev'} = $cgi->{'vrev'} if defined $cgi->{'vrev'};
  if ($cgi->{'time'}) {
    die("specified time is less than time in last commit\n") if ($rev_old->{'time'} || 0) > $cgi->{'time'};
    $rev->{'time'} = $cgi->{'time'};
  }

  my $acceptinfo;
  if ($requestid) {
    $acceptinfo = {};
    $acceptinfo->{'osrcmd5'} = $rev_old->{'srcmd5'} if $rev_old->{'srcmd5'} ne 'empty';
    if ($files_old->{'_link'}) {
      # see if we can expand it
      eval {
	my %rev = %$rev_old;
	handlelinks(\%rev, $files_old);
	$acceptinfo->{'oxsrcmd5'} = $rev{'srcmd5'};
      };
    }
  }
  if ($packid eq '_project') {
    $rev = BSFileDB::fdb_add_i("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay, $rev);
    $rev->{'project'} = $projid;
    $rev->{'package'} = $packid;
    if ($acceptinfo) {
      $acceptinfo->{'rev'} = $rev->{'rev'};
      $acceptinfo->{'srcmd5'} = $rev->{'srcmd5'};
      $rev->{'acceptinfo'} = $acceptinfo if $cgi->{'withacceptinfo'};
    }
    extract_old_prjsource($projid, $rev);
    unlink("$projectsdir/$projid.pkg/$packid.upload-MD5SUMS");
    notify_repservers('project', $projid);
    notify("SRCSRV_UPDATE_PROJECT_CONFIG", { "project" => $projid, "files" => $filestr, "comment" => $comment, "sender" => $user });
    return $rev;
  }

  # help a little with link<->nolink and singleversion<->multiversion changes
  if (defined($rev->{'version'}) && defined($rev_old->{'version'}) && !defined($cgi->{'vrev'})) {
    # if this is a known -> unknown version change, max with vrev of last commit
    # same for unknown -> known
    if (($rev->{'version'} eq 'unknown' && $rev_old->{'version'} ne 'unknown') ||
        ($rev->{'version'} ne 'unknown' && $rev_old->{'version'} eq 'unknown')) {
      my $l_old = 0;
      $l_old = $1 if $rev_old->{'vrev'} =~ /(\d+)$/;
      my $l_new = 0;
      $l_new = $1 if $rev->{'vrev'} =~ /(\d+)$/;
      $rev->{'vrev'} =~ s/\d+$/$l_old + 1/e if $l_old + 1 > $l_new;
    }
  }

  # add to revision database
  if (defined($rev->{'version'}) && !defined($cgi->{'vrev'})) {
    $rev = BSFileDB::fdb_add_i2("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay, $rev, 'vrev', 'version', $rev->{'version'});
  } else {
    $rev = BSFileDB::fdb_add_i("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay, $rev);
  }

  # add missing data to complete the revision object
  $rev->{'project'} = $projid;
  $rev->{'package'} = $packid;

  # update linked package database
  updatelinkinfodb($projid, $packid, $rev, $files);

  # update request acceptinfo
  if ($acceptinfo) {
    $acceptinfo->{'rev'} = $rev->{'rev'};
    $acceptinfo->{'srcmd5'} = $rev->{'srcmd5'};
    if ($files->{'_link'}) {
      # see if we can expand it
      eval {
	my %rev = %$rev;
	handlelinks(\%rev, $files);
	$acceptinfo->{'xsrcmd5'} = $rev{'srcmd5'};
      };
    }
    $rev->{'acceptinfo'} = $acceptinfo if $cgi->{'withacceptinfo'};
  }

  # send out notification
  notify("SRCSRV_COMMIT", {project => $projid, package => $packid, files => $filestr, rev => $rev->{'rev'}, user => $user, comment => $comment, 'requestid' => $requestid});
  $rev_old->{'version'} = "unknown" unless defined($rev_old->{'version'});
  notify("SRCSRV_VERSION_CHANGE", {project => $projid, package => $packid, files => $filestr, rev => $rev->{'rev'},
                                   oldversion => $rev_old->{'version'}, newversion => $rev->{'version'},
                                   user => $user, comment => $comment, 'requestid' => $requestid})
    if defined($rev->{'version'}) && defined($rev_old->{'version'}) && $rev->{'version'} ne $rev_old->{'version'};

  # kill upload revision as we did a real commit
  unlink("$projectsdir/$projid.pkg/$packid.upload-MD5SUMS");
  # kill obsolete _pattern file
  unlink("$projectsdir/$projid.pkg/pattern-MD5SUMS") if $packid eq '_pattern';

  notify_repservers('package', $projid, $packid);

  # put marker back
  $files->{'/SERVICE'} = $servicemark if $servicemark;
  return $rev;
}

sub lsrev_git {
  my ($rev, $linkinfo) = @_;
  my $id = $rev->{'srcmd5'};
  local *F;
  my $gitdir = repgitdir($rev);
  open(F, '-|', 'git', "--git-dir=$gitdir", 'cat-file', 'tree', $id) || die("git: $!\n");
  my $tree = '';
  1 while sysread(F, $tree, 4096, length($tree));
  close(F) || die("bad id\n");
  my $files = {};
  while ($tree =~ /(\d+) ([^\000]*)\000(.{20})/sg) {
    next if $1 eq '40000';		# ignore dirs for now
    next if substr($2, 0, 1) eq '.';	# ignore files starting with . for now
    $files->{$2} = unpack('H*', $3);
  }
  return $files;
}

#
# retrieve the file list of a revision object or tree object
# store merge info in linkinfo if available
#
sub lsrev {
  my ($rev, $linkinfo) = @_;

  die("nothing known\n") unless $rev;
  my $projid = $rev->{'project'};
  my $packid = $rev->{'package'};
  my $srcmd5 = $rev->{'srcmd5'};
  die("revision project missing\n") unless defined $projid;
  die("revision package missing\n") unless defined $packid;
  die("no such revision\n") unless defined $srcmd5;
  local *F;
  die("bad packid\n") if $packid =~ /\// || $packid =~ /^\./;
  if ($srcmd5 eq 'upload') {
    open(F, '<', "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS") || die("$packid/$srcmd5-$packid: not in repository\n");
  } elsif ($srcmd5 eq 'pattern') {
    open(F, '<', "$projectsdir/$projid.pkg/pattern-MD5SUMS") || return {};
  } elsif ($srcmd5 eq 'empty' || $srcmd5 eq $emptysrcmd5) {
    return {};
  } elsif (length($srcmd5) == 40) {
     return lsrev_git($rev, $linkinfo);
  } else {
    die("bad srcmd5 '$srcmd5'\n") if $srcmd5 !~ /^[0-9a-f]{32}$/;
    my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
    if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2 && ! -e "$treedir/$srcmd5-MD5SUMS" && -e "$srcrep/$packid/$srcmd5-MD5SUMS") {
      $treedir = "$srcrep/$packid";
    }
    if (!open(F, '<', "$treedir/$srcmd5-MD5SUMS")) {
      return {'_linkerror' => $srcmd5} if -e "$srcrep/$packid/$srcmd5-_linkerror";
      return {'_serviceerror' => $srcmd5} if -s "$treedir/$srcmd5-_serviceerror";
      die("$projid/$packid/$srcmd5: not in repository. Either not existing or misconfigured server setting for '\$nosharedtrees' setting in BSConfig.pm\n");
    }
  }
  my @files = <F>;
  close F;
  chomp @files;
  my $files = {map {substr($_, 34) => substr($_, 0, 32)} @files};
  # hack: do not list _signkey in project meta
  delete $files->{'_signkey'} if $packid eq '_project' && !$rev->{'keepsignkey'};
  if ($linkinfo) {
    $linkinfo->{'lsrcmd5'} = $files->{'/LOCAL'} if $files->{'/LOCAL'};
    $linkinfo->{'srcmd5'} = $files->{'/LINK'} if $files->{'/LINK'};
    $linkinfo->{'xservicemd5'} = $files->{'/SERVICE'} if $files->{'/SERVICE'};
    $linkinfo->{'lservicemd5'} = $files->{'/LSERVICE'} if $files->{'/LSERVICE'};
  }
  delete $files->{'/LINK'};
  delete $files->{'/LOCAL'};
  delete $files->{'/SERVICE'};
  delete $files->{'/LSERVICE'};
  return $files;
}


# find last revision that consisted of the tree object
sub findlastrev {
  my ($tree) = @_;
  my $rev = BSFileDB::fdb_getmatch("$projectsdir/$tree->{'project'}.pkg/$tree->{'package'}.rev", $srcrevlay, 'srcmd5', $tree->{'srcmd5'});
  return undef unless $rev;
  $rev->{'project'} = $tree->{'project'};
  $rev->{'package'} = $tree->{'package'};
  return $rev;
}



###########################################################################
###
###  source link handling
###

sub patchspec {
  my ($p, $dir, $spec) = @_;
  local *F;
  open(F, '<', "$dir/$spec") || die("$dir/$spec: $!\n");
  my @preamble;
  while(<F>) {
    chomp;
    push @preamble, $_;
    last if /^\s*%(package|prep|build|install|check|clean|preun|postun|pretrans|posttrans|pre|post|files|changelog|description|triggerpostun|triggerun|triggerin|trigger|verifyscript)(\s|$)/;
  }
  my %patches;
  for (@preamble) {
    next unless /^patch(\d*)\s*:/i;  
    $patches{0 + ($1 eq '' ? 0 : $1)} = $_;
  }
  my @patches = sort {$a <=> $b} keys %patches;
  my $nr = 0;
  if (exists $p->{'after'}) {
    $nr = 0 + $p->{'after'};
    $nr++ while $patches{$nr};
  } else {
    $nr = $patches[-1] + 1 if @patches;
  }
  my @after;
  @after = map {$patches{$_}} grep {$_ < $nr} @patches if @patches;
  @after = grep {/^source(\d*)\s*:/i} @preamble if !@after;
  @after = grep {/^name(\d*)\s*:/i} @preamble if !@after;
  @after = $preamble[-2] if @preamble > 1 && !@after;
  return "could not find a place to insert the patch" if !@after;
  my $nrx = $nr;
  $nrx = '' if $nrx == 0;
  local *O;
  open(O, '>', "$dir/.patchspec$$") || die("$dir/.patchspec$$: $!\n");
  for (@preamble) {
    print O "$_\n";
    next unless @after && $_ eq $after[-1];
    print O "Patch$nrx: $p->{'name'}\n";
    @after = ();
  }
  if ($preamble[-1] !~ /^\s*%prep(\s|$)/) {
    while (1) {
      my $l = <F>;
      return "specfile has no %prep section" if !defined $l;
      chomp $l;
      print O "$l\n";
      last if $l =~ /^\s*%prep(\s|$)/;
    }
  }
  my @prep;
  while(<F>) {
    chomp;
    push @prep, $_;
    last if /^\s*%(package|prep|build|install|check|clean|preun|postun|pretrans|posttrans|pre|post|files|changelog|description|triggerpostun|triggerun|triggerin|trigger|verifyscript)(\s|$)/;
  }
  %patches = ();
  my $ln = -1;
  # find outmost pushd/popd calls and insert new patches after a pushd/popd block
  # $blevel == 0 indicates the outmost block
  my %bend = ();
  my $bln = undef;
  $$bln = $ln;
  my $blevel = -1;
  for (@prep) {
    $ln++;
    $blevel++ if /^pushd/;
    if (/^popd/) {
      unless ($blevel) {
        $$bln = $ln;
        undef $bln;
        $$bln = $ln;
      }
      $blevel--;
    }
    next unless /%patch(\d*)(.*)/;
    if ($1 ne '') {
      $patches{0 + $1} = $ln;
      $bend{0 + $1} = $bln if $blevel >= 0;
      next;
    }
    my $pnum = 0;
    my @a = split(' ', $2);
    if (! grep {$_ eq '-P'} @a) {
      $patches{$pnum} = $ln;
    } else {
      while (@a) {
        next if shift(@a) ne '-P';
        next if !@a || $a[0] !~ /^\d+$/;
        $pnum = 0 + shift(@a);
        $patches{$pnum} = $ln;
      }
    }
    $bend{$pnum} = $bln if $blevel >= 0;
  }
  return "specfile has broken %prep section" unless $blevel == -1;
  @patches = sort {$a <=> $b} keys %patches;
  $nr = 1 + $p->{'after'} if exists $p->{'after'};
  %patches = map { $_ => exists $bend{$_} ? ${$bend{$_}} : $patches{$_} } @patches;
  @after = map {$patches{$_}} grep {$_ < $nr} @patches if @patches;
  @after = ($patches[0] - 1) if !@after && @patches;
  @after = (@prep - 2) if !@after;
  my $after = $after[-1];
  $after = -1 if $after < -1;
  $ln = -1;
  push @prep, '' if $after >= @prep;
  #print "insert %patch after line $after\n";
  for (@prep) {
    if (defined($after) && $ln == $after) {
      print O "pushd $p->{'dir'}\n" if exists $p->{'dir'};
      if ($p->{'popt'}) {
        print O "%patch$nrx -p$p->{'popt'}\n";
      } else {
        print O "%patch$nrx\n";
      }
      print O "popd\n" if exists $p->{'dir'};
      undef $after;
    }
    print O "$_\n";
    $ln++;
  }
  while(<F>) {
    chomp;
    print O "$_\n";
  }
  close(O) || die("close: $!\n");
  rename("$dir/.patchspec$$", "$dir/$spec") || die("rename $dir/.patchspec$$ $dir/$spec: $!\n");
  return '';
}
# " Make emacs wired syntax highlighting happy

sub topaddspec {
  my ($p, $dir, $spec) = @_;
  local (*F, *O);
  open(F, '<', "$dir/$spec") || die("$dir/$spec: $!\n");
  open(O, '>', "$dir/.topaddspec$$") || die("$dir/.topaddspec$$: $!\n");
  my $text = $p->{'text'};
  $text = '' if !defined $text;
  $text .= "\n" if $text ne '' && substr($text, -1, 1) ne "\n";
  print O $text;
  while(<F>) {
    chomp;
    print O "$_\n";
  }
  close(O) || die("close: $!\n");
  rename("$dir/.topaddspec$$", "$dir/$spec") || die("rename $dir/.topaddspec$$ $dir/$spec: $!\n");
}

#
# apply a single link step
# store the result under the identifier "$md5"
#
# if "$md5" is not set, store the result in "$uploaddir/applylink$$"
#
sub applylink {
  my ($md5, $lsrc, $llnk) = @_;
  if ($md5 && -e "$srcrep/$llnk->{'package'}/$md5-_linkerror") {
    # no need to do all the work again...
    my $log = readstr("$srcrep/$llnk->{'package'}/$md5-_linkerror", 1);
    $log ||= "unknown error";
    chomp $log;
    $log =~ s/.*\n//s;
    $log ||= "unknown error";
    return str2utf8xml($log);
  }
  my $flnk = lsrev($llnk);
  my $fsrc = lsrev($lsrc);
  my $l = $llnk->{'link'};
  my $patches = $l->{'patches'} || {};
  my @patches = ();
  my $simple = 1;
  my @simple_delete;
  my $isbranch;
  if ($l->{'patches'}) {
    for (@{$l->{'patches'}->{''} || []}) {
      my $type = (keys %$_)[0];
      if (!$type) {
	$simple = 0;
	next;
      }
      if ($type eq 'topadd') {
        push @patches, { 'type' => $type, 'text' => $_->{$type}};
	$simple = 0;
      } elsif ($type eq 'delete') {
        push @patches, { 'type' => $type, %{$_->{$type} || {}}};
	push @simple_delete, $patches[-1]->{'name'};
      } else {
        push @patches, { 'type' => $type, %{$_->{$type} || {}}};
	$simple = 0;
	$isbranch = 1 if $type eq 'branch';
      }
    }
  }
  $simple = 0 unless $md5;
  if ($simple) {
    # simple source link with no patching
    # copy all files but the ones we have locally
    copyfiles($llnk->{'project'}, $llnk->{'package'}, $lsrc->{'project'}, $lsrc->{'package'}, $fsrc, $flnk);
    # calculate meta
    my $newf = { %$fsrc };
    for my $f (sort keys %$flnk) {
      $newf->{$f} = $flnk->{$f} unless $f eq '_link';
    }
    delete $newf->{$_} for @simple_delete;
    # store filelist in md5
    my $linkinfo = {
      'srcmd5'  => $lsrc->{'srcmd5'},
      'lsrcmd5' => $llnk->{'srcmd5'},
    };
    addmeta_link($llnk->{'project'}, $llnk->{'package'}, $newf, $md5, $linkinfo);
    return '';
  }

  # sanity checking...
  for my $p (@patches) {
    return "patch has no type" unless exists $p->{'type'};
    return "patch has illegal type \'$p->{'type'}\'" unless $p->{'type'} eq 'apply' || $p->{'type'} eq 'add' || $p->{'type'} eq 'topadd' || $p->{'type'} eq 'delete' || $p->{'type'} eq 'branch';
    if ($p->{'type'} ne 'topadd' && $p->{'type'} ne 'delete' && $p->{'type'} ne 'branch') {
      return "patch has no patchfile" unless exists $p->{'name'};
      return "patch \'$p->{'name'}\' does not exist" unless $flnk->{$p->{'name'}};
    }
  }
  my $tmpdir = "$uploaddir/applylink$$";
  mkdir_p($tmpdir);
  die("$tmpdir: $!\n") unless -d $tmpdir;
  unlink("$tmpdir/$_") for ls($tmpdir);	# remove old stuff
  my %apply = map {$_->{'name'} => 1} grep {$_->{'type'} eq 'apply'} @patches;
  $apply{$_} = 1 for keys %{$llnk->{'ignore'} || {}};	# also ignore those files, used in keeplink
  my %fl;
  if (!$isbranch) {
    for my $f (sort keys %$fsrc) {
      next if $flnk->{$f} && !$apply{$f};
      link("$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f", "$tmpdir/$f") || die("$f: $!\n");
      $fl{$f} = "$lsrc->{'package'}/$fsrc->{$f}-$f";
    }
    for my $f (sort keys %$flnk) {
      next if $apply{$f} || $f eq '_link';
      link("$srcrep/$llnk->{'package'}/$flnk->{$f}-$f", "$tmpdir/$f") || die("$f: $!\n");
      $fl{$f} = "$llnk->{'package'}/$flnk->{$f}-$f";
    }
  }
  my $failed;
  for my $p (@patches) {
    my $pn = $p->{'name'};
    if ($p->{'type'} eq 'delete') {
      unlink("$tmpdir/$pn");
      next;
    }
    if ($p->{'type'} eq 'branch') {
      # flnk: mine
      # fbas: old
      # fsrc: new
      my $baserev = $l->{'baserev'};
      return "no baserev in branch patch" unless $baserev;
      return "baserev is not srcmd5" unless $baserev =~ /^[0-9a-f]{32}$/s;
      my %brev = (%$lsrc, 'srcmd5' => $baserev);
      my $fbas;
      eval {
        $fbas = lsrev(\%brev);
      };
      return "baserev $baserev does not exist" unless $fbas;
      return "baserev is link" if $fbas->{'_link'};

      # ignore linked generated service files if our link contains service files
      if (grep {/^_service/} keys %$flnk) {
	delete $fbas->{$_} for grep {/^_service[:_]/} keys %$fbas;
	delete $fsrc->{$_} for grep {/^_service[:_]/} keys %$fsrc;
      }
      # do 3-way merge
      my %destnames = (%$fsrc, %$flnk);
      delete $destnames{'_link'};
      for my $f (sort {length($a) <=> length($b) || $a cmp $b} keys %destnames) {
	my $mbas = $fbas->{$f} || '';
	my $msrc = $fsrc->{$f} || '';
	my $mlnk = $flnk->{$f} || '';
	if ($mbas eq $mlnk) {
	  next if $msrc eq '';
	  link("$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f", "$tmpdir/$f") || die("$fsrc->{$f}-$f: $!\n");
	  $fl{$f} = "$lsrc->{'package'}/$fsrc->{$f}-$f";
	  next;
	}
	if ($mbas eq $msrc || $mlnk eq $msrc) {
	  next if $mlnk eq '';
	  link("$srcrep/$llnk->{'package'}/$flnk->{$f}-$f", "$tmpdir/$f") || die("$flnk->{$f}-$f: $!\n");
	  $fl{$f} = "$llnk->{'package'}/$flnk->{$f}-$f";
	  next;
	}
	if ($mbas eq '' || $msrc eq '' || $mlnk eq '') {
	  $failed = "conflict in file $f";
	  last;
	}
        # run merge tools
	link("$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f", "$tmpdir/$f.new") || die("link $fsrc->{$f}-$f: $!\n");
	link("$srcrep/$lsrc->{'package'}/$fbas->{$f}-$f", "$tmpdir/$f.old") || die("link $fbas->{$f}-$f: $!\n");
	link("$srcrep/$llnk->{'package'}/$flnk->{$f}-$f", "$tmpdir/$f.mine") || die("link $flnk->{$f}-$f: $!\n");
	if (!isascii("$tmpdir/$f.new") || !isascii("$tmpdir/$f.old") || !isascii("$tmpdir/$f.mine")) {
	  $failed = "conflict in file $f";
	  last;
	}
	my $pid;
        if ( $f =~ /\.changes$/ ) {
          # try our changelog merge tool first
  	  if (!($pid = xfork())) {
	    delete $SIG{'__DIE__'};
	    open(STDERR, '>>', "$tmpdir/.log") || die(".log: $!\n");
	    open(STDOUT, '>', "$tmpdir/$f") || die("$f: $!\n");
            print STDERR "running merge tool on $f\n";
	    exec('./bs_mergechanges', "$tmpdir/$f.old", "$tmpdir/$f.new", "$tmpdir/$f.mine");
	    die("./bs_mergechanges: $!\n");
	  }
  	  waitpid($pid, 0) == $pid || die("waitpid $pid: $!\n");
	  $pid = undef if $?;
        }
	if (!$pid) {
          # default diff3 merge tool. always using as fallback
	  if (!($pid = xfork())) {
	    delete $SIG{'__DIE__'};
	    chdir($tmpdir) || die("$tmpdir: $!\n");
	    open(STDERR, '>>', ".log") || die(".log: $!\n");
	    open(STDOUT, '>', $f) || die("$f: $!\n");
            print STDERR "running diff3 on $f\n";
	    exec('/usr/bin/diff3', '-m', '-E', "$f.mine", "$f.old", "$f.new");
	    die("/usr/bin/diff3: $!\n");
	  }
	  waitpid($pid, 0) == $pid || die("waitpid $pid: $!\n");
	  if ($?) {
	    $failed = "conflict in file $f";
	    last;
	  }
	}
	unlink("$tmpdir/$f.old");
	unlink("$tmpdir/$f.new");
	unlink("$tmpdir/$f.mine");
      }
      last if $failed;
      next;
    }
    if ($p->{'type'} eq 'add') {
      for my $spec (grep {/\.spec$/} ls($tmpdir)) {
	local *F;
	open(F, '>>', "$tmpdir/.log") || die("$tmpdir/.log: $!\n");
	print F "adding patch $pn to $spec\n";
	close F;
        my $err = patchspec($p, $tmpdir, $spec);
        if ($err) {
	  open(F, '>>', "$tmpdir/.log") || die("$tmpdir/.log: $!\n");
	  print F "error: $err\n";
	  close F;
	  $failed = "could not add patch '$pn'";
	  last;
	  unlink("$tmpdir/$_") for ls($tmpdir);
	  rmdir($tmpdir);
	  return "could not add patch '$pn'";
	}
        delete $fl{$spec};
      }
      last if $failed;
      next;
    }
    if ($p->{'type'} eq 'topadd') {
      for my $spec (grep {/\.spec$/} ls($tmpdir)) {
	local *F;
	open(F, '>>', "$tmpdir/.log") || die("$tmpdir/.log: $!\n");
	print F "adding text at top of $spec\n";
	close F;
        topaddspec($p, $tmpdir, $spec);
        delete $fl{$spec};
      }
      next;
    }
    next unless $p->{'type'} eq 'apply';
    my $pid;
    if (!($pid = xfork())) {
      delete $SIG{'__DIE__'};
      chdir($tmpdir) || die("$tmpdir: $!\n");
      open(STDIN, '<', "$srcrep/$llnk->{'package'}/$flnk->{$pn}-$pn") || die("$srcrep/$llnk->{'package'}/$flnk->{$pn}-$pn: $!\n");
      open(STDOUT, '>>', ".log") || die(".log: $!\n");
      open(STDERR, '>&STDOUT');
      $| = 1;
      print "applying patch $pn\n";
      $::ENV{'TMPDIR'} = '.';
      # Old patch command still supported --unified-reject-files and --global-reject-file.
      # exec('/usr/bin/patch', '--no-backup-if-mismatch', '--unified-reject-files', '--global-reject-file=.rejects', '-g', '0', '-f');
      exec('/usr/bin/patch', '--no-backup-if-mismatch', '-g', '0', '-f');
      die("/usr/bin/patch: $!\n");
    }
    waitpid($pid, 0) == $pid || die("waitpid $pid: $!\n");
    if ($?) {
      $failed = "could not apply patch '$pn'";
      last;
    }
  }
  if ($failed) {
    local *F;
    # add result as last line
    open(F, '>>', "$tmpdir/.log") || die("$tmpdir/.log: $!\n");
    print F "\n$failed\n";
    close F;
    # link error marker
    if ($md5 && !link("$tmpdir/.log", "$srcrep/$llnk->{'package'}/$md5-_linkerror")) {
      my $err = "link $tmpdir/.log $srcrep/$llnk->{'package'}/$md5-_linkerror: $!\n";
      die($err) unless -e "$srcrep/$llnk->{'package'}/$md5-_linkerror";
    }
    unlink("$tmpdir/$_") for ls($tmpdir);
    rmdir($tmpdir);
    return str2utf8xml($failed);
  }
  my @newf = grep {!/^\./} ls($tmpdir);
  my $newf = {};
  local *F;
  for my $f (@newf) {
    my @s = stat "$tmpdir/$f";
    die("$tmpdir/$f: $!\n") unless @s;
    if ($s[3] > 1 && $fl{$f}) {
      my @s2 = stat "$srcrep/$fl{$f}";
      die("$srcrep/$fl{$f}: $!\n") unless @s2;
      if ("$s[0]/$s[1]" eq "$s2[0]/$s2[1]") {
        $newf->{$f} = $fl{$f};
        $newf->{$f} =~ s/.*\///;
        $newf->{$f} = substr($newf->{$f}, 0, 32);
	next;
      }
    }
    open(F, '<', "$tmpdir/$f") || die("$tmpdir/$f: $!\n");
    my $ctx = Digest::MD5->new;
    $ctx->addfile(*F);
    close F;
    $newf->{$f} = $ctx->hexdigest();
  }

  # if we just want the patched files we're finished
  if (!$md5) {
    # rename into md5 form, sort so that there's no collision
    for my $f (sort {length($b) <=> length($a) || $a cmp $b} @newf) {
      rename("$tmpdir/$f", "$tmpdir/$newf->{$f}-$f");
    }
    return $newf;
  }

  # otherwise link everything over
  for my $f (@newf) {
    addfile($llnk->{'project'}, $llnk->{'package'}, "$tmpdir/$f", $f, $newf->{$f});
  }
  # clean up tmpdir
  unlink("$tmpdir/$_") for ls($tmpdir);
  rmdir($tmpdir);
  # store filelist
  my $linkinfo = {
    'srcmd5'  => $lsrc->{'srcmd5'},
    'lsrcmd5' => $llnk->{'srcmd5'},
  };
  addmeta_link($llnk->{'project'}, $llnk->{'package'}, $newf, $md5, $linkinfo);
  return '';
}

#
# expand a source link
# - returns expanded file list
# - side effects:
#   modifies $rev->{'srcmd5'}, $rev->{'vrev'}, $rev->{'linkrev'}
#   modifies $li->{'srcmd5'}, $li->{'lsrcmd5'}
#   modifies $li->{'linked'} if exists
#
sub handlelinks {
  my ($rev, $files, $li) = @_;

  my @linkinfo;
  my %seen;
  my $projid = $rev->{'project'};
  my $packid = $rev->{'package'};
  my $linkrev = $rev->{'linkrev'};
  push @linkinfo, {'project' => $projid, 'package' => $packid, 'srcmd5' => $rev->{'srcmd5'}, 'rev' => $rev->{'rev'}};
  delete $rev->{'srcmd5'};
  delete $rev->{'linkrev'};
  my $oldvrev = 0;
  my $vrevdone;
  my $lrev = $rev;
  while ($files->{'_link'}) {
    my $l = repreadxml($lrev, '_link', $files->{'_link'}, $BSXML::link, 1);
    return '_link is bad' unless $l;
    my $cicount = $l->{'cicount'} || 'add';
    eval {
      BSVerify::verify_link($l);
      die("illegal cicount\n") unless $cicount eq 'copy' || $cicount eq 'add' || $cicount eq 'local';
      if (!exists($l->{'package'}) && exists($l->{'project'}) && $l->{'project'} ne $linkinfo[-1]->{'project'}) {
        # be extra careful if the package attribute doesn't exist, but the
        # link points to some other project
        checksourceaccess($l->{'project'}, $linkinfo[-1]->{'package'});
      }
    };
    if ($@) {
      my $err = $@;
      $err =~ s/\n$//s;
      return "_link is bad: $err" if @linkinfo == 1;
      return "$lrev->{'project'}/$lrev->{'package'}: _link is bad: $err";
    }
    $l->{'project'} = $linkinfo[-1]->{'project'} unless exists $l->{'project'};
    $l->{'package'} = $linkinfo[-1]->{'package'} unless exists $l->{'package'};
    $linkrev = $l->{'baserev'} if $linkrev && $linkrev eq 'base';
    ($l->{'rev'}, $linkrev) = ($linkrev, undef) if $linkrev;
    $linkinfo[-1]->{'link'} = $l;
    $projid = $l->{'project'};
    $packid = $l->{'package'};
    $lrev = $l->{'rev'} || '';
    return 'circular package link' if $seen{"$projid/$packid/$lrev"};
    $seen{"$projid/$packid/$lrev"} = 1;
    # record link target for projpack
    push @{$li->{'linked'}}, {'project' => $projid, 'package' => $packid} if $li && $li->{'linked'}; 
    eval {
      if ($l->{'missingok'}) {
        # be careful with 'missingok' pointing to protected packages
        checksourceaccess($projid, $packid);
      }
      $lrev = getrev($projid, $packid, $l->{'rev'}, $li ? $li->{'linked'} : undef, $l->{'missingok'} ? 1 : 0);
    };
    if ($@) {
      my $error = $@;
      chomp $error;
      $error = $2 if $error =~ /^(\d+) +(.*?)$/s;
      return "$projid/$packid: $error";
    }
    return "linked package '$packid' does not exist in project '$projid'" unless $lrev;
    return "linked package '$packid' is empty" if $lrev->{'srcmd5'} eq 'empty';
    return "linked package '$packid' is strange" unless $lrev->{'srcmd5'} =~ /^[0-9a-f]{32}$/;
    $lrev->{'vrev'} = $l->{'vrev'} if defined $l->{'vrev'};
    undef $files;
    eval {
      # links *always* point to expanded services
      $files = lsrev_service($lrev);
    };
    if ($@) {
      my $error = $@;
      chomp $error;
      return "$projid/$packid: $error";
    }
    $rev->{'vrev'} = $oldvrev if $cicount eq 'copy';
    $oldvrev = $rev->{'vrev'};
    $vrevdone = 1 if $cicount eq 'local';
    if (!$vrevdone) {
      my $v = $rev->{'vrev'} || 0;
      $v =~ s/^.*\D//;
      $rev->{'vrev'} = $lrev->{'vrev'} || 0;
      $rev->{'vrev'} =~ s/(\d+)$/$1+$v/e;
    }

    push @linkinfo, {'project' => $projid, 'package' => $packid, 'srcmd5' => $lrev->{'srcmd5'}, 'rev' => $lrev->{'rev'}};
  }
  my $md5;
  my $oldl;
  for my $l (reverse @linkinfo) {
    if (!$md5) {
      $md5 = $l->{'srcmd5'};
      $oldl = $l;
      next;
    }
    my $md5c = "$md5  /LINK\n$l->{'srcmd5'}  /LOCAL\n";
    $md5 = Digest::MD5::md5_hex($md5c);
    my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$l->{'project'}/$l->{'package'}" : "$treesdir/$l->{'package'}";
    if (! -e "$treedir/$md5-MD5SUMS") {
      my $error = applylink($md5, $oldl, $l);
      if ($error) {
        $rev->{'srcmd5'} = $md5 if $l == $linkinfo[0];
	$error = "$l->{'project'}/$l->{'package'}: $error" if $l != $linkinfo[0];
        return $error;
      }
    }
    $l->{'srcmd5'} = $md5;
    $oldl = $l;
  }
  $rev->{'srcmd5'} = $md5;
  $files = lsrev($rev, $li);
  return $files;
}

# - returns expanded file list
# - side effects:
#   modifies $rev->{'srcmd5'}
sub handleservice {
  my ($rev, $files, $servicemark) = @_;

  my $lsrcmd5 = $rev->{'srcmd5'};
  $rev->{'srcmd5'} = $servicemark;
  my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$rev->{'project'}/$rev->{'package'}" : "$treesdir/$rev->{'package'}";
  my $sfiles;
  if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2 && ! -e "$treedir/$servicemark-MD5SUMS" && -e "$srcrep/$rev->{'package'}/$servicemark-MD5SUMS") {
    $sfiles = lsrev($rev);
  } elsif (-e "$treedir/$servicemark-MD5SUMS") {
    $sfiles = lsrev($rev);
  } elsif (! -e "$projectsdir/$rev->{'project'}.pkg/$rev->{'package'}.xml") {
    # not our own package, don't run service. try getrev/lsrev instead.
    my $rrev = getrev($rev->{'project'}, $rev->{'package'}, $servicemark);
    $sfiles = lsrev($rrev);
  }
  if ($sfiles) {
    # tree is available, i.e. the service has finished
    if ($sfiles->{'_service_error'}) {
      # old style...
      my $error = repreadstr($rev, '_service_error', $sfiles->{'_service_error'});
      $error =~ s/[\r\n]+$//s;
      $error =~ s/.*[\r\n]//s;
      die(str2utf8xml($error ? "$error\n" : "unknown service error\n"));
    }
    return $sfiles;
  }
  # don't have the tree yet
  if (-s "$treedir/$servicemark-_serviceerror") {
    local *SERROR;
    if (open(SERROR, '<', "$treedir/$servicemark-_serviceerror")) {
      my $size = -s SERROR;
      sysseek(SERROR, $size - 1024, 0) if $size > 1024;
      my $error = '';
      1 while sysread(SERROR, $error, 1024, length($error));
      close SERROR;
      $error =~ s/[\r\n]+$//s;
      $error =~ s/.*[\r\n]//s;
      $error ||= 'unknown service error';
      die(str2utf8xml("$error\n"));
    }
  }
  my %nfiles = %$files;
  $nfiles{'/SERVICE'} = $servicemark;
  $rev->{'srcmd5'} = $lsrcmd5;	# put it back so that runservice can put it in /LSRCMD5
  runservice({}, $rev, \%nfiles);
  $rev->{'srcmd5'} = $servicemark;
  die("service in progress\n");
}

# returns service expanded filelist
# modifies $rev->{'srcmd5'}
sub lsrev_service {
  my ($rev, $linkinfo) = @_;
  $linkinfo ||= {};
  my $files = lsrev($rev, $linkinfo);
  $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'}) if $linkinfo->{'xservicemd5'};
  return $files;
}

# returns expanded filelist
# modifies $rev->{'srcmd5'}, $rev->{'vrev'}
sub lsrev_expanded {
  my ($rev, $linkinfo) = @_;
  my $files = lsrev_service($rev, $linkinfo);
  return $files unless $files->{'_link'};
  $files = handlelinks($rev, $files, $linkinfo);
  die("$files\n") unless ref $files;
  return $files;
}

# add missing target information to linkinfo
sub linkinfo_addtarget {
  my ($rev, $linkinfo) = @_;
  my %lrev = %$rev;
  $lrev{'srcmd5'} = $linkinfo->{'lsrcmd5'} if $linkinfo->{'lsrcmd5'};
  my $files = lsrev(\%lrev);
  die("linkinfo_addtarget: not a link?\n") unless $files->{'_link'};
  my $l = repreadxml(\%lrev, '_link', $files->{'_link'}, $BSXML::link, 1);
  if ($l) {
    $linkinfo->{'project'} = defined($l->{'project'}) ? $l->{'project'} : $lrev{'project'};
    $linkinfo->{'package'} = defined($l->{'package'}) ? $l->{'package'} : $lrev{'package'};
    $linkinfo->{'missingok'} = "true" if $l->{'missingok'};
    $linkinfo->{'rev'} = $l->{'rev'} if $l->{'rev'};
    $linkinfo->{'baserev'} = $l->{'baserev'} if $l->{'baserev'};
  }
}

sub findlastworkinglink {
  my ($rev) = @_;

  my $projid = $rev->{'project'};
  my $packid = $rev->{'package'};
  my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
  my @cand = grep {s/-MD5SUMS$//} ls($treedir);
  if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2) {
    push @cand, grep {s/-MD5SUMS$//} ls("$srcrep/$packid");
    @cand = unify(@cand);
  }
  my %cand;
  for my $cand (@cand) {
    my $candrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $cand};
    my %li;
    my $files = lsrev($candrev, \%li);
    next unless $li{'lsrcmd5'} && $li{'lsrcmd5'} eq $rev->{'srcmd5'};
    $cand{$cand} = $li{'srcmd5'};
  }
  return undef unless %cand;
  @cand = sort keys %cand;
  return $cand[0] if @cand == 1;

  while (1) {
    my $lrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $rev->{'srcmd5'}};
    my $lfiles = lsrev($lrev);
    return undef unless $lfiles;
    my $l = repreadxml($lrev, '_link', $lfiles->{'_link'}, $BSXML::link, 1);
    return undef unless $l;
    $projid = $l->{'project'} if exists $l->{'project'};
    $packid = $l->{'package'} if exists $l->{'package'};
    my $lastcand;
    for my $cand (splice @cand) {
      next unless $cand{$cand};
      my %li;
      my $candrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $cand{$cand}};
      lsrev($candrev, \%li);
      $candrev->{'srcmd5'} = $li{'lsrcmd5'} if $li{'lsrcmd5'};
      $candrev = findlastrev($candrev);
      next unless $candrev;
      next if $lastcand && $lastcand->{'rev'} > $candrev->{'rev'};
      $cand{$cand} = $li{'srcmd5'} ? $li{'srcmd5'} : undef;
      if ($lastcand && $lastcand->{'rev'} == $candrev->{'rev'}) {
        push @cand, $cand;
	next;
      }
      @cand = ($cand);
      $lastcand = $candrev;
    }
    return undef unless @cand;
    return $cand[0] if @cand == 1;
    $rev = $lastcand;
  }
}


###########################################################################
###
###  project/package management
###

sub identical {
  my ($d1, $d2, $except) = @_;

  return 0 unless defined($d1) && defined($d2);
  my $r = ref($d1);
  return 0 if $r ne ref($d2);
  if ($r eq '') {
    return 0 if $d1 ne $d2;
  } elsif ($r eq 'HASH') {
    my %k = (%$d1, %$d2);
    for my $k (keys %k) {
      next if $except && $except->{$k};
      return 0 unless identical($d1->{$k}, $d2->{$k}, $except);
    }
  } elsif ($r eq 'ARRAY') {
    return 0 unless @$d1 == @$d2;
    for (my $i = 0; $i < @$d1; $i++) {
      return 0 unless identical($d1->[$i], $d2->[$i], $except);
    }
  } else {
    return 0;
  }
  return 1;
}

sub findprojects {
  my ($deleted) = @_;
  if ($deleted) {
    my @projids = grep {s/\.pkg$//} ls("$projectsdir/_deleted");
    @projids = grep {! -e "$projectsdir/$_.xml"} @projids;
    return sort @projids;
  }
  local *D;
  mkdir_p("$projectsdir") || die("creating $projectsdir: $!\n");
  opendir(D, $projectsdir) || die("$projectsdir: $!\n");
  my @projids = grep {s/\.xml$//} readdir(D);
  closedir(D);
  return sort @projids;
}

sub findpackages {
  my ($projid, $proj, $nonfatal, $seen, $origins, $noexpand, $deleted) = @_;
  $proj ||= readproj($projid, 1) || {};
  local *D;
  my @packids;

  # if this is a remote project, forward to remote server
  if ($proj->{'remoteurl'}) {
    my $r;
    my @args;
    push @args, 'deleted=1' if $deleted;
    push @args, 'expand=1' unless $noexpand || $deleted;
    eval {
      $r = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}", 'proxy' => $proxy}, $BSXML::dir, @args);
    };
    if ($@ && $@ =~ /^404/) {
      # remote project does not exist
      die($@) unless $nonfatal;
      return @packids;
    }
    if ($@) {
      die($@) unless $nonfatal && $nonfatal > 0;	# -1: internal projectlink recursion, errors are still fatal
      warn($@);
      push @packids, ':missing_packages' if $nonfatal == 2;
      return @packids;
    }
    @packids = map {$_->{'name'}} @{($r || {})->{'entry'} || []};
    if ($origins) {
      for my $entry (@{($r || {})->{'entry'} || []}) {
	$origins->{$entry->{'name'}} = defined($entry->{'originproject'}) ? maptoremote($proj, $entry->{'originproject'}) : $projid;
      }
    }
    return @packids;
  }

  # handle deleted packages
  if ($deleted) {
    # we never expand deleted packages
    if (! -e "$projectsdir/$projid.xml" && -d "$projectsdir/_deleted/$projid.pkg") {
      @packids = grep {$_ ne '_meta' && $_ ne '_project'} grep {s/\.mrev$//} ls("$projectsdir/_deleted/$projid.pkg");
    } else {
      @packids = grep {s/\.mrev\.del$//} ls("$projectsdir/$projid.pkg");
      @packids = grep {! -e "$projectsdir/$projid.pkg/$_.xml"} @packids;
    }
    @packids = sort @packids;
    if ($origins) {
      for (@packids) {
        $origins->{$_} = $projid unless defined $origins->{$_};
      }
    }
    return @packids;
  }

  # get local packages
  if (opendir(D, "$projectsdir/$projid.pkg")) {
    @packids = grep {s/\.xml$//} readdir(D);
    closedir(D);
    if ($origins) {
      for (@packids) {
        $origins->{$_} = $projid unless defined $origins->{$_};
      }
    }
  }

  # handle project links
  if ($proj->{'link'} && !$noexpand) {
    $seen ||= {};
    $seen->{$projid} = 1;
    my $frozen = get_frozenlinks($projid);
    for my $lprojid (map {$_->{'project'}} @{$proj->{'link'}}) {
      next if $seen->{$lprojid};
      $seen->{$lprojid} = 1;
      my @lpackids;
      my $frozenp = $frozen->{'/all'} || $frozen->{$lprojid};
      my $lorigins = defined($origins) ? {} : undef;
      if ($frozenp) {
	@lpackids = sort keys %$frozenp;
	if ($lorigins) {
	  $lorigins->{$_} = $lprojid for @lpackids;
	}
      } else {
        my $lproj = readproj($lprojid, 1);
        if (!$lproj || $lproj->{'remoteurl'}) {
          $lproj = remoteprojid($lprojid);
	  next unless $lproj;	# linked project does not exist
        }
        @lpackids = findpackages($lprojid, $lproj, $nonfatal || -1, $seen, $lorigins);
      }
      if (grep {$_ eq '_product'} @packids) {
	@lpackids = grep {$_ ne '_product' && !/^_product:/} @lpackids;
      }
      push @packids, @lpackids;
      if ($origins && $lorigins) {
        for (@lpackids) {
          $origins->{$_} = $lorigins->{$_} unless defined $origins->{$_};
        }
      }
    }
    @packids = unify(@packids);
  }

  return sort @packids;
}

sub getrev_meta {
  my ($projid, $packid, $revid, $deleted, $nonfatal) = @_;
  my $revfile = defined($packid) ? "$projectsdir/$projid.pkg/$packid.mrev" : "$projectsdir/$projid.pkg/_project.mrev";
  if ($deleted) {
    $revfile = defined($packid) ? "$projectsdir/$projid.pkg/$packid.mrev.del" : "$projectsdir/_deleted/$projid.pkg/_project.mrev";
    if (defined($packid) && ! -e $revfile && ! -e "$projectsdir/$projid.xml" && -e "$projectsdir/_deleted/$projid.pkg") {
      $revfile = "$projectsdir/_deleted/$projid.pkg/$packid.mrev";
    }
  }
  my $rev;
  if (!defined($revid) || $revid eq 'latest') {
    $rev = BSFileDB::fdb_getlast($revfile, $srcrevlay);
    $rev = { 'srcmd5' => $emptysrcmd5 } unless $rev;
  } elsif ($revid =~ /^[0-9a-f]{32}$/) {
    $rev = { 'srcmd5' => $revid };
  } else {
    $rev = BSFileDB::fdb_getmatch($revfile, $srcrevlay, 'rev', $revid);
  }
  if ($rev) {
    $rev->{'project'} = $projid;
    $rev->{'package'} = defined($packid) ? $packid : '_project';
  } elsif (!$nonfatal) {
    die("404 revision '$revid' does not exist\n") if $revid;
    die("404 no revision\n");
  }
  return $rev;
}

sub retrofit_old_prjsource {
  my ($projid) = @_;
  my $files = {};
  my $packid = '_project';
  if (-e "$projectsdir/$projid.conf") {
    BSUtil::cp("$projectsdir/$projid.conf", "$uploaddir/addrev_meta$$");
    $files->{'_config'} = addfile($projid, $packid, "$uploaddir/addrev_meta$$", '_config');
  }
  return $files;
}

sub retrofit_old_meta {
  my ($projid, $packid) = @_;
  my $files = {};
  if (defined($packid) && $packid ne '_project') {
    if (-e "$projectsdir/$projid.pkg/$packid.xml") {
      BSUtil::cp("$projectsdir/$projid.pkg/$packid.xml", "$uploaddir/addrev_meta$$");
      $files->{'_meta'} = addfile($projid, $packid, "$uploaddir/addrev_meta$$", '_meta');
    }
  } else {
    $packid = '_project';
    if (-e "$projectsdir/$projid.xml") {
      BSUtil::cp("$projectsdir/$projid.xml", "$uploaddir/addrev_meta$$");
      $files->{'_meta'} = addfile($projid, $packid, "$uploaddir/addrev_meta$$", '_meta');
    }
    if (-e "$projectsdir/$projid.pkg/_sslcert") {
      # FIXME: this is only needed for the test suite. But as long we do not have a signing
      #        stub there we need this to inject keys.
      BSUtil::cp("$projectsdir/$projid.pkg/_sslcert", "$uploaddir/addrev_meta$$");
      $files->{'_sslcert'} = addfile($projid, $packid, "$uploaddir/addrev_meta$$", '_sslcert');
    }
    if (-e "$projectsdir/$projid.pkg/_pubkey") {
      BSUtil::cp("$projectsdir/$projid.pkg/_pubkey", "$uploaddir/addrev_meta$$");
      $files->{'_pubkey'} = addfile($projid, $packid, "$uploaddir/addrev_meta$$", '_pubkey');
    }
    if (-e "$projectsdir/$projid.pkg/_signkey") {
      BSUtil::cp("$projectsdir/$projid.pkg/_signkey", "$uploaddir/addrev_meta$$");
      chmod(0600, "$uploaddir/addrev_meta$$");
      $files->{'_signkey'} = addfile($projid, $packid, "$uploaddir/addrev_meta$$", '_signkey');
    }
  }
  return $files;
}

sub extract_old_prjsource {
  my ($projid, $rev) = @_;
  my $files = lsrev($rev);
  my $config;
  $config = repreadstr($rev, '_config', $files->{'_config'}, 1) if $files->{'_config'};
  writestr("$uploaddir/$$.2", "$projectsdir/$projid.conf", $config) if $config;
}

sub extract_old_meta {
  my ($projid, $packid, $rev) = @_;
  $rev->{'keepsignkey'} = 1;
  my $files = lsrev($rev);
  delete $rev->{'keepsignkey'};
  if (!defined($packid) || $packid eq '_project') {
    $packid = '_project';
    my $pubkey;
    $pubkey = repreadstr($rev, '_pubkey', $files->{'_pubkey'}, 1) if $files->{'_pubkey'};
    writestr("$uploaddir/$$.2", "$projectsdir/$projid.pkg/_pubkey", $pubkey) if $pubkey;
    my $signkey;
    $signkey = repreadstr($rev, '_signkey', $files->{'_signkey'}, 1) if $files->{'_signkey'};
    if ($signkey) {
      writestr("$uploaddir/$$.2", undef, $signkey);
      chmod(0600, "$uploaddir/$$.2");
      rename("$uploaddir/$$.2", "$projectsdir/$projid.pkg/_signkey") || die("rename $uploaddir/$$.2 $projectsdir/$projid.pkg/_signkey: $!\n");
    }
    my $meta;
    $meta = repreadstr($rev, '_meta', $files->{'_meta'}, 1) if $files->{'_meta'};
    writestr("$uploaddir/$$.2", "$projectsdir/$projid.xml", $meta) if $meta;
  } else {
    my $meta;
    $meta = repreadstr($rev, '_meta', $files->{'_meta'}, 1) if $files->{'_meta'};
    writestr("$uploaddir/$$.2", "$projectsdir/$projid.pkg/$packid.xml", $meta) if $meta;
  }
}

sub addrev_meta_multiple {
  my ($cgi, $projid, $packid, $suf, @todo) = @_;

  $suf ||= 'mrev';
  undef $packid if $packid && $packid eq '_project';
  my $rpackid = defined($packid) ? $packid : '_project';

  # first commit content into internal repository
  my %rfilemd5;
  for my $todo (@todo) {
    my ($tmpfile, $file, $rfile) = @$todo;
    next unless defined($tmpfile);
    mkdir_p($uploaddir);
    unlink("$uploaddir/addrev_meta$$");
    BSUtil::cp($tmpfile, "$uploaddir/addrev_meta$$");
    chmod(0600, "$uploaddir/addrev_meta$$") if !defined($packid) && $suf eq 'mrev' && $rfile eq '_signkey';
    $rfilemd5{$rfile} = addfile($projid, $rpackid, "$uploaddir/addrev_meta$$", $rfile);
  }

  mkdir_p("$projectsdir/$projid.pkg");
  my $revfile = "$projectsdir/$projid.pkg/$rpackid.$suf";
  local *FF;
  BSUtil::lockopen(\*FF, '+>>', $revfile);
  my $rev = BSFileDB::fdb_getlast($revfile, $srcrevlay);
  my $files;
  if ($rev) {
    $rev->{'project'} = $projid;
    $rev->{'package'} = $rpackid;
    $rev->{'keepsignkey'} = 1;
    $files = lsrev($rev);
    delete $rev->{'keepsignkey'};
  } else {
    $files = {};
    if ((defined($packid) && -e "$projectsdir/$projid.pkg/$packid.xml") || (!defined($packid) && -e "$projectsdir/$projid.xml")) {
      if ($suf eq 'mrev') {
        $files = retrofit_old_meta($projid, $packid);
      } elsif (!defined($packid)) {
        $files = retrofit_old_prjsource($projid);
      }
    }
  }

  for my $todo (@todo) {
    my ($tmpfile, $file, $rfile) = @$todo;
    if (defined($tmpfile)) {
      $files->{$rfile} = $rfilemd5{$rfile};
    } else {
      delete $files->{$rfile};
    }
  }

  my $srcmd5 = addmeta($projid, $rpackid, $files);
  my $user = defined($cgi->{'user'}) ? str2utf8xml($cgi->{'user'}) : 'unknown';
  my $comment = defined($cgi->{'comment'}) ? str2utf8xml($cgi->{'comment'}) : '';
  my $nrev = { 'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => $comment, 'requestid' => $cgi->{'requestid'} };
  # copy version/vref in initial commit case
  if (!@todo && defined($packid) && $suf ne 'mrev' && $rev) {
    $nrev->{'version'} = $rev->{'version'} if defined $rev->{'version'};
    $nrev->{'vrev'} = $rev->{'vrev'} if defined $rev->{'vrev'};
  }
  BSFileDB::fdb_add_i(\*FF, $srcrevlay, $nrev);

  for my $todo (@todo) {
    my ($tmpfile, $file, $rfile) = @$todo;
    if (defined($file)) {
      if (defined($tmpfile)) {
        rename($tmpfile, $file) || die("rename $tmpfile $file: $!\n");
      } else {
        unlink($file);
      }
    } elsif (defined($tmpfile)) {
      unlink($tmpfile);
    }
  }
  close FF;	# free lock
  $nrev->{'project'} = $projid;
  $nrev->{'package'} = $rpackid;
  return $nrev;
}

sub addrev_meta {
  my ($cgi, $projid, $packid, $tmpfile, $file, $rfile, $suf) = @_;
  if (defined($rfile)) {
    return addrev_meta_multiple($cgi, $projid, $packid, $suf,  [ $tmpfile, $file, $rfile ]);
  } else {
    return addrev_meta_multiple($cgi, $projid, $packid, $suf);
  }
}

sub readproj {
  my ($projid, $nonfatal, $revid) = @_;
  my $proj;
  if ($revid) {
    my $rev = getrev_meta($projid, undef, $revid);
    my $files = $rev ? lsrev($rev) : {};
    $proj = repreadxml($rev, '_meta', $files->{'_meta'}, $BSXML::proj, 1) if $files->{'_meta'};
  } else {
    $proj = readxml("$projectsdir/$projid.xml", $BSXML::proj, 1);
  }
  die("404 project '$projid' does not exist\n") if !$proj && !$nonfatal;
  return $proj;
}

sub readpack {
  my ($projid, $packid, $nonfatal, $revid) = @_;
  my $pack;
  if ($revid) {
    my $rev = getrev_meta($projid, $packid, $revid, undef, $nonfatal);
    my $files = $rev ? lsrev($rev) : {};
    $pack = repreadxml($rev, '_meta', $files->{'_meta'}, $BSXML::pack, 1) if $files->{'_meta'};
  } else {
    $pack = readxml("$projectsdir/$projid.pkg/$packid.xml", $BSXML::pack, 1);
  }
  if (!$pack && !$nonfatal) {
    readproj($projid);
    die("404 package '$packid' does not exist in project '$projid'\n");
  }
  return $pack;
}

# collect all global source services via all package and project links
sub getprojectservices {
  my ($cgi, $projid, $packid, $projectloop) = @_;
  my $services = {};

  # protection against loops and double matches
  $projectloop ||= {};
  return ({}, $BSXML::services) if $projectloop->{$projid};
  $projectloop->{$projid} = 1;

  # get source services from this project
  my $projectrev = getrev($projid, '_project');
  my $projectfiles = lsrev($projectrev);
  if ($projectfiles->{'_service'}) {
    $services = readxml("$srcrep/_project/$projectfiles->{'_service'}-_service", $BSXML::services, 1) || {};
  }

  # find further projects via project link
  my $proj = readproj($projid, 1);
  for my $lprojid (map {$_->{'project'}} @{$proj->{'link'} || []}) {
    my $lpack;
    eval {
      ($lpack, undef) = getpackage($cgi, $lprojid, $packid);
    };
    if ($lpack) {
      my ($as, undef) = getprojectservices($cgi, $lprojid, $packid, $projectloop);
      if (defined($as) && defined($as->{'service'})) {
        push @{$services->{'service'}}, @{$as->{'service'}};
      }
    }
  }

  # find further projects via package link
  my $packagerev;
  eval {
     $packagerev = getrev($projid, $packid, $cgi->{'rev'});
  };
  return ($services, $BSXML::services) unless $packagerev;

  my $packagefiles = lsrev($packagerev);
  my $l;
  $l = repreadxml($packagerev, '_link', $packagefiles->{'_link'}, $BSXML::link, 1) if $packagefiles->{'_link'};
  if ($l) {
    my $lprojid = $projid;
    my $lpackid = $packid;
    $lprojid = $l->{'project'} if defined $l->{'project'};
    $lpackid = $l->{'package'} if defined $l->{'package'};
    # honor project links
    my $lpack;
    eval {
      ($lpack, undef) = getpackage($cgi, $lprojid, $lpackid);
    };
    if ($lpack) {
      my ($as, undef) = getprojectservices({%$cgi, 'rev' => $l->{'rev'}}, $lprojid, $lpackid, $projectloop);
      if (defined($as) && defined($as->{'service'})) {
        push @{$services->{'service'}}, @{$as->{'service'}};
      }
    }
  }

  return ($services, $BSXML::services);
}

# find matching .spec/.dsc/.kiwi file depending on packid and/or repoid
sub findfile {
  my ($rev, $repoid, $ext, $files) = @_;

  return (undef, undef) if !$ext || $ext eq 'none';
  $files = lsrev($rev) unless $files;
  return (undef, undef) unless $files;

  # create filename -> return value hash
  my %files = map {$_ => [$files->{$_}, $_]} keys %$files;

  # map services files to their real name
  if ($files{'_service'}) {
    for (sort keys %files) {
      next unless /^_service:.*:(.*?)$/s;
      next unless $files{$_};
      $files{$1} = $files{$_};
      delete $files{$_};
    }
  }

  return @{$files{'_preinstallimage'}} if $ext ne 'kiwi' && keys(%files) == 1 && $files{'_preinstallimage'};
  return @{$files{'simpleimage'}} if $files{'simpleimage'};

  if ($ext eq 'arch') {
    return @{$files{'PKGBUILD'}} if $files{'PKGBUILD'};
    return (undef, undef);
  }

  my $packid = $rev->{'package'};
  return (@{$files{"$packid-$repoid.$ext"}}) if defined($repoid) && $files{"$packid-$repoid.$ext"};
  # 28.4.2009 mls: deleted "&& defined($repoid)"
  return @{$files{"$packid.$ext"}} if $files{"$packid.$ext"};
  # try again without last components
  if ($packid =~ /^(.*?)\./) {
    return @{$files{"$1.$ext"}} if $files{"$1.$ext"};
  }
  my @files = grep {/\.$ext$/} keys %files;
  @files = grep {/^\Q$packid\E/i} @files if @files > 1;
  return @{$files{$files[0]}} if @files == 1;
  if (@files > 1) {
    if (!defined($repoid)) {
      # return (undef, undef);
      @files = sort @files;
      return @{$files{$files[0]}};
    }
    @files = grep {/^\Q$packid-$repoid\E/i} @files if @files > 1;
    return @{$files{$files[0]}} if @files == 1;
  }
  return (undef, undef);
}

sub unify {
  my %h = map {$_ => 1} @_;
  return grep(delete($h{$_}), @_);
}

#########################################################################

# set up kiwi project callback

sub kiwibootcallback {
  my ($projid, $packid) = @_;
  BSVerify::verify_projid($projid);
  BSVerify::verify_packid($packid);
  checksourceaccess($projid, $packid);
  my $rev = getrev($projid, $packid);
  my $files = lsrev($rev);
  my ($md5, $file) = findfile($rev, undef, 'kiwi', $files);
  die("no kiwi file found\n") unless $md5 && $file;
  my $xml = readstr("$srcrep/$packid/$md5-$file");
  return ($xml, {'project' => $projid, 'package' => $packid, 'srcmd5' => $rev->{'srcmd5'}, 'file' => $file});
}
$Build::Kiwi::bootcallback = \&kiwibootcallback;

#########################################################################

sub projid2reposerver {
  my ($projid) = @_;
  return $BSConfig::reposerver unless $BSConfig::partitionservers;
  my @p = @{$BSConfig::partitioning || []};
  my $par;
  while (@p) {
    if ($projid =~ /^$p[0]/) {
      $par = $p[1];
      last;
    }
    splice(@p, 0, 2);
  }
  $par = $BSConfig::partition unless defined $par;
  die("cannot determine partition for $projid\n") unless defined $par;
  die("partition '$par' from partitioning does not exist\n") unless $BSConfig::partitionservers->{$par};
  return $BSConfig::partitionservers->{$par};
}

sub projid2partition {
  my ($projid) = @_;
  return undef unless $BSConfig::partitioning;
  my @p = @{$BSConfig::partitioning || []};
  my $par;
  while (@p) {
    if ($projid =~ /^$p[0]/) {
      $par = $p[1];
      last;
    }
    splice(@p, 0, 2);
  }
  $par = $BSConfig::partition unless defined $par;
  return $par;
}

sub checkpartition {
  my ($remotemap, $projid, $proj) = @_;
  $remotemap->{':partitions'}->{$projid} = 1;
  return if $remotemap->{$projid};
  my @p = @{$BSConfig::partitioning || []};
  my $par;
  while (@p) {
    if ($projid =~ /^$p[0]/) {
      $par = $p[1];
      last;
    }
    splice(@p, 0, 2);
  }
  $par = $BSConfig::partition unless defined $par;
  die("cannot determine partition for $projid\n") unless defined $par;
  return if $par eq $remotemap->{':partition'};
  my $reposerver = $BSConfig::reposerver;
  if ($BSConfig::partitionservers) {
    $reposerver = $BSConfig::partitionservers->{$par};
    die("partition '$par' from partitioning does not exist\n") unless $reposerver;
  }
  $remotemap->{$projid} = {
    'name' => $projid, 'remoteurl' => $reposerver, 'remoteproject' => $projid, 'partition' => $par,
  };
  $proj ||= readproj($projid, 1);
  if (!$proj) {
    $remotemap->{$projid} = { 'name' => $projid };	# gone!
    return;
  }
  $remotemap->{$projid}->{'repository'} = $proj->{'repository'} if $proj->{'repository'};
  $remotemap->{$projid}->{'kind'} = $proj->{'kind'} if $proj->{'kind'};
  if ($proj->{'access'}) {
    for ('access', 'publish', 'person', 'group') {
      $remotemap->{$projid}->{$_} = $proj->{$_} if exists $proj->{$_};
    }
  }
}

sub getprojquotapackage {
  my ($projid) = @_;
  if (!exists($packagequota{':packages'})) {
    my $quotaxml = readxml($BSConfig::bsquotafile, $BSXML::quota, 1);
    for my $p (@{$quotaxml->{'project'} || []}) {
      $packagequota{$p->{'name'}} = $p->{'packages'};
    }
    $packagequota{':packages'} = $quotaxml->{'packages'};
  }
  while ($projid) {
    return $packagequota{$projid} if exists $packagequota{$projid};
    last unless $projid =~ s/:[^:]*$//;
  }
  return $packagequota{':packages'};
}

# this is kind of a snapshot in time, but good enough for now 
sub mergeroles {
  my ($projid, $proj) = @_; 
  my @person;
  my @group;
  while ($projid ne '') {
    $proj ||= readproj($projid, 1); 
    if ($proj) {
      push @person, @{$proj->{'person'} || []};
      push @group , @{$proj->{'group'} || []};
    }   
    last unless $projid =~ s/:[^:]*$//;
    undef $proj;
  }
  return (\@person, \@group);
}

sub getprojpack {
  my ($cgi, $projids, $repoids, $packids, $arch) = @_;
  local *oldbsrpc = *BSRPC::rpc;
  local *BSRPC::rpc;
  die("unsupported view\n") if $cgi->{'view'} && $cgi->{'view'} ne 'storable';
  if ($cgi->{'noremote'}) {
    *BSRPC::rpc = sub {die("400 interconnect error: noremote option\n");};
  } else {
    *BSRPC::rpc = sub {
      my $r = eval { oldbsrpc(@_) };
      if ($@) {
	$@ = "interconnect error: $@" unless $@ =~ /(?:remote|interconnect) error:/;
	die($@);
      }
      return $r;
    };
  }
  $arch ||= 'noarch';
  my $partition = $cgi->{'partition'};
  die("No such partition '$partition'\n") if $partition && $BSConfig::partitionservers && !$BSConfig::partitionservers->{$partition};
  my $remotemap = $cgi->{'withremotemap'} ? {} : undef;
  if ($remotemap && $partition) {
    $remotemap->{':partition'} = $partition;
    $remotemap->{':partitions'} = {};
  }
  $projids = [ findprojects() ] unless $projids;
  if ($partition) {
    for my $projid (splice @$projids) {
      my $par = projid2partition($projid);
      die("cannot determine partition for $projid\n") unless defined $par;
      die("partition '$par' from partitioning does not exist\n") if $BSConfig::partitionservers && !$BSConfig::partitionservers->{$par};
      if ($par ne $partition) {
	# check if it is remote, if not then it belongs to another partition
	my $r = readproj($projid, 1);
	$r = remoteprojid($projid) unless defined $r;
	if (!($r && $r->{'remoteurl'})) {
	  # not remote, but on wrong partition
	  # if asked for a specific project, put it in remotemap
	  next unless $remotemap && $cgi->{'project'};
	  checkpartition($remotemap, $projid, $r) if $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$projid};
	  if ($remotemap->{$projid} && $cgi->{'withconfig'}) {
	    # also put config in remotemap is asked for a specific project
	    my $c = readstr("$projectsdir/$projid.conf", 1);
	    $remotemap->{$projid}->{'config'} = defined($c) ? $c : '' if ($remotemap->{$projid} || {})->{'partition'};
	  }
	  next;
	}
      }
      push @$projids, $projid;
    }
  }
  if ($BSConfig::limit_projects && $BSConfig::limit_projects->{$arch}) {
    my %limit_projids = map {$_ => 1} @{$BSConfig::limit_projects->{$arch}};
    $projids = [ grep {$limit_projids{$_}} @$projids ];
  }
  $repoids = { map {$_ => 1} @$repoids } if $repoids;
  $packids = { map {$_ => 1} @$packids } if $packids;
  my $bconf = Build::read_config($arch);

  $frozenlinks_cache = {};
  my %channeldata;
  my @res;
  for my $projid (@$projids) {
    my $jinfo = { 'name' => $projid };
    my $proj = readproj($projid, 1);
    if ($remotemap && (!$proj || $proj->{'remoteurl'}) && !exists($remotemap->{$projid})) {
      my $r = remoteprojid($projid);
      $remotemap->{$projid} = {%$r, 'proto' => 1} if $r;
    }
    next unless $proj;
    for (qw{kind}) {
      $jinfo->{$_} = $proj->{$_} if exists $proj->{$_};
    }

    my %expandedrepos;

    if ($cgi->{'withrepos'}) {
      if ($repoids) {
	$jinfo->{'repository'} = [ grep {$repoids->{$_->{'name'}}} @{$proj->{'repository'} || []} ];
      } else {
        $jinfo->{'repository'} = $proj->{'repository'} || [];
      }
      if ($cgi->{'expandedrepos'}) {
	$jinfo->{'repository'} = Storable::dclone($jinfo->{'repository'});
	for my $repo (@{$jinfo->{'repository'}}) {
	  my $base = {};
	  my @prps = expandsearchpath($projid, $repo->{'name'}, $remotemap, $base);
	  $expandedrepos{"$projid/$repo->{'name'}"} = [ @prps ];
	  for my $prp (@prps) {
	    my @s = split('/', $prp, 2);
	    $prp = {'project' => $s[0], 'repository' => $s[1]};
	  }
	  $repo->{'path'} = \@prps;
	  $repo->{'base'} = $base;
	}
      } elsif ($remotemap) {
	for my $repo (@{$jinfo->{'repository'}}) {
	  eval {
	    my @prps = expandsearchpath($projid, $repo->{'name'}, $remotemap);
            $expandedrepos{"$projid/$repo->{'name'}"} = [ @prps ];
	  };
	  $expandedrepos{"$projid/$repo->{'name'}"} = $@ if $@;
	}
      }
    }

    if ($remotemap) {
      for my $lprojid (map {$_->{'project'}} @{$proj->{'link'} || []}) {
        my $lproj = remoteprojid($lprojid);
	eval {
	  fetchremoteproj($lproj, $lprojid, $remotemap) if $lproj;
	};
        checkpartition($remotemap, $lprojid) if $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$lprojid};
      }
    }

    if ($cgi->{'withconfig'}) {
      my $config = readstr("$projectsdir/$projid.conf", 1);
      if ($config) {
	#my $s1 = '^\s*macros:\s*$.*?^\s*:macros\s*$';
	#my $s2 = '^\s*macros:\s*$.*\Z';
	#$config =~ s/$s1//gmsi;
	#$config =~ s/$s2//gmsi;
	$jinfo->{'config'} = $config unless $config =~ /^\s*$/s;
      }
    }
    if ($cgi->{'withsrcmd5'} && -s "$projectsdir/$projid.pkg/pattern-MD5SUMS") {
      my $patterns = readstr("$projectsdir/$projid.pkg/pattern-MD5SUMS", 1);
      $jinfo->{'patternmd5'} = Digest::MD5::md5_hex($patterns) if $patterns;
    } elsif ($cgi->{'withsrcmd5'} && $cgi->{'nopackages'}) {
      # used by publisher to get patternmd5
      eval {
	my $rev = getrev($projid, '_pattern');
	my $files = lsrev_expanded($rev);
	$jinfo->{'patternmd5'} = $rev->{'srcmd5'};
      };
    }
    my @packages;
    @packages = findpackages($projid, $proj, 2) unless $cgi->{'nopackages'} || $proj->{'remoteurl'};
    my $missing_packages = grep {$_ eq ':missing_packages'} @packages;
    if ($missing_packages) {
      @packages = grep {$_ ne ':missing_packages'} @packages;
      $jinfo->{'missingpackages'} = 1;
    }
    next if $repoids && !grep {$repoids->{$_->{'name'}}} @{$proj->{'repository'} || []};
    next if $packids && !grep {$packids->{$_}} @packages;
    for (qw{title description build publish debuginfo useforbuild remoteurl remoteproject download link sourceaccess privacy access lock}) {
      $jinfo->{$_} = $proj->{$_} if exists $proj->{$_};
    }
    if ($proj->{'access'}) {
      # we need the roles if the project is protected, see checkroles() in the scheduler
      my ($person, $group) = mergeroles($projid, $proj);
      $jinfo->{'person'} = $person if $person && @$person;
      $jinfo->{'group'} = $group if $group && @$group;
    }
    # Check build flags in project meta data
    # packages inherit the project wide settings and may override them
    my $pdisabled;
    my $pdisable = {};
    my $penable = {};
    undef($penable) if $cgi->{'ignoredisable'};
    if ($jinfo->{'build'} && $penable) {
      for (@{$proj->{'repository'} || []}) {
        my $disen = BSUtil::enabled($_->{'name'}, $jinfo->{'build'}, 1, $arch);
        if ($disen) {
          $penable->{$_->{'name'}} = 1;
        } else {
          $pdisable->{$_->{'name'}} = 1;
        }
      }
      $pdisabled = 1 if !keys(%$penable);
    } else {
      # build is enabled
      undef($penable);
    }

    # Check package number quota
    my $quota_exceeded;
    if ($BSConfig::bsquotafile) {
      my $pquota = getprojquotapackage($projid);
      $quota_exceeded = 1 if defined($pquota) && @packages > $pquota;
    }

    if (!$cgi->{'ignoredisable'} && !grep {!$_->{'status'} || $_->{'status'} ne 'disabled'} @{$proj->{'repository'} || []}) {
      # either no repositories or all disabled. No need to check packages
      @packages = ();
    }
    @packages = () if $cgi->{'nopackages'};
    my @pinfo;
    my %bconfs;

    my $exclude_all;
    my $exclude_repos;
    if (!$cgi->{'ignoredisable'} && defined($cgi->{'arch'})) {
      $exclude_repos = {};
      $exclude_all = 1;
      for (@{$proj->{'repository'} || []}) {
	if (grep {$_ eq $arch} @{$_->{'arch'} || []}) {
	  undef $exclude_all;
	} else {
          $exclude_repos->{$_->{'name'}} = 1;
	}
      }
    }

    my @packages_delayed;
    my $packages_pass = 0;
    while (1) {
      if (!@packages) {
	last if !@packages_delayed || $packages_pass;
	$packages_pass = 1;
	fill_remote_getrev_cache();
	@packages = @packages_delayed;
	next;
      }
      my $packid = shift(@packages);

      next if $packids && !$packids->{$packid};
      my $pinfo = {'name' => $packid};
      push @pinfo, $pinfo;
      my $pack = readpack($projid, $packid, 1);
      $pack ||= {} if $proj->{'link'};
      if (!$pack) {
	$pinfo->{'error'} = 'no metadata';
	next;
      }
      for (qw{build publish debuginfo useforbuild bcntsynctag sourceaccess privacy access lock}) {
	$pinfo->{$_} = $pack->{$_} if $pack->{$_};
      }
      if (!$pinfo->{'build'}) {
        $pinfo->{'build'}->{'enable'} = $pack->{'enable'} if $pack->{'enable'};
        $pinfo->{'build'}->{'disable'} = $pack->{'disable'} if $pack->{'disable'};
      }
      if ($exclude_all) {
	$pinfo->{'error'} = 'excluded';
	next;
      }

      my $enable = defined($penable) ? {%$penable} : undef;
      my $disable = {%$pdisable};
      if (!$cgi->{'ignoredisable'} && $pinfo->{'build'}) {
        for (@{$proj->{'repository'} || []}) {
          my $default = exists($disable->{$_->{'name'}}) ? 0 : 1;
          my $disen = BSUtil::enabled($_->{'name'}, $pinfo->{'build'}, $default, $arch);
          if ($disen) {
            $enable->{$_->{'name'}} = 1;
            delete $disable->{$_->{'name'}};
          } else {
            $disable->{$_->{'name'}} = 1;
            delete $enable->{$_->{'name'}};
          }
        }
      }
      undef($disable) if $enable && !keys(%$enable);
      undef($enable) if $disable && !keys(%$disable);
      if ((!$disable || $pdisabled) && $enable && !%$enable) {
	$pinfo->{'error'} = 'disabled';
	next;
      }
      if ($quota_exceeded) {
	$pinfo->{'error'} = 'quota exceeded';
	next;
      }
      if ($cgi->{'withsrcmd5'} || $cgi->{'withdeps'}) {
        my $rev;
	my $linked = [];
	$collect_remote_getrev = 1 unless $packages_pass;
	eval {
	  $rev = getrev($projid, $packid, 'build', $linked);
	};
	$collect_remote_getrev = 0;
        $pinfo->{'originproject'} = $rev->{'originproject'} if $rev && $rev->{'originproject'};
        $pinfo->{'linked'} = $linked if @$linked;
	if ($@) {
	  $pinfo->{'error'} = $@;
	  $pinfo->{'error'} =~ s/\n$//s;
	  if (!$packages_pass && $pinfo->{'error'} =~ /collect_remote_getrev$/) {
	    pop @pinfo;
	    push @packages_delayed, $packid;
	  }
 	  next;
	}
	if (!$rev || $rev->{'srcmd5'} eq 'empty' || $rev->{'srcmd5'} eq $emptysrcmd5) {
	  $pinfo->{'error'} = 'no source uploaded';
	  next;
	}
	$pinfo->{'srcmd5'} = $rev->{'srcmd5'};
	$pinfo->{'rev'} = $rev->{'rev'};
	$pinfo->{'revtime'} = $rev->{'time'} if $rev->{'time'};
	my $files;
	eval {
	  my $linkinfo = {};
          $files = lsrev($rev, $linkinfo);
	  if ($linkinfo->{'xservicemd5'}) {
	    $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'});
	    $pinfo->{'srcmd5'} = $rev->{'srcmd5'};
	  }
	  if ($linkinfo->{'xservicemd5'} || $linkinfo->{'lservicemd5'} || $linkinfo->{'lsrcmd5'}) {
	    my $meta = '';
	    $meta .= "$files->{$_}  $_\n" for sort keys %$files;
	    $pinfo->{'verifymd5'} = Digest::MD5::md5_hex($meta);
	  }
	};
	if ($@) {
	  $pinfo->{'error'} = $@;
	  $pinfo->{'error'} =~ s/\n$//s;
 	  next;
	}
	if ($files->{'_service'} && -e "$eventdir/service/${projid}::$packid") {
	  $pinfo->{'error'} = 'source update running';
 	  next;
	}
        if ($files->{'_service_error'}) {
	  $pinfo->{'error'} = 'source service failed';
 	  next;
        }
	if ($files->{'_link'}) {
	  $collect_remote_getrev = 1 unless $packages_pass;
	  eval {
	    $files = handlelinks($rev, $files, {'linked' => $linked});
	  };
	  $collect_remote_getrev = 0;
	  if ($@) {
	    $files = "$@";
	    $files =~ s/\n$//;
	  }
	  if (@$linked) {
	    $pinfo->{'linked'} = $linked;
	    if ($remotemap && $remotemap->{':partitions'}) {
	      # we need to have all partition infos set for the links
	      for my $li (@$linked) {
		my $lprojid = $li->{'project'};
		next if $remotemap->{$lprojid} || $remotemap->{':partitions'}->{$lprojid};
		my $lproj = readproj($lprojid, 1);
		if ($lproj && !$lproj->{'remoteurl'}) {
		  checkpartition($remotemap, $lprojid, $lproj);
		} else {
		  $remotemap->{':partitions'}->{$lprojid} = 1;  # not on a partition
		}
	      }
	    }
	  }
	  if (!ref $files) {
	    $pinfo->{'error'} = defined($files) ? $files : "could not get file list";
	    if (!$packages_pass && $pinfo->{'error'} =~ /collect_remote_getrev$/) {
	      pop @pinfo;
	      push @packages_delayed, $packid;
	    }
	    next;
	  }
	  $pinfo->{'srcmd5'} = $rev->{'srcmd5'};
	  my $meta = '';
	  $meta .= "$files->{$_}  $_\n" for sort keys %$files;
	  $pinfo->{'verifymd5'} = Digest::MD5::md5_hex($meta);
	}
	if ($packid eq '_pattern') {
	  $jinfo->{'patternmd5'} = $pinfo->{'srcmd5'};
	  $pinfo->{'error'} = 'excluded';
	  next;
	}
	if ($files->{'_aggregate'}) {
	  my $aggregatelist = repreadxml($rev, '_aggregate', $files->{'_aggregate'}, $BSXML::aggregatelist, 1);
	  if (!$aggregatelist) {
	    $pinfo->{'error'} = "bad aggregatelist data";
	    next;
	  }
          eval {
	    BSVerify::verify_aggregatelist($aggregatelist);
          };
	  if ($@) {
	    my $err = $@;
	    $err =~ s/\n$//s;
	    $pinfo->{'error'} = "bad aggregatelist: $err";
	    next;
	  }
	  $pinfo->{'aggregatelist'} = $aggregatelist;
	  if ($remotemap && $aggregatelist) {
	    for my $aggregate (@{$aggregatelist->{'aggregate'} || []}) {
	      my $aprojid = $aggregate->{'project'};
	      next if $remotemap->{$aprojid} && !$remotemap->{$aprojid}->{'proto'};
	      my $aproj = readproj($aprojid, 1);
	      if (!$aproj || $aproj->{'remoteurl'}) {
		$aproj = remoteprojid($aprojid);
		eval {
		  fetchremoteproj($aproj, $aprojid, $remotemap) if $aproj;
		};
	      } else {
		checkpartition($remotemap, $aprojid, $aproj) if $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$aprojid};
	      }
	    }
	  }
	  if (($enable && %$enable) || ($disable && %$disable)) {
	    my @dinfo = ();
	    for my $repo (@{$proj->{'repository'} || []}) {
	      my $repoid = $repo->{'name'};
	      next if $repoids && !$repoids->{$repoid};
	      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {
	        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};
		next;
	      }
	    }
	    $pinfo->{'info'} = \@dinfo if @dinfo;
	  }
	} elsif ($files->{'_patchinfo'}) {
	  my $patchinfo = repreadxml($rev, '_patchinfo', $files->{'_patchinfo'}, $BSXML::patchinfo, 1);
          if (!$patchinfo) {
	    $pinfo->{'error'} = "bad patchinfo data";
	    next;
	  }
          eval {
	    BSVerify::verify_patchinfo($patchinfo);
          };
	  if ($@) {
	    my $err = $@;
	    chomp $err;
	    $pinfo->{'error'} = "bad patchinfo: $err";
	    next;
	  }
	  $pinfo->{'patchinfo'} = $patchinfo;
	  if (($enable && %$enable) || ($disable && %$disable)) {
	    my @dinfo = ();
	    for my $repo (@{$proj->{'repository'} || []}) {
	      my $repoid = $repo->{'name'};
	      next if $repoids && !$repoids->{$repoid};
	      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {
	        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};
		next;
	      }
	    }
	    $pinfo->{'info'} = \@dinfo if @dinfo;
	  }
	} elsif ($files->{'_channel'}) {
	  if (!exists($channeldata{$files->{'_channel'}})) {
	    eval {
	      my $channel = repreadxml($rev, '_channel', $files->{'_channel'}, $BSXML::channel);
	      BSVerify::verify_channel($channel);
	      $channeldata{$files->{'_channel'}} = $channel;
	    };
	    if ($@) {
	      my $err = $@;
	      chomp $err;
	      $channeldata{$files->{'_channel'}} = $err;
	    }
	  }
	  my $channel = $channeldata{$files->{'_channel'}} || 'bad data';
          if (!ref($channel)) {
	    $pinfo->{'error'} = "bad channel: $channel";
	    next;
	  }
          $pinfo->{'channelmd5'} = $files->{'_channel'};
	  if (($enable && %$enable) || ($disable && %$disable)) {
	    my @dinfo = ();
	    for my $repo (@{$proj->{'repository'} || []}) {
	      my $repoid = $repo->{'name'};
	      next if $repoids && !$repoids->{$repoid};
	      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {
	        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};
		next;
	      }
	    }
	    $pinfo->{'info'} = \@dinfo if @dinfo;
	  }
        } elsif ($cgi->{'withdeps'}) {
	  my @dinfo;

	  $pinfo->{'constraintsmd5'} = $files->{'_constraints'} if $files->{'_constraints'};
	  $pinfo->{'hasbuildenv'} = 1 if $files->{'_buildenv'};
	  for my $repo (@{$proj->{'repository'} || []}) {
	    my $repoid = $repo->{'name'};
	    next if $repoids && !$repoids->{$repoid};

	    my $rinfo = {'repository' => $repoid};
	    push @dinfo, $rinfo;
	    if ($exclude_repos && $exclude_repos->{$repoid}) {
	      $rinfo->{'error'} = 'excluded';
	      next;
	    }
	    if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {
	      $rinfo->{'error'} = 'disabled';
	      next;
	    }
            if (!$bconfs{$repoid}) {
	      print "calculating config for $projid/$repoid $arch\n";
	      my $path = $expandedrepos{"$projid/$repoid"};
	      if (!$path) {
	        eval {
		  my @path = expandsearchpath($projid, $repoid, $remotemap);
		  $expandedrepos{"$projid/$repoid"} = \@path;
		};
		$expandedrepos{"$projid/$repoid"} = $@ if $@;
		$path = $expandedrepos{"$projid/$repoid"};
	      }
	      eval {
		die($path) unless ref $path;
		my $c = concatconfigs($projid, $repoid, $remotemap, @$path);
	        $bconfs{$repoid} = Build::read_config($arch, [ split("\n", $c) ]);
	      };
	      if ($@) {
	        my $err = $@;
	        chomp $err;
	        $bconfs{$repoid} = {'error' => $err};
	      }
            }
	    my $conf = $bconfs{$repoid};
	    if ($conf->{'error'}) {
	      $rinfo->{'error'} = $conf->{'error'};
	      next;
	    }
	    my $type = $conf->{'type'};
	    if (!$type || $type eq 'UNDEFINED') {
	      $rinfo->{'error'} = 'bad build configuration, no build type defined or detected';
	      next;
	    }
            my ($md5, $file) = findfile($rev, $repoid, $type, $files);
	    if (!$md5) {
	      # no spec/dsc/kiwi file found
	      if ($files->{'_preinstallimage'} || $files->{'simpleimage'}  || grep {/\.(?:spec|dsc|kiwi)$/} keys %$files) {
		# only different types available
		$rinfo->{'error'} = 'excluded';
	      }
	      next;
	    }
	    $rinfo->{'file'} = $file;
	    my $buildtype = Build::recipe2buildtype($file);
	    if (!$buildtype) {
	      $rinfo->{'error'} = "don't know how to build $file";
	      next;
	    }
	    if (($type eq 'kiwi' || $buildtype eq 'kiwi') && $BSConfig::kiwiprojects && !$cgi->{'ignoredisable'}) {
	      my %kiwiprojects = map {$_ => 1} @$BSConfig::kiwiprojects;
	      if (!$kiwiprojects{$projid}) {
		$rinfo->{'error'} = 'kiwi image building is not enabled for this project';
	        next;
	      }
	    }
	    # get build dependency info
	    my $d = Build::parse_typed($conf, "$srcrep/$packid/$md5-$file", $buildtype);
	    data2utf8xml($d);
	    if (!$d || !defined($d->{'name'})) {
	      $rinfo->{'error'} = "can not parse package name from $file";
	      $rinfo->{'error'} .= " because: ".$d->{'error'} if $d->{'error'};
	      next;
	    }
	    my $version = defined($d->{'version'}) ? $d->{'version'} : 'unknown';
	    $pinfo->{'versrel'} ||= "$version-$rev->{'vrev'}";
	    $rinfo->{'name'} = $d->{'name'};
	    $rinfo->{'dep'} = $d->{'deps'};
	    if ($d->{'prereqs'}) {
	      my %deps = map {$_ => 1} (@{$d->{'deps'} || []}, @{$d->{'subpacks'} || []});
	      my @prereqs = grep {!$deps{$_} && !/^%/} @{$d->{'prereqs'}};
	      $rinfo->{'prereq'} = \@prereqs if @prereqs;
	    }
            # add all source services to be used at build time
	    if ($files->{'_service'}) {
              my $services = repreadxml($rev, '_service', $files->{'_service'}, $BSXML::services, 1);
              for my $service (@{$services->{'service'} || []}) {
                next unless $service->{'mode'} && $service->{'mode'} eq "buildtime";
                push @{$rinfo->{'dep'}}, "obs-service-$service->{'name'}";
              }
            }
	    # KIWI Products support debugmedium and sourcemedium filters
	    if ($type eq 'kiwi' && ($d->{'imagetype'}[0] || '') eq 'product') {
	      $rinfo->{'nodbgpkgs'} = 1 if defined($d->{'debugmedium'}) && $d->{'debugmedium'} <= 0;
	      $rinfo->{'nosrcpkgs'} = 1 if defined($d->{'sourcemedium'}) && $d->{'sourcemedium'} <= 0;
	    }
	    # KIWI Images don't build with local arch
	    if ($type eq 'kiwi' && ($d->{'imagetype'}[0] || '') ne 'product') {
	      $rinfo->{'error'} = 'excluded' if defined($BSConfig::localarch) && $arch eq 'local';
	    }
	    if ($type eq 'kiwi' && ($d->{'imagetype'}[0] || '') eq 'product') {
	      # KIWI Products always build on the first repo arch
	      $rinfo->{'imagearch'} = [ @{$d->{'exclarch'}} ] if $d->{'exclarch'};
	    } else {
	      my $myarch = $conf->{'target'} ? (split('-', $conf->{'target'}))[0] : $arch;
	      $rinfo->{'error'} = 'excluded' if $d->{'exclarch'} && !grep {$_ eq $myarch} @{$d->{'exclarch'}};
	      $rinfo->{'error'} = 'excluded' if $d->{'badarch'} && grep {$_ eq $myarch} @{$d->{'badarch'}};
	    }
	    for ('imagetype', 'path', 'extrasource') {
	      $rinfo->{$_} = $d->{$_} if exists $d->{$_};
	    }
	    if ($remotemap && $rinfo->{'path'}) {
	      # simple way to fill the remote map
	      eval {
		concatconfigs($projid, $repoid, $remotemap, map {"$_->{'project'}/$_->{'repository'}"} grep {$_->{'project'} ne '_obsrepositories'} @{$rinfo->{'path'}});
	      };
	    }
	  }
	  $pinfo->{'info'} = \@dinfo if @dinfo;
	}
      }
    }
    $jinfo->{'package'} = \@pinfo;
    push @res, $jinfo;
  }
  $frozenlinks_cache = undef;
  my $ret = {'repoid' => $repoid, 'project' => \@res};
  if ($remotemap) {
    delete $remotemap->{':partition'};
    delete $remotemap->{':partitions'};
  }
  #print Dumper($remotemap);
  if ($remotemap && %$remotemap) {
    for my $p (sort keys %$remotemap) {
      next unless $remotemap->{$p};
      my $r = {'project' => $p};
      # keep in sync with BSXML! (we only use access/publish from the flags)
      for (qw{kind root remoteurl remoteproject remoteroot partition proto config publish access person group repository error}) {
        $r->{$_} = $remotemap->{$p}->{$_} if defined($remotemap->{$p}->{$_});
      }
      $r->{'error'} =~ s/\n$// if $r->{'error'};
      push @{$ret->{'remotemap'}}, $r;
    }
  }
  if (%channeldata) {
    for my $md5 (sort keys %channeldata) {
      next unless ref($channeldata{$md5});
      push  @{$ret->{'channeldata'}}, {'md5' => $md5, 'channel' => $channeldata{$md5} };
    }
  }
  if ($cgi->{'view'} && $cgi->{'view'} eq 'storable') {
    return ($ret, \&BSUtil::tostorable, 'Content-Type: application/octet-stream');
  }
  return ($ret, $BSXML::projpack);
}

sub getprojectlist {
  my ($cgi) = @_;
  my @projects = findprojects($cgi->{'deleted'});
  @projects = map {{'name' => $_}} @projects;
  return ({'entry' => \@projects}, $BSXML::dir);
}

sub getproject {
  my ($cgi, $projid) = @_;
  # Read the project xml file
  my $proj = readproj($projid, 1, $cgi->{'rev'});
  $proj = remoteprojid($projid) if !$proj || $proj->{'remoteurl'};
  die("404 project '$projid' does not exist\n") unless $proj;
  if ($proj->{'remoteurl'}) {
    my $p = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_meta", 'proxy' => $proxy}, $BSXML::proj);
    # map remote names to local names
    $p->{'name'} = $projid;
    for my $r (@{$p->{'repository'} || []}) {
      for my $re (@{$r->{'path'} || []}) {
	$re->{'project'} = maptoremote($proj, $re->{'project'});
      }
      for my $re (@{$r->{'releasetarget'} || []}) {
	$re->{'project'} = maptoremote($proj, $re->{'project'});
      }
    }
    for my $pp (@{$p->{'link'} || []}) {
      $pp->{'project'} = maptoremote($proj, $pp->{'project'});
    }
    delete $p->{'person'};
    delete $p->{'group'};
    $p->{'mountproject'} = $proj->{'root'} if defined $proj->{'root'};
    $proj = $p;
  }
  return ($proj, $BSXML::proj);
}

#########################################################################

sub pubkey2sslcert {
  my ($projid, $pubkeyfile, $signkeyfile) = @_;
  die("don't know how to generate a ssl cert\n") unless $BSConfig::sign;
  $pubkeyfile ||= "$projectsdir/$projid.pkg/_pubkey";
  $signkeyfile ||= "$projectsdir/$projid.pkg/_signkey";
  my @signargs;
  push @signargs, '--project', $projid if $BSConfig::sign_project;
  my $cert = '';
  eval {
    $cert = BSUtil::xsystem(undef, $BSConfig::sign, @signargs, '-P', $signkeyfile, '-C', $pubkeyfile);
  };
  if ($@) {
    die("Need an RSA key for openssl signing, please create a new key for $projid\n") if $@ =~ /not an RSA private key/i;
    die($@);
  }
  return $cert;
}

sub updatesslcert {
  my ($projid, $pubkeyfile, $signkeyfile) = @_;
  my $rev = getrev_meta($projid, undef);
  return undef unless $rev;
  my $files = lsrev($rev);
  return undef unless $files->{'_sslcert'};
  my $cert = pubkey2sslcert($projid, $pubkeyfile, $signkeyfile);
  mkdir_p($uploaddir);
  writestr("$uploaddir/sslcert.$$", undef, $cert);
  return "$uploaddir/sslcert.$$";
}

sub createkey {
  my ($cgi, $projid) = @_;
  $cgi->{'comment'} ||= 'create sign key';
  die("don't know how to create a key\n") unless $BSConfig::sign;
  die("404 project $projid does not exist\n") unless -s "$projectsdir/$projid.xml";
  mkdir_p($uploaddir);
  my $pubkey = '';
  my @keyargs = ('rsa@2048', '800');
  my @signargs;
  push @signargs, '--project', $projid if $BSConfig::sign_project;
  my $obsname = $BSConfig::obsname || 'build.opensuse.org';
  local *F;
  open(F, '-|', $BSConfig::sign, @signargs, '-P', "$uploaddir/signkey.$$", '-g', @keyargs, "$projid OBS Project", "$projid\@$obsname") || die("$BSConfig::sign: $!\n");
  1 while sysread(F, $pubkey, 4096, length($pubkey));
  close(F) || die("$BSConfig::sign: $?\n");
  die("sign did not create signkey\n") unless -s "$uploaddir/signkey.$$";
  mkdir_p("$projectsdir/$projid.pkg");
  writestr("$uploaddir/pubkey.$$", undef, $pubkey);
  my $certfile = updatesslcert($projid, "$uploaddir/pubkey.$$", "$uploaddir/signkey.$$");
  addrev_meta_multiple($cgi, $projid, undef, 'mrev',
	[ "$uploaddir/pubkey.$$",  "$projectsdir/$projid.pkg/_pubkey",  '_pubkey' ],
	[ "$uploaddir/signkey.$$", "$projectsdir/$projid.pkg/_signkey", '_signkey' ],
	[ $certfile, undef, '_sslcert' ]);
  return $BSStdServer::return_ok;
}

sub extendkey {
  my ($cgi, $projid) = @_;
  $cgi->{'comment'} ||= 'extend public key expiry date';
  die("don't know how to extend a key\n") unless $BSConfig::sign;
  die("project does not have a key\n") unless -s "$projectsdir/$projid.pkg/_pubkey";
  die("project does not have a signkey\n") unless -s "$projectsdir/$projid.pkg/_signkey";
  my @keyargs = ('800');
  my @signargs;
  push @signargs, '--project', $projid if $BSConfig::sign_project;
  my $pubkey = '';
  local *F;
  open(F, '-|', $BSConfig::sign, @signargs, '-P', "$projectsdir/$projid.pkg/_signkey", '-x', @keyargs, "$projectsdir/$projid.pkg/_pubkey") || die("$BSConfig::sign: $!\n");
  1 while sysread(F, $pubkey, 4096, length($pubkey));
  close(F) || die("$BSConfig::sign: $?\n");
  mkdir_p($uploaddir);
  writestr("$uploaddir/pubkey.$$", undef, $pubkey);
  my $certfile = updatesslcert($projid, "$uploaddir/pubkey.$$");
  addrev_meta_multiple($cgi, $projid, undef, 'mrev',
	[ "$uploaddir/pubkey.$$",  "$projectsdir/$projid.pkg/_pubkey",  '_pubkey' ],
	[ $certfile, undef, '_sslcert' ]);
  return $BSStdServer::return_ok;
}

sub deletekey {
  my ($cgi, $projid) = @_;
  $cgi->{'comment'} ||= 'delete sign key';
  if ($BSConfig::forceprojectkeys) {
    my $pprojid = $projid;
    $pprojid =~ s/:[^:]*$//;
    my $sk;
    ($sk) = getsignkey({}, $pprojid) if $projid ne $pprojid;
    die("must have a key for signing in this or upper project\n") unless $sk;
  }
  addrev_meta_multiple($cgi, $projid, undef, 'mrev',
	[ undef, "$projectsdir/$projid.pkg/_pubkey",  '_pubkey' ],
	[ undef, "$projectsdir/$projid.pkg/_signkey", '_signkey' ],
	[ undef, undef,                               '_sslcert' ]);
  rmdir("$projectsdir/$projid.pkg");
  return $BSStdServer::return_ok;
}

sub getpubkey {
  my ($cgi, $projid) = @_;
  my $pubkey;

  my $proj = readproj($projid, 1, $cgi->{'rev'});
  $proj = remoteprojid($projid) if !$proj || $proj->{'remoteurl'};
  die("404 project '$projid' does not exist\n") unless $proj;

  if ($proj->{'remoteurl'}) {
    $pubkey = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_pubkey", 'proxy' => $proxy}, undef);
  } else {
    if ($cgi->{'rev'}) {
      my $rev = getrev_meta($projid, undef, $cgi->{'rev'});
      my $files = $rev ? lsrev($rev) : {};
      $pubkey = repreadstr($rev, '_pubkey', $files->{'_pubkey'}, 1) if $files->{'_pubkey'};
    } else {
      $pubkey = readstr("$projectsdir/$projid.pkg/_pubkey", 1);
    }
  }
  die("404 $projid: no pubkey available\n") unless $pubkey;
  return ($pubkey, 'Content-Type: text/plain');
}

#########################################################################

sub putproject {
  my ($cgi, $projid) = @_;
  mkdir_p($uploaddir);
  my $uploaded = BSServer::read_file("$uploaddir/$$");
  die("upload failed\n") unless $uploaded;
  my $proj = readxml("$uploaddir/$$", $BSXML::proj);
  $proj->{'name'} = $projid unless defined $proj->{'name'};
  BSVerify::verify_proj($proj, $projid);
  writexml("$uploaddir/$$.2", undef, $proj, $BSXML::proj);
  unlink("$uploaddir/$$");
  my $oldproj = readxml("$projectsdir/$projid.xml", $BSXML::proj, 1);
  notify($oldproj ? "SRCSRV_UPDATE_PROJECT" : "SRCSRV_CREATE_PROJECT", { "project" => $projid, "sender" => ($cgi->{'user'} || "unknown") });
  mkdir_p("$projectsdir") || die("creating $projectsdir: $!\n");
  addrev_meta($cgi, $projid, undef, "$uploaddir/$$.2", "$projectsdir/$projid.xml", '_meta');
  if ($BSConfig::forceprojectkeys) {
    my ($sk) = getsignkey({}, $projid);
    createkey({ %$cgi, 'comment' => 'autocreate key' }, $projid) if $sk eq '';
  }

  my %except = map {$_ => 1} qw{title description person group url attributes};
  if (!identical($oldproj, $proj, \%except)) {
    if ($cgi->{'lowprio'}) {
      notify_repservers('lowprioproject', $projid);
    } else {
      notify_repservers('project', $projid);
    }
  }

  $proj = readproj($projid);
  return ($proj, $BSXML::proj);
}

sub delproject {
  my ($cgi, $projid) = @_;

  $cgi->{'comment'} ||= 'project was deleted';
  die("404 project '$projid' does not exist\n") unless -e "$projectsdir/$projid.xml";
  # add delete commit to both source and meta
  addrev_meta($cgi, $projid, undef, undef, undef, undef, 'rev');
  addrev_meta($cgi, $projid, undef, undef, undef, undef);
  if (-d "$projectsdir/$projid.pkg") {
    # delete packages in sub process to avoid timeout errors
    my $pid;
    if (!($pid = xfork())) {
      # delete those packages and keys
      mkdir_p("$projectsdir/_deleted/$projid.pkg");
      # make room in old delete by deleting all old packages
      for my $f (ls("$projectsdir/_deleted/$projid.pkg")) {
        if ($f =~ /\.m?rev$/) {
          my $oldrev = readstr("$projectsdir/_deleted/$projid.pkg/$f", 1);
          if (defined($oldrev) && $oldrev ne '') {
            BSUtil::lockopen(\*F, '+>>', "$projectsdir/_deleted/$projid.pkg/$f.del");
            BSUtil::appendstr("$projectsdir/_deleted/$projid.pkg/$f.del", $oldrev);
            # XXX: add comment
            close F;
          }
          unlink("$projectsdir/_deleted/$projid.pkg/$f");
        }
      }
      for my $f (ls("$projectsdir/$projid.pkg")) {
        if ($f =~ /^(.*)\.xml$/) {
          my $packid = $1;
          if (! -f "$projectsdir/$projid.pkg/$1.mrev") {
            # create initial meta revision in case it does not exist yet
            addrev_meta($cgi, $projid, $packid, undef, undef, undef);
          }
        }
      }
      for my $f (ls("$projectsdir/$projid.pkg")) {
        if ($f =~ /\.m?rev(?:\.del)?$/) {
          updatelinkinfodb($projid, $1) if $f =~ /^(.*)\.rev$/;
          my $oldrev = readstr("$projectsdir/$projid.pkg/$f", 1);
          if (defined($oldrev) && $oldrev ne '') {
            BSUtil::lockopen(\*F, '+>>', "$projectsdir/_deleted/$projid.pkg/$f");
            BSUtil::appendstr("$projectsdir/_deleted/$projid.pkg/$f", $oldrev);
            close F;
          }
        }
        unlink("$projectsdir/$projid.pkg/$f");
      }
      rmdir("$projectsdir/$projid.pkg") || die("rmdir $projectsdir/$projid.pkg: $!\n");
    }
  }
  unlink("$projectsdir/$projid.conf");
  unlink("$projectsdir/$projid.xml");
  notify_repservers('project', $projid);

  notify("SRCSRV_DELETE_PROJECT", { "project" => $projid, "comment" => $cgi->{'comment'}, "sender" => ($cgi->{'user'} || "unknown"), "requestid" => $cgi->{'requestid'} });

  return $BSStdServer::return_ok;
}

sub undeleteproject {
  my ($cgi, $projid) = @_;

  die("404 project '$projid' already exists\n") if -e "$projectsdir/$projid.xml";
  die("404 project '$projid' is not deleted\n") unless -e "$projectsdir/_deleted/$projid.pkg";
  $cgi->{'comment'} ||= 'project was undeleted';
  mkdir_p($uploaddir);
  mkdir_p("$projectsdir/$projid.pkg");
  for my $f (ls("$projectsdir/_deleted/$projid.pkg")) {
    if ($f =~ /\.m?rev\.del$/) {
      BSUtil::cp("$projectsdir/_deleted/$projid.pkg/$f", "$uploaddir/$$.2", "$projectsdir/$projid.pkg/$f");
    } elsif ($f =~ /^(.*)\.(m?rev)$/) {
      my $packid = $1;
      my $suf = $2;
      my $rev = undelete_rev($cgi, "$projectsdir/_deleted/$projid.pkg/$f", "$projectsdir/$projid.pkg/$f");
      $rev->{'project'} = $projid;
      $rev->{'package'} = $packid;
      # extract legacy files
      if ($suf eq 'rev') {
	if ($packid eq '_project') {
          extract_old_prjsource($projid, $rev);
	} else {
	  updatelinkinfodb($projid, $packid, $rev, lsrev($rev));
	}
      } elsif ($suf eq 'mrev') {
        extract_old_meta($projid, $packid, $rev);
      }
    }
  }
  notify_repservers('project', $projid);
  notify("SRCSRV_UNDELETE_PROJECT", { "project" => $projid, "comment" => $cgi->{'comment'}, "sender" => ($cgi->{'user'} || "unknown") });

  return $BSStdServer::return_ok;
}

#########################################################################

sub getpackagelist {
  my ($cgi, $projid, $repoid, $arch) = @_;
  my $origins = $cgi->{'noorigins'} ? undef : {};
  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1) unless $cgi->{'deleted'};
  my @packages = findpackages($projid, $proj, 0, {}, $origins, !$cgi->{'expand'}, $cgi->{'deleted'});
  for (@packages) {
    $_ = {'name' => $_};
    $_->{'originproject'} = $origins->{$_->{'name'}} if $origins && $origins->{$_->{'name'}} ne $projid;
  }
  return ({'entry' => \@packages}, $BSXML::dir);
}

sub getpackage {
  my ($cgi, $projid, $packid) = @_;
  my $proj;
  $proj = checkprojrepoarch($projid, undef, undef, 1) unless $cgi->{'deleted'};
  if ($proj && $proj->{'remoteurl'}) {
    my @args;
    push @args, "rev=$cgi->{'rev'}" if $cgi->{'rev'};
    my $pack = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/_meta", 'proxy' => $proxy}, $BSXML::pack, @args);
    $pack->{'project'} = $projid;	# local name
    if ($pack->{'devel'} && exists($pack->{'devel'}->{'project'})) {
      $pack->{'devel'}->{'project'} = maptoremote($proj, $pack->{'devel'}->{'project'});
    }
    delete $pack->{'person'};
    delete $pack->{'group'};
    delete $pack->{$_} for map {$_->[0]} @BSXML::flags;
    return ($pack, $BSXML::pack);
  }
  if ($cgi->{'rev'} || $cgi->{'deleted'} || $packid eq '_project') {
    # return the exact file here
    # we also do not look at project links
    # we return the data as string so that the md5 sum matches
    my $rev = getrev_meta($projid, $packid, $cgi->{'rev'}, $cgi->{'deleted'});
    my $files = lsrev($rev);
    die("404 _meta: no such file\n") unless $files->{'_meta'};
    my $meta = repreadstr($rev, '_meta', $files->{'_meta'});
    return ($meta);
  }
  my $pack = readpack($projid, $packid, 1);
  $pack->{'project'} ||= $projid if $pack;
  if (!$pack && $proj->{'link'}) {
    my %checked = ($projid => 1);
    my @todo = map {$_->{'project'}} @{$proj->{'link'}};
    while (@todo) {
      my $lprojid = shift @todo;
      next if $checked{$lprojid};
      $checked{$lprojid} = 1;
      my $lproj = readproj($lprojid, 1);
      $lproj = remoteprojid($lprojid) if !$lproj || $lproj->{'remoteurl'};
      if ($lproj->{'remoteurl'}) {
	eval {
	  $pack = BSRPC::rpc({'uri' => "$lproj->{'remoteurl'}/source/$lproj->{'remoteproject'}/$packid/_meta", 'proxy' => $proxy}, $BSXML::pack);
	};
        die($@) if $@ && $@ !~ /^404/;
	if ($pack) {
	  $pack->{'project'} = $lprojid;	# local name
	  if ($pack->{'devel'} && exists($pack->{'devel'}->{'project'})) {
	    $pack->{'devel'}->{'project'} = maptoremote($lproj, $pack->{'devel'}->{'project'});
	  }
	}
      } else {
        $pack = readpack($lprojid, $packid, 1);
        $pack->{'project'} ||= $lprojid if $pack;
        unshift @todo, map {$_->{'project'}} @{$lproj->{'link'}} if !$pack && $lproj->{'link'};
      }
      last if $pack;
    }
  }
  die("404 package '$packid' does not exist in project '$projid'\n") unless $pack;
  return ($pack, $BSXML::pack);
}

sub putpackage {
  my ($cgi, $projid, $packid) = @_;
  mkdir_p($uploaddir);
  my $uploaded = BSServer::read_file("$uploaddir/$$");
  die("upload failed\n") unless $uploaded;
  my $pack = readxml("$uploaddir/$$", $BSXML::pack);
  $pack->{'name'} = $packid unless defined $pack->{'name'};
  BSVerify::verify_pack($pack, $packid);
  die("package contains revision data\n") if grep {exists $pack->{$_}} @$srcrevlay;
  # XXX
  # delete rev stuff, just in case...
  # delete $pack->{$_} for @$srcrevlay;
  # $pack->{'name'} = $packid;
  writexml("$uploaddir/$$.2", undef, $pack, $BSXML::pack);
  unlink("$uploaddir/$$");
  my $proj = readproj($projid);
  die("$projid is a remote project\n") if $proj->{'remoteurl'};
  if ($packid eq '_product' && ! -e "$projectsdir/$projid.pkg/$packid.xml") {
    # creating a _product package, make sure that there is no _product:xxx package
    my @pkgs = findpackages($projid, $proj, 1, undef, undef, 1);
    die("cannot create '$packid' if _product:* packages already exist\n") if grep {/^_product:/} @pkgs;
  }
  if (($packid =~ /^_product:/) && ! -e "$projectsdir/$projid.pkg/$packid.xml") {
    die("403 cannot create '$packid' if a '_product' package exists\n") if -e "$projectsdir/$projid.pkg/_product.xml";
  }
  mkdir_p("$projectsdir/$projid.pkg");

  my $oldpack = readxml("$projectsdir/$projid.pkg/$packid.xml", $BSXML::pack, 1);
  notify($oldpack ? "SRCSRV_UPDATE_PACKAGE" : "SRCSRV_CREATE_PACKAGE", { "project" => $projid, "package" => $packid, "sender" => ($cgi->{'user'} || "unknown")});

  addrev_meta($cgi, $projid, $packid, "$uploaddir/$$.2", "$projectsdir/$projid.pkg/$packid.xml", '_meta');
  my %except = map {$_ => 1} qw{title description devel person group url};
  if (!identical($oldpack, $pack, \%except)) {
    notify_repservers('package', $projid, $packid);
  }
  $pack = readpack($projid, $packid);
  return ($pack, $BSXML::pack);
}

sub delpackage {
  my ($cgi, $projid, $packid) = @_;
  $cgi->{'comment'} ||= 'package was deleted';
  die("404 project '$projid' does not exist\n") unless -e "$projectsdir/$projid.xml";
  die("404 package '$packid' does not exist in project '$projid'\n") unless -e "$projectsdir/$projid.pkg/$packid.xml";
  if ($packid =~ /^_product:/) {
    die("403 cannot delete '$packid' if a '_product' package exists\n") if -e "$projectsdir/$projid.pkg/_product.xml";
  }
  # add delete commit to both source and meta
  addrev_meta($cgi, $projid, $packid, undef, undef, undef, 'rev');
  addrev_meta($cgi, $projid, $packid, undef, undef, undef);
  unlink("$projectsdir/$projid.pkg/$packid.upload-MD5SUMS");
  unlink("$projectsdir/$projid.pkg/$packid.xml");
  my $oldrev = readstr("$projectsdir/$projid.pkg/$packid.rev", 1);
  if (defined($oldrev) && $oldrev ne '') {
    BSUtil::lockopen(\*F, '+>>', "$projectsdir/$projid.pkg/$packid.rev.del");
    BSUtil::appendstr("$projectsdir/$projid.pkg/$packid.rev.del", $oldrev);
    close F;
    updatelinkinfodb($projid, $packid);
  }
  unlink("$projectsdir/$projid.pkg/$packid.rev");
  $oldrev = readstr("$projectsdir/$projid.pkg/$packid.mrev", 1);
  if (defined($oldrev) && $oldrev ne '') {
    BSUtil::lockopen(\*F, '+>>', "$projectsdir/$projid.pkg/$packid.mrev.del");
    BSUtil::appendstr("$projectsdir/$projid.pkg/$packid.mrev.del", $oldrev);
    close F;
  }
  unlink("$projectsdir/$projid.pkg/$packid.mrev");
  if ($packid eq '_product') {
    expandproduct($projid, $packid, undef, undef);
  }
  notify_repservers('package', $projid, $packid);
  notify("SRCSRV_DELETE_PACKAGE", { "project" => $projid, "package" => $packid, "sender" => ($cgi->{'user'} || "unknown"), "comment" => $cgi->{'comment'}, "requestid" => $cgi->{'requestid'} });
  return $BSStdServer::return_ok;
}

sub undelete_rev {
  my ($cgi, $revfilefrom, $revfileto) = @_;
  my @rev = BSFileDB::fdb_getall($revfilefrom, $srcrevlay);
  die("$revfilefrom: no entries\n") unless @rev;
  # XXX add way to specify which block to restore
  for my $rev (reverse splice @rev) {
    unshift @rev, $rev;
    last if $rev->{'rev'} == 1;
  }
  my $rev = $rev[-1];
  my $user = defined($cgi->{'user'}) ? str2utf8xml($cgi->{'user'}) : 'unknown';
  my $comment = defined($cgi->{'comment'}) ? str2utf8xml($cgi->{'comment'}) : '';
  my $nrev = { 'srcmd5' => $rev->{'srcmd5'}, 'time' => time(), 'user' => $user, 'comment' => $comment, 'requestid' => $cgi->{'requestid'} };
  $nrev->{'version'} = $rev->{'version'} if $rev && defined $rev->{'version'};
  $nrev->{'vrev'} = $rev->{'vrev'} if $rev && defined $rev->{'vrev'};
  $nrev->{'rev'} = $rev->{'rev'} + 1;
  if ($cgi->{'time'}) {
    die("specified time is less than time in last commit\n") if $rev && $rev->{'time'} > $cgi->{'time'};
    $nrev->{'time'} = $cgi->{'time'};
  }
  push @rev, $nrev;
  BSFileDB::fdb_add_multiple($revfileto, $srcrevlay, @rev);
  return $nrev;
}

sub undeletepackage {
  my ($cgi, $projid, $packid) = @_;
  $cgi->{'comment'} ||= 'package was undeleted';
  die("404 project '$projid' does not exist\n") unless -e "$projectsdir/$projid.xml";
  die("403 package '$packid' already exists\n") if -e "$projectsdir/$projid.pkg/$packid.xml";
  die("403 package '$packid' was not deleted\n") unless -e "$projectsdir/$projid.pkg/$packid.rev.del";
  my $rev = undelete_rev($cgi, "$projectsdir/$projid.pkg/$packid.mrev.del", "$projectsdir/$projid.pkg/$packid.mrev");
  $rev->{'project'} = $projid;
  $rev->{'package'} = $packid;
  extract_old_meta($projid, $packid, $rev);
  if (-s "$projectsdir/$projid.pkg/$packid.rev.del") {
    my $nrev = undelete_rev($cgi, "$projectsdir/$projid.pkg/$packid.rev.del", "$projectsdir/$projid.pkg/$packid.rev");
    $nrev->{'project'} = $projid;
    $nrev->{'package'} = $packid;
    updatelinkinfodb($projid, $packid, $nrev, lsrev($nrev));
  }
  notify_repservers('package', $projid, $packid);
  notify("SRCSRV_UNDELETE_PACKAGE", { "project" => $projid, "package" => $packid, "sender" => ($cgi->{'user'} || "unknown"), "comment" => $cgi->{'comment'} });

  return $BSStdServer::return_ok;
}

sub getpackagehistory {
  my ($cgi, $projid, $packid) = @_;
  my @res;
  my $revfile;
  $packid = '_project' unless defined $packid;

  if (!$cgi->{'deleted'}) {
    my $proj = checkprojrepoarch($projid, undef, undef, 1);
    if ($proj->{'remoteurl'}) {
      my @args;
      push @args, "rev=$cgi->{'rev'}" if $cgi->{'rev'};
      my $h = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/_history", 'proxy' => $proxy}, $BSXML::revisionlist, @args);
      return ($h, $BSXML::revisionlist);
    }
    if ($packid ne '_project' && ! -e "$projectsdir/$projid.pkg/$packid.xml") {
      # check project links
      die("404 package '$packid' does not exist\n") unless $proj->{'link'};
      $cgi->{'_checked'} ||= {};
      $cgi->{'_checked'}->{$projid} = 1;
      for my $lprojid (map {$_->{'project'}} @{$proj->{'link'}}) {
	next if $cgi->{'_checked'}->{$lprojid};
	$cgi->{'_checked'}->{$lprojid} = 1;
	my $h;
	eval {
	  $h = (getpackagehistory($cgi, $lprojid, $packid))[0];
	};
	die($@) if $@ && $@ !~ /^404/;
	return ($h, $BSXML::revisionlist) if $h;
      }
      die("404 package '$packid' does not exist\n");
    }
  }

  $revfile = "$projectsdir/$projid.pkg";
  $revfile = "$projectsdir/_deleted/$projid.pkg" if $packid eq '_project' && $cgi->{'deleted'};
  $revfile .= $cgi->{'meta'} ? "/$packid.mrev" : "/$packid.rev";
  if ($packid ne '_project' && $cgi->{'deleted'}) {
    $revfile .= '.del';
    if (! -e $revfile && ! -e "$projectsdir/$projid.xml" && -e "$projectsdir/_deleted/$projid.pkg") {
      $revfile = "$projectsdir/_deleted/$projid.pkg/$packid.mrev";
    }
  }
  my $filter;
  if ($cgi->{'rev'}) {
    $filter = sub { return $cgi->{'rev'} eq $_[0]->{'rev'} || $cgi->{'rev'} eq $_[0]->{'srcmd5'} ? 1 : 0 };
  }
  for (BSFileDB::fdb_getall_reverse($revfile, $srcrevlay, $cgi->{'limit'}, $filter)) {
    $_->{'comment'} = str2utf8xml($_->{'comment'}) if $_->{'comment'};
    unshift @res, $_;
  }
  return ({'revision' => \@res}, $BSXML::revisionlist);
}

##########################################################################

##########################################################################

# XXX -> library

sub remoteprojid {
  my ($projid) = @_;
  my $rsuf = '';
  my $origprojid = $projid;

  my $proj = readproj($projid, 1);
  if ($proj) {
    return undef unless $proj->{'remoteurl'};
    return undef unless $proj->{'remoteproject'};
    return {
      'name' => $projid,
      'root' => $projid,
      'remoteroot' => $proj->{'remoteproject'},
      'remoteurl' => $proj->{'remoteurl'},
      'remoteproject' => $proj->{'remoteproject'},
    };
  }
  while ($projid =~ /^(.*)(:.*?)$/) {
    $projid = $1;
    $rsuf = "$2$rsuf";
    $proj = readproj($projid, 1);
    if ($proj) {
      return undef unless $proj->{'remoteurl'};
      if ($proj->{'remoteproject'}) {
        $rsuf = "$proj->{'remoteproject'}$rsuf";
      } else {
        $rsuf =~ s/^://;
      }
      return {
        'name' => $origprojid,
        'root' => $projid,
        'remoteroot' => $proj->{'remoteproject'},
        'remoteurl' => $proj->{'remoteurl'},
        'remoteproject' => $rsuf,
      };
    }
  }
  return undef;
}

sub maptoremote {
  my ($proj, $projid) = @_;
  return "$proj->{'root'}:$projid" unless $proj->{'remoteroot'};
  return $proj->{'root'} if $projid eq $proj->{'remoteroot'};
  return '_unavailable' if $projid !~ /^\Q$proj->{'remoteroot'}\E:(.*)$/;
  return "$proj->{'root'}:$1";
}

sub fetchremoteproj {
  my ($proj, $projid, $remotemap) = @_;
  return undef unless $proj && $proj->{'remoteurl'} && $proj->{'remoteproject'};
  $projid ||= $proj->{'name'};
  my $rproj;
  my $c;
  if ($remotemap) {
    $rproj = $remotemap->{$projid};
    if ($rproj) {
      die($rproj->{'error'}) if $rproj->{'error'};
      return $rproj unless $rproj->{'proto'};
      $c = $rproj->{'config'};	# save old config
      undef $rproj;
    }
  }
  print "fetching remote project data for $projid\n";
  my $param = {
    'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_meta",
    'timeout' => 60,
    'proxy' => $proxy,
  };
  eval {
    $rproj = BSRPC::rpc($param, $BSXML::proj);
  };
  if ($@) {
    if ($remotemap) {
      $rproj = {%$proj, 'error' => $@, 'proto' => 1};
      $rproj->{'config'} = $c if defined $c;
      $remotemap->{$projid} = $rproj;
    }
    die($@);
  }
  for (qw{name kind root remoteroot remoteurl remoteproject}) {
    $rproj->{$_} = $proj->{$_};
  }
  for my $repo (@{$rproj->{'repository'} || []}) {
    for my $pathel (@{$repo->{'path'} || []}) {
      $pathel->{'project'} = maptoremote($proj, $pathel->{'project'});
    }
    for my $pathel (@{$repo->{'releasetarget'} || []}) {
      $pathel->{'project'} = maptoremote($proj, $pathel->{'project'});
    }
  }
  for my $link (@{$rproj->{'link'} || []}) {
    $link->{'project'} = maptoremote($proj, $link->{'project'});
  }
  $remotemap->{$projid} = $rproj if $remotemap;
  return $rproj;
}

sub fetchremoteconfig {
  my ($proj, $projid, $remotemap) = @_;
  return undef unless $proj && $proj->{'remoteurl'} && $proj->{'remoteproject'};
  $projid ||= $proj->{'name'};
  if ($remotemap) {
    my $rproj = $remotemap->{$projid};
    if ($rproj) {
      die($rproj->{'error'}) if $rproj->{'error'};
      return $rproj->{'config'} if defined $rproj->{'config'};
    } else {
      $remotemap->{$projid} = {%$proj, 'proto' => 1};
    }
  }
  print "fetching remote project config for $projid\n";
  my $param = {
    'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_config",
    'timeout' => 60,
    'proxy' => $proxy,
  };
  my $c;
  eval {
    $c = BSRPC::rpc($param, undef);
  };
  if ($@) {
    $remotemap->{$projid}->{'error'} = $@ if $remotemap;
    die($@);
  }
  $remotemap->{$projid}->{'config'} = $c if $remotemap;
  return $c;
}

sub fill_remote_getrev_cache_projid {
  my ($projid, $packids) = @_;

  return unless $packids && @$packids;
  print "filling remote_getrev cache for $projid @$packids\n";
  my $proj = remoteprojid($projid);
  return unless $proj;
  my $silist;
  my @args;
  push @args, 'view=info';
  push @args, 'nofilename=1';
  push @args, map {"package=$_"} @$packids;
  eval {
    $silist = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}", 'proxy' => $proxy}, $BSXML::sourceinfolist, @args);
  };
  warn($@) if $@;
  return unless $silist;
  for my $si (@{$silist->{'sourceinfo'} || []}) {
    my $packid = $si->{'package'};
    my $rev = {};
    if ($si->{'linked'}) {
      $rev->{'linked'} = [];
      for my $l (@{$si->{'linked'}}) {
        $l->{'project'} = maptoremote($proj, $l->{'project'});
        push @{$rev->{'linked'}}, $l if defined($l->{'project'}) && $l->{'project'} ne '_unavailable';
      }
    }
    $rev->{'srcmd5'} = $si->{'verifymd5'} || $si->{'srcmd5'};
    delete $rev->{'srcmd5'} unless defined $rev->{'srcmd5'};
    if ($si->{'error'}) {
      if ($si->{'error'} =~ /^(\d+) +(.*?)$/) {
        $si->{'error'} = "$1 remote error: $2";
      } else {
        $si->{'error'} = "remote error: $si->{'error'}";
      }
      if ($si->{'error'} eq 'no source uploaded') {
	delete $si->{'error'};
	$rev->{'srcmd5'} = $emptysrcmd5;
      } elsif ($si->{'verifymd5'} || $si->{'error'} =~ /^404[^\d]/) {
	$rev->{'error'} = $si->{'error'};
	$remote_getrev_cache{"$projid/$packid/"} = $rev;
      } else {
	next;
      }
    }
    next unless $rev->{'srcmd5'};
    my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
    next unless -e "$treedir/$rev->{'srcmd5'}-MD5SUMS";
    $rev->{'vrev'} = $si->{'vrev'} || '0';
    $rev->{'rev'} = $si->{'rev'} || $rev->{'srcmd5'};
    $remote_getrev_cache{"$projid/$packid/"} = $rev;
  }
}

sub fill_remote_getrev_cache {
  for my $projid (sort keys %{$remote_getrev_todo || {}}) {
    my @packids = sort keys %{$remote_getrev_todo->{$projid} || {}};
    next if @packids <= 1;
    while (@packids) {
      my @chunk;
      my $len = 20;
      while (@packids) {
	my $packid = shift @packids;
	push @chunk, $packid;
	$len += 9 + length($packid);
	last if $len > 1900;
      }
      fill_remote_getrev_cache_projid($projid, \@chunk);
    }
  }
  $remote_getrev_todo = {};
}

sub remote_getrev {
  my ($projid, $packid, $rev, $linked, $missingok) = @_;
  my $proj = remoteprojid($projid);
  if (!$proj) {
    return {'project' => $projid, 'package' => $packid, 'srcmd5' => 'pattern', 'rev' => 'pattern'} if $packid eq '_pattern';
    return {'project' => $projid, 'package' => $packid, 'srcmd5' => $emptysrcmd5} if $missingok;
    die("404 package '$packid' does not exist\n") if -e "$projectsdir/$projid.xml";
    die("404 project '$projid' does not exist\n");
  }
  # check if we already know this srcmd5, if yes don't bother to contact
  # the remote server
  if ($rev && $rev =~ /^[0-9a-f]{32}$/) {
    my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
    if ($rev eq $emptysrcmd5 || -e "$treedir/$rev-MD5SUMS") {
      return {'project' => $projid, 'package' => $packid, 'rev' => $rev, 'srcmd5' => $rev};
    }        
  }
  if (defined($rev) && $rev eq '0') {
    return {'srcmd5' => $emptysrcmd5, 'project' => $projid, 'package' => $packid};
  }
  my @args;
  push @args, 'expand=1';
  push @args, "rev=$rev" if defined $rev;
  my $cacherev = !defined($rev) || $rev eq 'build' ? '' : $rev;
  if ($remote_getrev_cache{"$projid/$packid/$cacherev"}) {
    $rev = { %{$remote_getrev_cache{"$projid/$packid/$cacherev"}} };
    push @$linked, map { { %$_ } } @{$rev->{'linked'}} if $linked && $rev->{'linked'};
    if ($rev->{'error'}) {
      return {'project' => $projid, 'package' => $packid, 'srcmd5' => $emptysrcmd5} if $missingok && $rev->{'error'} =~ /^404[^\d]/;
      die("$rev->{'error'}\n");
    }
    delete $rev->{'linked'};
    $rev->{'project'} = $projid;
    $rev->{'package'} = $packid;
    return $rev;
  }
  if ($collect_remote_getrev && $cacherev eq '') {
    $remote_getrev_todo->{$projid}->{$packid} = 1;
    die("collect_remote_getrev\n");
  }
  my $dir;
  eval {
    $dir = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid", 'proxy' => $proxy}, $BSXML::dir, @args, 'withlinked') if $linked;
  };
  if (!$dir || $@) {
    eval {
      $dir = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid", 'proxy' => $proxy}, $BSXML::dir, @args);
    };
    if ($@) {
      return {'project' => $projid, 'package' => $packid, 'srcmd5' => $emptysrcmd5} if $missingok && $@ =~ /^404[^\d]/;
      die($@);
    }
  }
  if ($dir->{'error'}) {
    if ($linked && $dir->{'linkinfo'} && $dir->{'linkinfo'}->{'linked'}) {
      # add linked info for getprojpack
      for my $l (@{$dir->{'linkinfo'}->{'linked'}}) {
        $l->{'project'} = maptoremote($proj, $l->{'project'});
        push @$linked, $l if defined($l->{'project'}) && $l->{'project'} ne '_unavailable';
      }
    }
    die("$dir->{'error'}\n");
  }
  $rev = {};
  $rev->{'rev'} = $dir->{'rev'} || $dir->{'srcmd5'};
  $rev->{'srcmd5'} = $dir->{'srcmd5'};
  $rev->{'vrev'} = $dir->{'vrev'};
  $rev->{'vrev'} ||= '0';
  # now put everything in local srcrep
  my $files = {};
  for my $entry (@{$dir->{'entry'} || []}) {
    $files->{$entry->{'name'}} = $entry->{'md5'};
    next if -e "$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}";
    if ($linked && $entry->{'size'} > 8192) {
      # getprojpack request, hand over to AJAX
      BSHandoff::rpc($ajaxsocket, "/source/$projid/$packid", undef, "rev=$dir->{'srcmd5'}", 'view=notify');
      die("download in progress\n");
    }
    mkdir_p($uploaddir);
    my $param = {
      'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/$entry->{'name'}",
      'filename' => "$uploaddir/$$",
      'withmd5' => 1,
      'receiver' => \&BSHTTP::file_receiver,
      'proxy' => $proxy,
    };
    my $res = BSRPC::rpc($param, undef, "rev=$rev->{'srcmd5'}");
    die("file download failed\n") unless $res && $res->{'md5'} eq $entry->{'md5'};
    addfile($projid, $packid, "$uploaddir/$$", $entry->{'name'}, $entry->{'md5'});
  }
  my $srcmd5 = addmeta($projid, $packid, $files);
  if ($dir->{'serviceinfo'}) {
    $dir->{'srcmd5'} = $rev->{'srcmd5'} = $srcmd5;
  }
  my @linked;
  if ($dir->{'linkinfo'}) {
    $dir->{'srcmd5'} = $rev->{'srcmd5'} = $srcmd5;
    $rev->{'rev'} = $rev->{'srcmd5'} unless $dir->{'rev'};
    if ($linked) {
      # add linked info for getprojpack
      my $li = $dir->{'linkinfo'};
      if ($li->{'linked'}) {
	for my $l (@{$li->{'linked'}}) {
	  $l->{'project'} = maptoremote($proj, $l->{'project'});
	  push @linked, $l if defined($l->{'project'}) && $l->{'project'} ne '_unavailable';
	}
	undef $li;
      }
      while ($li) {
        my $lprojid = $li->{'project'};
        my $lpackid = $li->{'package'};
        last unless defined($lprojid) && defined($lpackid);
        my $mlprojid = maptoremote($proj, $lprojid);
        last unless defined($mlprojid) && $mlprojid ne '_unavailable';
        push @linked, {'project' => $mlprojid, 'package' => $lpackid};
	last unless $li->{'srcmd5'} && !$li->{'error'};
	my $ldir;
	eval {
	  $ldir = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$lprojid/$lpackid", 'proxy' => $proxy}, $BSXML::dir, "rev=$li->{'srcmd5'}");
	};
	last if $@ || !$ldir;
	$li = $ldir->{'linkinfo'};
      }
      push @$linked, @linked;
    }
  }
  die("srcmd5 mismatch\n") if $dir->{'srcmd5'} ne $srcmd5;
  if (!$dir->{'linkinfo'} || $linked) {
    my %revcopy = %$rev;
    $revcopy{'linked'} = [ map { { %$_ } } @linked ] if $dir->{'linkinfo'};
    $remote_getrev_cache{"$projid/$packid/$cacherev"} = \%revcopy;
  }
  $rev->{'project'} = $projid;
  $rev->{'package'} = $packid;
  return $rev;
}

sub expandsearchpath {
  my ($projid, $repoid, $remotemap, $base) = @_;
  my %done;
  my @ret;
  my @path = {project => $projid, repository => $repoid};
  while (@path) {
    my $t = shift @path;
    my $prp = "$t->{'project'}/$t->{'repository'}";
    push @ret, $prp unless $done{$prp};
    $done{$prp} = 1;
    if (!@path) {
      ($base->{'project'}, $base->{'repository'}) = ($t->{'project'}, $t->{'repository'}) if $base;
      last if $done{"/$prp"};
      my ($pid, $tid) = ($t->{'project'}, $t->{'repository'});
      my $proj = readproj($pid, 1);
      if (!$proj || $proj->{'remoteurl'}) {
	undef $proj;
	$proj = $remotemap->{$pid} if $remotemap && $remotemap->{$pid};
	if (!$proj || $proj->{'proto'}) {
          $proj = remoteprojid($pid);
          $proj = fetchremoteproj($proj, $pid, $remotemap);
          die("404 project '$pid' does not exist\n") unless $proj;
        }
      }
      checkpartition($remotemap, $pid, $proj) if $remotemap && $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$pid};
      $done{"/$prp"} = 1;       # mark expanded
      my @repo = grep {$_->{'name'} eq $tid} @{$proj->{'repository'} || []};
      push @path, @{$repo[0]->{'path'}} if @repo && $repo[0]->{'path'};
    } elsif ($remotemap) {
      my $pid = $t->{'project'};
      my $proj = readproj($pid, 1);
      if ((!$proj || $proj->{'remoteurl'}) && !$remotemap->{$pid}) {
        my $r = remoteprojid($pid);
        $remotemap->{$pid} = {%$r, 'proto' => 1} if $r;
      }
      checkpartition($remotemap, $pid, $proj) if $remotemap && $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$pid};
    }
  }
  return @ret;
}

sub concatconfigs {
  my ($projid, $repoid, $remotemap, @path) = @_;

  my $config = "%define _project $projid\n";
  my $macros = '';

  #$macros .= "%vendor Open Build Service\n";

  # find the sign project, this is what we use as vendor
  my $vprojid = $projid;
  while ($vprojid ne '') {
    last if -s "$projectsdir/$vprojid.pkg/_signkey";
    $vprojid =~ s/[^:]*$//;
    $vprojid =~ s/:$//;
  }
  $vprojid = $projid if $vprojid eq '';
  my $obsname = $BSConfig::obsname || 'build.opensuse.org';
  $macros .= "%vendor obs://$obsname/$vprojid\n";

  $macros .= "%_project $projid\n";
  my $lastr = '';

  my $distinfo = "$projid / $repoid";
  if ($repoid eq 'standard') {
    $distinfo = $projid;
  } 

  for my $prp (reverse @path) {
    if ($prp eq "$projid/$repoid") {
      $macros .= "\n%distribution $distinfo\n";
      $macros .= "%_project $projid\n";
    }
    my ($p, $r) = split('/', $prp, 2);
    my $c;
    if (-s "$projectsdir/$p.conf") {
      $c = readstr("$projectsdir/$p.conf");
    } elsif (!-e "$projectsdir/$p.xml") {
      my $proj = remoteprojid($p);
      $c = fetchremoteconfig($proj, $p, $remotemap);
    }
    if ($remotemap && $remotemap->{':partitions'}) {
      checkpartition($remotemap, $p) if !$remotemap->{':partitions'}->{$p};
      $remotemap->{$p}->{'config'} = defined($c) ? $c : '' if ($remotemap->{$p} || {})->{'partition'};
    }
    next unless defined $c;
    $config .= "\n### from $p\n";
    $config .= "%define _repository $r\n";

    if ($c =~ /^\s*:macros\s*$/im) {
      # probably some multiple macro sections with %if statements
      # flush out macros
      $macros .= "\n### from $p\n";
      $macros .= "\n%_repository $r\n";
      $config .= "\nMacros:\n$macros:Macros\n\n";
      $macros = '';
      $lastr = $r;
      my $s1 = '\A(.*^\s*:macros\s*$)(.*?)\Z';	# should always match
      if ($c =~ /$s1/msi) {
        $config .= $1;
	$c = $2;
      } else {
        $config .= $c;
	$c = '';
      }
    }
    if ($c =~ /^(.*\n)?\s*macros:[^\n]*\n(.*)/si) {
      # has single macro section at end. cumulate
      $c = defined($1) ? $1 : '';
      $macros .= "\n### from $p\n";
      $macros .= "%_repository $r\n";
      $macros .= $2;
      $lastr = $r;
    }
    $config .= $c;
  }
  if ($lastr ne $repoid) {
    $macros .= "\n### from $projid\n";
    $macros .= "%_repository $repoid\n";
  }
  if (!@path || $path[0] ne "$projid/$repoid") {
    $macros .= "\n%distribution $distinfo\n";
    $macros .= "%_project $projid\n";
  }
  if ($BSConfig::extramacros) {
    for (sort keys %{$BSConfig::extramacros}) {
      $macros .= $BSConfig::extramacros->{$_} if $projid =~ /$_/;
    }
  }
  if ($BSConfig::extraconfig) {
    my $extraconfig = '';
    for (sort keys %{$BSConfig::extraconfig}) {
      $extraconfig .= $BSConfig::extraconfig->{$_} if $projid =~ /$_/;
    }
    $config .= "\n$extraconfig" if $extraconfig;
  }
  $config .= "\nMacros:\n$macros" if $macros ne '';
  return $config;
}

sub getbuildconfig {
  my ($cgi, $projid, $repoid) = @_;
  my @path;
  if ($cgi->{'path'}) {
    @path = @{$cgi->{'path'}};
  } else {
    @path = expandsearchpath($projid, $repoid);
  }
  my $config = concatconfigs($projid, $repoid, undef, @path);
  return ($config, 'Content-Type: text/plain');
}

sub getprojectconfig {
  my ($cgi, $projid) = @_;
  my $proj = checkprojrepoarch($projid, undef, undef, 1);
  if ($proj->{'remoteurl'}) {
    my $config = BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_config", 'proxy' => $proxy}, undef);
    return ($config, 'Content-Type: text/plain');
  }
  my $config;
  if ($cgi->{'rev'}) {
    my $rev = getrev($projid, '_project', $cgi->{'rev'});
    my $files = $rev ? lsrev($rev) : {};
    $config = repreadstr($rev, '_config', $files->{'_config'}, 1) if $files->{'_config'};
  } else {
    $config = readstr("$projectsdir/$projid.conf", 1);
  }
  $config = '' unless defined $config;
  return ($config, 'Content-Type: text/plain');
}

sub putprojectconfig {
  my ($cgi, $projid) = @_;
  my $proj = readproj($projid);
  mkdir_p($uploaddir);
  my $uploadfile = "$uploaddir/$$";
  die("upload failed\n") unless BSServer::read_file($uploadfile);
  if (! -s $uploadfile) {
    unlink($uploadfile);
    $uploadfile = undef;
  }
  addrev_meta($cgi, $projid, undef, $uploadfile, "$projectsdir/$projid.conf", '_config', 'rev');
  notify_repservers('project', $projid);
  notify("SRCSRV_UPDATE_PROJECT_CONFIG", { "project" => $projid, "sender" => ($cgi->{'user'} || "unknown") });
  return $BSStdServer::return_ok;
}

sub delprojectconfig {
  my ($cgi, $projid) = @_;
  addrev_meta($cgi, $projid, undef, undef, "$projectsdir/$projid.conf", '_config', 'rev');
  notify_repservers('project', $projid);
  notify("SRCSRV_UPDATE_PROJECT_CONFIG", { "project" => $projid, "sender" => ($cgi->{'user'} || "unknown") });
  return $BSStdServer::return_ok;
}

##########################################################################

sub getsources {
  my ($cgi, $projid, $packid, $srcmd5) = @_;
  my $rev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $srcmd5};
  my $files = lsrev($rev);
  my @send = map {{'name' => $_, 'filename' => "$srcrep/$packid/$files->{$_}-$_"}} keys %$files;
  BSServer::reply_cpio(\@send);
  return undef;
}

sub detach {
  my $jev = $BSServerEvents::gev;
  return unless exists $jev->{'fd'};
  my $ev = BSEvents::new('never');
  for (keys %$jev) {
    $ev->{$_} = $jev->{$_} unless $_ eq 'id' || $_ eq 'handler' || $_ eq 'fd';
  }
  $jev->{'conf'}->{'stdreply'}->(@_) if $jev->{'conf'}->{'stdreply'};
  $BSServerEvents::gev = $ev;
  return $ev;
}

my %getfilelist_ajax_inprogress;

sub getfilelist_ajax {
  my ($cgi, $projid, $packid) = @_;

  if ($cgi->{'view'} eq 'cpio') {
    my $rev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $cgi->{'rev'}};
    my $files = lsrev($rev);
    my @send = map {{'name' => $_, 'filename' => "$srcrep/$packid/$files->{$_}-$_"}} keys %$files;
    BSWatcher::reply_cpio(\@send);
    return undef;
  }
  die("unknown view '$cgi->{'view'}'\n") unless $cgi->{'view'} eq 'notify';
  my $jev = $BSServerEvents::gev;
  if (!$jev->{'remoteurl'}) {
    die unless $cgi->{'rev'};
    my $proj = remoteprojid($projid);
    die("missing project/package\n") unless $proj;
    $jev->{'remoteurl'} = $proj->{'remoteurl'};
    $jev->{'remoteproject'} = $proj->{'remoteproject'};
  }
  if (!$jev->{'filelist'}) {
    my $rev = $cgi->{'rev'};
    return $BSStdServer::return_ok if $getfilelist_ajax_inprogress{"$projid/$packid/$rev"};
    my $param = {
      'uri' => "$jev->{'remoteurl'}/source/$jev->{'remoteproject'}/$packid",
      'proxy' => $proxy,
    };
    eval {
      $jev->{'filelist'} = BSWatcher::rpc($param, $BSXML::dir, "rev=$rev");
    };
    if ($@) {
      my $err = $@;
      notify_all_repservers('package', $projid, $packid);
      die($err);
    }
    return undef unless $jev->{'filelist'};
    $jev = detach($BSStdServer::return_ok);
    $jev->{'idstring'} = "$projid/$packid/$rev";
    $getfilelist_ajax_inprogress{"$projid/$packid/$rev"} = $jev;
    $jev->{'handler'} = sub {delete $getfilelist_ajax_inprogress{"$projid/$packid/$rev"}};
  }
  my $havesize = 0;
  my $needsize = 0;
  my @need;
  for my $entry (@{$jev->{'filelist'}->{'entry'} || []}) {
    if (-e "$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}") {
      $havesize += $entry->{'size'};
    } else {
      push @need, $entry;
      $needsize += $entry->{'size'};
    }
  }
  my $serial;
  if (@need) {
    $serial = BSWatcher::serialize("$jev->{'remoteurl'}/source");
    return undef unless $serial;
    mkdir_p($uploaddir);
  }
  if (@need > 1 && $havesize < 8192) {
    # download full cpio source
    my %need = map {$_->{'name'} => $_} @need;
    my $tmpcpiofile = "$$-$jev->{'id'}-tmpcpio";
    my $param = {
      'uri' => "$jev->{'remoteurl'}/source/$jev->{'remoteproject'}/$packid",
      'directory' => $uploaddir,
      'tmpcpiofile' => "$uploaddir/$tmpcpiofile",
      'withmd5' => 1,
      'receiver' => \&BSHTTP::cpio_receiver,
      'proxy' => $proxy,
      'map' => sub { $need{$_[1]} ? "$tmpcpiofile.$_[1]" : undef },
      'cpiopostfile' => sub {
	my $name = substr($_[1]->{'name'}, length("$tmpcpiofile."));
	die("file download confused\n") unless $need{$name} && $_[1]->{'md5'} eq $need{$name}->{'md5'};
        addfile($projid, $packid, "$uploaddir/$_[1]->{'name'}", $name, $_[1]->{'md5'});
       },
    };
    my $res;
    eval {
      $res = BSWatcher::rpc($param, undef, "rev=$cgi->{'rev'}", 'view=cpio');
    };
    if ($@) {
      # notify scheduler that the download failed
      my $err = $@;
      BSWatcher::serialize_end($serial) if $serial;
      notify_all_repservers('package', $projid, $packid);
      die($err);
    }
    return undef unless $res;
  }
  for my $entry (@need) {
    next if -e "$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}";
    my $param = {
      'uri' => "$jev->{'remoteurl'}/source/$jev->{'remoteproject'}/$packid/$entry->{'name'}",
      'filename' => "$uploaddir/$$-$jev->{'id'}",
      'withmd5' => 1,
      'receiver' => \&BSHTTP::file_receiver,
      'proxy' => $proxy,
    };
    my $res;
    eval {
      $res = BSWatcher::rpc($param, undef, "rev=$cgi->{'rev'}");
    };
    if ($@) {
      # notify scheduler that the download failed
      my $err = $@;
      BSWatcher::serialize_end($serial) if $serial;
      notify_all_repservers('package', $projid, $packid);
      die($err);
    }
    return undef unless $res;
    die("file download failed\n") unless $res && $res->{'md5'} eq $entry->{'md5'};
    die unless -e "$uploaddir/$$-$jev->{'id'}";
    addfile($projid, $packid, "$uploaddir/$$-$jev->{'id'}", $entry->{'name'}, $entry->{'md5'});
  }
  BSWatcher::serialize_end($serial) if $serial;
  delete $getfilelist_ajax_inprogress{"$projid/$packid/$cgi->{'rev'}"};
  notify_all_repservers('package', $projid, $packid);
  return '';
}

sub getproductrepositories {
  my ($xml) = @_;

  my @res;
  for my $product (@{$xml->{'products'}->{'product'}}) {
    my @pr;
    for my $repo (@{$product->{'register'}->{'updates'}->{'repository'}}) {
      my @p = published_path(undef, $repo->{'project'}, $repo->{'name'});
      my $path = { 'path' => $p[0]{'path'}, 'update' => undef };
      $path->{'arch'} = $repo->{'arch'} if $repo->{'arch'};
      $path->{'zypp'} = $repo->{'zypp'} if $repo->{'zypp'};
      $path->{'debug'} = undef if $repo->{'name'} =~ m/_debug$/;
      push @pr, $path;
    }
    for my $repo (@{$product->{'register'}->{'pool'}->{'repository'}}) {
      die("getproductrepositories: path AND url is set!\n") if defined ($repo->{'project'}) && defined($repo->{'url'});
      my $path;
      if (defined($repo->{'url'})) {
        $path = { 'url' => $repo->{'url'} };
      } else {
        my @p = published_path({"medium" => $repo->{'medium'}}, $repo->{'project'}, $repo->{'name'});
        $path = { 'path' => $p[0]{'path'} };
      }
      $path->{'arch'} = $repo->{'arch'} if $repo->{'arch'};
      $path->{'zypp'} = $repo->{'zypp'} if $repo->{'zypp'};
      $path->{'debug'} = undef if $repo->{'medium'} =~ m/_debug$/;
      push @pr, $path;
    }
    my $prod = { 'name' => $product->{'name'}, 'repository' => \@pr };
    $prod->{'distrotarget'} = $product->{'register'}->{'updates'}->{'distrotarget'} if $product->{'register'}->{'updates'}->{'distrotarget'};
    push @res, $prod;
  }
  return @res;
}

sub getfilelist {
  my ($cgi, $projid, $packid) = @_;

  my $view = $cgi->{'view'};
  my $rev;
  if ($cgi->{'meta'}) {
    $rev = getrev_meta($projid, $packid, $cgi->{'rev'}, $cgi->{'deleted'});
  } elsif ($cgi->{'deleted'}) {
    $rev = getrev_deleted($projid, $packid, $cgi->{'rev'});
  } else {
    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  }
  my $li = {};
  my $files = lsrev($rev, $li);

  # show state of current source service run, if defined
  my $serviceinfo;
  if ($li->{'xservicemd5'} || $li->{'lservicemd5'}) {
    # new style
    $serviceinfo = {};
    $serviceinfo->{'lsrcmd5'} = $li->{'lservicemd5'} if $li->{'lservicemd5'};
    if ($li->{'xservicemd5'}) {
      if ($cgi->{'expand'}) {
	$serviceinfo->{'lsrcmd5'} = $rev->{'srcmd5'};
	$files = handleservice($rev, $files, $li->{'xservicemd5'});
	$serviceinfo->{'code'} = 'succeeded';	# otherwise it already died...
      } else {
        eval { handleservice({ %$rev }, $files, $li->{'xservicemd5'}) };
	my $error = $@;
	chomp $error if $error;
	if (!$error) {
	  $serviceinfo->{'code'} = 'succeeded';
	  $serviceinfo->{'xsrcmd5'} = $li->{'xservicemd5'};
	} elsif ($error eq 'service in progress') {
	  $serviceinfo->{'code'} = 'running';
	} else {
	  $serviceinfo->{'code'} = 'failed';
	  $serviceinfo->{'xsrcmd5'} = $li->{'xservicemd5'};
	  $serviceinfo->{'error'} = $error;
	}
      }
    }
    delete $li->{'xservicemd5'};
    delete $li->{'lservicemd5'};
  } elsif ($files->{'_service'} && $packid ne '_project' && !$cgi->{'meta'} && !defined($cgi->{'rev'})) {
    # check error/in progress
    $serviceinfo = {};
    my $lockfile = "$eventdir/service/${projid}::$packid";
    if (-e $lockfile) {
      $serviceinfo->{'code'} = 'running';
    } elsif ($files->{'_service_error'}) {
      $serviceinfo->{'code'} = 'failed';
      $serviceinfo->{'error'} = repreadstr($rev, '_service_error', $files->{'_service_error'});
    } else {
      $serviceinfo->{'code'} = 'succeeded';
    }
  } elsif ($files->{'_service_error'}) {
    $serviceinfo = {'code' => 'failed'};
    $serviceinfo->{'error'} = repreadstr($rev, '_service_error', $files->{'_service_error'});
  }

  if ($files->{'_link'}) {
    if ($cgi->{'emptylink'}) {
      my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link);
      delete $l->{'patches'};
      mkdir_p($uploaddir);
      writexml("$uploaddir/$$", undef, $l, $BSXML::link);
      $files = {};
      $files->{'_link'} = addfile($projid, $packid, "$uploaddir/$$", '_link');
      $rev = addrev({}, $projid, $packid, $files, '');
    }
    my %lrev = %$rev;
    $lrev{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};
    $li->{'linked'} = [] if $cgi->{'withlinked'};
    my $lfiles = handlelinks(\%lrev, $files, $li);
    if ($cgi->{'expand'}) {
      if (!ref($lfiles)) {
	if ($cgi->{'withlinked'} && !$view) {
	  my $ret = {};
	  $ret->{'name'} = $packid;
	  $ret->{'error'} = $lfiles || 'internal error';
	  $ret->{'linkinfo'} = $li;
	  return ($ret, $BSXML::dir);
	}
	die("$lfiles\n");
      }
      $files = $lfiles;
      %$rev = %lrev;
      $rev->{'rev'} = $rev->{'srcmd5'};
    } else {
      if (ref $lfiles) {
        $li->{'xsrcmd5'} = $lrev{'srcmd5'};
      } else {
	# link is broken
	$li->{'error'} = $lfiles;
	# set xsrcmd5 if we have a link error file
	$li->{'xsrcmd5'} = $lrev{'srcmd5'} if $lrev{'srcmd5'} && -e "$srcrep/$packid/$lrev{'srcmd5'}-_linkerror";
	if ($cgi->{'lastworking'}) {
	  my $lastworking = findlastworkinglink($rev);
	  $li->{'lastworking'} = $lastworking if $lastworking;
	}
      }
    }
  }

  if ($cgi->{'extension'}) {
    for (keys %$files) {
      delete $files->{$_} unless /\.\Q$cgi->{'extension'}\E$/;
    }
  }

  if ($view && $view eq 'cpio') {
    if (!$cgi->{'extension'} && $rev->{'srcmd5'} && $rev->{'srcmd5'} ne 'upload' && $rev->{'srcmd5'} ne 'pattern' && $rev->{'srcmd5'} ne 'empty' && $rev->{'srcmd5'} ne $emptysrcmd5) {
      # hack: we identify remote source downloads by looking at the user agent
      my $useragent = $BSServer::request->{'headers'}->{'user-agent'} || '';
      if ($useragent =~ /BSRPC/) {
	BSHandoff::handoff($ajaxsocket, "/source/$projid/$packid", undef, "rev=$rev->{'srcmd5'}", 'view=cpio');
	exit(0);
      }
    }
    my @files = map {{'name' => $_, 'filename' => "$srcrep/$packid/$files->{$_}-$_"}} sort keys %$files;
    # sigh
    $files->[0]->{'filename'} = repfilename($rev, '_serviceerror', $files->{'_serviceerror'}) if @files == 1 && $files->{'_serviceerror'};
    BSServer::reply_cpio(\@files);
    return undef;
  }

  if ($view && ($view eq 'products' || $view eq 'productrepositories') ) {
    my @res;
    for my $filename (sort keys %$files) {
      next unless $filename =~ /\.product$/;
      next if $cgi->{'product'} && $filename ne "$cgi->{'product'}.product";
      my $xml = BSProductXML::readproductxml("$srcrep/$rev->{'package'}/$files->{$filename}-$filename", 0, undef, $files);
      die("400 Unable to parse $filename\n") unless $xml;
      if ($view eq 'productrepositories') {
        push @res, getproductrepositories($xml);
      } else {
        push @res, $xml;
      }
    }
    if ($view eq 'productrepositories') {
      return ({"product" => \@res}, $BSProductXML::productlistrepositories);
    }
    my $ret = {};
    $ret->{'productdefinition'} = \@res;
    return ($ret, $BSProductXML::products);
  }

  my $ret = {};
  $ret->{'name'} = $packid;
  $ret->{'srcmd5'} = $rev->{'srcmd5'} if $rev->{'srcmd5'} ne 'empty';
  $ret->{'rev'} = $rev->{'rev'} if exists $rev->{'rev'};
  $ret->{'vrev'} = $rev->{'vrev'} if exists $rev->{'vrev'};
  $ret->{'serviceinfo'} = $serviceinfo if $serviceinfo;
  my @res;
  for my $filename (sort keys %$files) {
    my @s = repstat($rev, $filename, $files->{$filename});
    if (@s) {
      push @res, {'name' => $filename, 'md5' => $files->{$filename}, 'size' => $s[7], 'mtime' => $s[9]};
    } else {
      push @res, {'name' => $filename, 'md5' => $files->{$filename}, 'error' => "$!"};
    }
  }
  if (%$li) {
    linkinfo_addtarget($rev, $li);
    $ret->{'linkinfo'} = $li;
  }
  $ret->{'entry'} = \@res;
  return ($ret, $BSXML::dir);
}

sub getfile {
  my ($cgi, $projid, $packid, $filename) = @_;
  die("no filename\n") unless defined($filename) && $filename ne '';
  die("bad filename\n") if $filename =~ /\// || $filename =~ /^\./;
  my $rev;
  if ($cgi->{'meta'}) {
    $rev = getrev_meta($projid, $packid, $cgi->{'rev'}, $cgi->{'deleted'});
  } elsif ($cgi->{'deleted'}) {
    $rev = getrev_deleted($projid, $packid, $cgi->{'rev'});
  } else {
    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  }
  my $files;
  if ($cgi->{'expand'}) {
    $files = lsrev_expanded($rev);
  } else {
    $files = lsrev($rev);
  }
  die("404 $filename: no such file\n") unless $files->{$filename};
  my @s = repstat($rev, $filename, $files->{$filename});
  die("$projid/$packid/$files->{$filename}-$filename: $!\n") unless @s;
  if (!$BSStdServer::isajax && $rev->{'srcmd5'} && $rev->{'srcmd5'} ne 'upload' && $rev->{'srcmd5'} ne 'pattern' && $rev->{'srcmd5'} ne 'empty' && $rev->{'srcmd5'} ne $emptysrcmd5) {
    # hack: we identify remote source downloads by looking at the user agent
    my $useragent = $BSServer::request->{'headers'}->{'user-agent'} || '';
    if ($useragent =~ /BSRPC/) {
      BSHandoff::handoff($ajaxsocket, "/source/$projid/$packid/$filename", undef, "rev=$rev->{'srcmd5'}");
      exit(0);
    }
  }
  my $fd = gensym;
  repopen($rev, $filename, $files->{$filename}, $fd) || die("$projid/$packid/$files->{$filename}-$filename: $!\n");
  BSWatcher::reply_file($fd);
  return undef;
}

sub putfile {
  my ($cgi, $projid, $packid, $filename) = @_;
  die("no filename\n") unless defined($filename) && $filename ne '';
  die("bad filename\n") if $filename =~ /\// || $filename =~ /^\./;
  mkdir_p($uploaddir);
  my $uploaded = BSServer::read_file("$uploaddir/$$", 'withmd5' => 1);
  die("upload failed\n") unless $uploaded;

  if ($cgi->{'meta'}) {
    if ($filename eq '_attribute') {
      my $attribs = readxml("$uploaddir/$$", $BSXML::attributes);
      BSVerify::verify_attributes($attribs);
      writexml("$uploaddir/$$", undef, $attribs, $BSXML::attributes);
    } elsif ($filename eq '_frozenlinks') {
      my $frozenx = readxml("$uploaddir/$$", $BSXML::frozenlinks);
      BSVerify::verify_frozenlinks($frozenx);
      writexml("$uploaddir/$$", undef, $frozenx, $BSXML::frozenlinks);
    } else {
      die("unsupported meta operation\n");
    }
    my $rev = addrev_meta($cgi, $projid, $packid, "$uploaddir/$$", undef, $filename);
    notify_repservers('package', $projid) if $cgi->{'meta'} && $filename eq '_frozenlinks';
    delete $rev->{'project'};
    delete $rev->{'package'};
    return ($rev, $BSXML::revision);
  }

  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  die("file '$filename' is read-only\n") if ($filename =~ /^_service:/) && !$cgi->{'force'};
  addfile($projid, $packid, "$uploaddir/$$", $filename, $uploaded->{'md5'});
  # create new meta file
  my $files;
  if ($cgi->{'keeplink'}) {
    $files = lsrev_expanded($rev);
  } else {
    $files = lsrev($rev);
  }
  $files->{$filename} = $uploaded->{'md5'};
  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};
  $rev = addrev($cgi, $projid, $packid, $files, $cgi->{'rev'});
  runservice($cgi, $rev, $files);
  delete $rev->{'project'};
  delete $rev->{'package'};
  return ($rev, $BSXML::revision);
}

sub getsourcediffcache {
  my ($cgi, $cacheid) = @_;

  my $view = $cgi->{'view'} || '';
  my $cn = "$diffcache/".substr($cacheid, 0, 2)."/$cacheid";
  BSWatcher::addfilewatcher($cn) if $BSStdServer::isajax;
  my $lockc = BSUtil::lockcheck('>>', "$cn.run");
  my $fd = gensym;
  if (open($fd, '<', $cn)) {
    unlink("$cn.run");
    utime(time, time, $cn);
    BSWatcher::reply_file($fd, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');
    return undef;
  }
  return undef if $BSStdServer::isajax && !$lockc;
  die("cache entry '$cacheid' does not exist\n");
}

sub sourcediff {
  my ($cgi, $projid, $packid) = @_;

  BSVerify::verify_linkrev($cgi->{'olinkrev'}) if defined($cgi->{'olinkrev'}) && $cgi->{'olinkrev'} ne 'linkrev';
  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;
  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;

  my $fmax = 200;
  my $tmax = 16000;
  $fmax = $cgi->{'filelimit'} if defined $cgi->{'filelimit'};
  $tmax = $cgi->{'tarlimit'} if defined $cgi->{'tarlimit'};
  undef $fmax unless $fmax;
  undef $tmax unless $tmax;

  my $have0rev = (defined($cgi->{'rev'}) && $cgi->{'rev'} eq '0') || (defined($cgi->{'orev'}) && $cgi->{'orev'} eq '0');
  my $rev;
  if ($cgi->{'meta'}) {
    $rev = getrev_meta($projid, $packid, $cgi->{'rev'});
  } else {
    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload', undef, $cgi->{'missingok'});
  }
  my $linkinfo = {};
  my $files = lsrev($rev, $linkinfo);
  $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'}) if $cgi->{'expand'} && $linkinfo->{'xservicemd5'};
  my $orev = $cgi->{'orev'};
  if (!defined($cgi->{'oproject'}) && !defined($cgi->{'opackage'}) && !defined($cgi->{'orev'}) && $rev->{'rev'}) {
    die("revision is not a simple commit\n") unless $rev->{'rev'} =~ /^\d+$/s;
    $orev = $rev->{'rev'} - 1;
    $have0rev = 1 if $orev == 0;
    $cgi->{'olinkrev'} = 'linkrev' if !defined($cgi->{'olinkrev'});
  }
  if ($cgi->{'meta'}) {
    $orev = getrev_meta($oprojid, $opackid, $orev);
  } else {
    $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest', undef, $cgi->{'missingok'});
  }
  my $olinkinfo = {};
  my $ofiles = lsrev($orev, $olinkinfo);
  $ofiles = handleservice($orev, $ofiles, $olinkinfo->{'xservicemd5'}) if $cgi->{'expand'} && $olinkinfo->{'xservicemd5'};
  if ($cgi->{'expand'} || (!$have0rev && $files->{'_link'} && !$ofiles->{'_link'}) || (!$have0rev && $ofiles->{'_link'} && !$files->{'_link'})) {
    # expand links
    if ($files->{'_link'}) {
      $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};
      my %li;
      my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link, 1);
      if ($l) {
        $l->{'project'} = $rev->{'project'} unless defined $l->{'project'};
        $l->{'package'} = $rev->{'package'} unless defined $l->{'package'};
      }
      $files = handlelinks($rev, $files, \%li);
      die("bad link: $files\n") unless ref $files;

      # some nasty magic to improve diff usability
      if ($l && $cgi->{'linkrev'} && $l->{'project'} eq $oprojid && $l->{'package'} eq $opackid && !$l->{'rev'} && !$cgi->{'orev'}) {
        # we're diffing against the link target. As the user specified a baserev, we should use it
        # instead of the latest source
        $orev = getrev($oprojid, $opackid, $li{'srcmd5'});
        $ofiles = lsrev($orev);
      }
      # olinkrev=linkrev: reuse same linkrev if the link target matches
      if ($cgi->{'olinkrev'} && $cgi->{'olinkrev'} eq 'linkrev' && $ofiles->{'_link'}) {
	my $ol = repreadxml($orev, '_link', $ofiles->{'_link'}, $BSXML::link, 1);
	if ($ol) {
	  $ol->{'project'} = $orev->{'project'} unless defined $ol->{'project'};
	  $ol->{'package'} = $orev->{'package'} unless defined $ol->{'package'};
	}
	$cgi->{'olinkrev'} = $li{'srcmd5'} if $l && $ol && $l->{'project'} eq $ol->{'project'} && $l->{'package'} eq $ol->{'package'};
      }
    }
    if ($ofiles->{'_link'}) {
      $orev->{'linkrev'} = $cgi->{'olinkrev'} if $cgi->{'olinkrev'} && $cgi->{'olinkrev'} ne 'linkrev';
      $ofiles = handlelinks($orev, $ofiles);
      die("bad link: $ofiles\n") unless ref $ofiles;
    }
  }
  my $view = $cgi->{'view'} || '';
  $view = 'unified' if $cgi->{'unified'};
  die("unsupported view '$view'\n") if $view && ($view ne 'xml' && $view ne 'unified');
  my $cacheid = "//cacheversion:2/";
  $cacheid .= "$orev->{'srcmd5'}/$rev->{'srcmd5'}";
  $cacheid .= "/unified:1" if $view && $view eq 'unified';
  $cacheid .= "/view:$cgi->{'view'}" if $view && $view ne 'unified';
  $cacheid .= "/fmax:$fmax" if defined $fmax;
  $cacheid .= "/tmax:$tmax" if defined $tmax;
  $cgi->{'withissues'} = 1 if $cgi->{'onlyissues'};
  if ($cgi->{'withissues'}) {
    my @s = stat("$BSConfig::bsdir/issuetrackers.xml");
    $cacheid .= "/withissues:$s[9]/$s[7]/$s[1]" if @s;
    $cacheid .= "/onlyissues" if $cgi->{'onlyissues'};
  }
  if ($cgi->{'file'}) {
    my %file = map {$_ => 1} @{$cgi->{'file'}};
    $cacheid .= "/file:$_" for sort keys %file;
    for (keys %$ofiles) {
      delete $ofiles->{$_} unless $file{$_};
    }
    for (keys %$files) {
      delete $files->{$_} unless $file{$_};
    }
  }
  $cacheid = Digest::MD5::md5_hex($cacheid);
  my $xmlret;
  if ($view eq 'xml') {
    $xmlret = {};
    $xmlret->{'key'} = $cacheid;
    $rev->{'rev'} ||= 0;
    $rev->{'srcmd5'} = $emptysrcmd5 if $rev->{'srcmd5'} eq 'empty';
    $orev->{'rev'} ||= 0;
    $orev->{'srcmd5'} = $emptysrcmd5 if $rev->{'srcmd5'} eq 'empty';
    $xmlret->{'old'} = { 'project' => $orev->{'project'}, 'package' => $orev->{'package'}, 'rev' => $orev->{'rev'}, 'srcmd5' => $orev->{'srcmd5'} };
    $xmlret->{'new'} = { 'project' => $rev->{'project'}, 'package' => $rev->{'package'}, 'rev' => $rev->{'rev'}, 'srcmd5' => $rev->{'srcmd5'} };
    $xmlret->{'files'} = {};
  }
  if (!grep {($ofiles->{$_} || '') ne ($files->{$_} || '')} (keys %$ofiles, keys %$files)) {
    # all files identical, don't bother
    return ($xmlret, $BSXML::sourcediff) if $view eq 'xml';
    return ('', 'Content-Type: text/plain');
  }
  local *F;
  my $cn = "$diffcache/".substr($cacheid, 0, 2)."/$cacheid";
  if (open(F, '<', $cn)) {
    utime(time, time, $cn);
    BSServer::reply_file(\*F, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');
    return undef;
  }
  local *LF;
  mkdir_p("$diffcache/".substr($cacheid, 0, 2));
  if (!BSUtil::lockcheck('>>', "$cn.run")) {
    my @args;
    push @args, "view=$view" if $view;
    BSHandoff::handoff($ajaxsocket, "/sourcediffcache/$cacheid", undef, @args);
    exit(0);
  }
  BSUtil::lockopen(\*LF, '>>', "$cn.run");
  # retry open, maybe somebody else has created the diff meanwhile
  if (open(F, '<', $cn)) {
    unlink("$cn.run");
    close LF;
    utime(time, time, $cn);
    BSServer::reply_file(\*F, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');
    return undef;
  }
  my $tmpdir = "$uploaddir/srcdiff$$";
  my $d;
  if ($view eq 'xml') {
    my %opts = ('edir' => $tmpdir, 'similar' => 1, 'doarchive' => 1, 'fmax' => $fmax, 'tmax' => $tmax);
    if (!$cgi->{'onlyissues'}) {
      $xmlret->{'files'} = { 'file' => BSSrcdiff::datadiff("$srcrep/$opackid", $ofiles, $orev->{'rev'}, "$srcrep/$packid", $files, $rev->{'rev'}, %opts) };
    }
    if ($cgi->{'withissues'}) {
      my $trackers = readxml("$BSConfig::bsdir/issuetrackers.xml", $BSXML::issue_trackers, 1) || {};
      $trackers = $trackers->{'issue-tracker'} || [];
      $xmlret->{'issues'} = { 'issue' => BSSrcdiff::issuediff("$srcrep/$opackid", $ofiles, $orev->{'rev'}, "$srcrep/$packid", $files, $rev->{'rev'}, $trackers, %opts) };
    }
    BSUtil::data2utf8xml($xmlret);
    $d = XMLout($BSXML::sourcediff, $xmlret);
  } else {
    $d = BSSrcdiff::diff("$srcrep/$opackid", $ofiles, $orev->{'rev'}, "$srcrep/$packid", $files, $rev->{'rev'}, $fmax, $tmax, $tmpdir, $view eq 'unified' ? 1 : 0);
  }
  mkdir_p("$diffcache/".substr($cacheid, 0, 2));
  writestr("$diffcache/.new$$", $cn, $d);
  unlink("$cn.run");
  close LF;
  return ($d, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');
}

sub linkdiff {
  my ($cgi, $projid, $packid) = @_;
  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};
  my $linkinfo = {};
  my $files = lsrev_expanded($rev, $linkinfo);
  die("not a link\n") unless $linkinfo->{'srcmd5'};
  linkinfo_addtarget($rev, $linkinfo);
  return sourcediff({
    %$cgi, 'expand' => 0,
    'oproject' => $linkinfo->{'project'},
    'opackage' => $linkinfo->{'package'},
    'orev' => $linkinfo->{'srcmd5'},
    'missingok' => $linkinfo->{'missingok'},
    'rev' => $rev->{'srcmd5'},
  }, $projid, $packid);
}

sub servicediff {
  my ($cgi, $projid, $packid) = @_;
  die("servicediff only works for new style services\n") if $BSConfig::old_style_services;
  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  my $linkinfo = {};
  my $files = lsrev($rev, $linkinfo);
  if ($linkinfo->{'xservicemd5'}) {
    return sourcediff({%$cgi, 'expand' => 0, 'orev' => $rev->{'srcmd5'}, 'rev' => $linkinfo->{'xservicemd5'}}, $projid, $packid);
  } elsif ($linkinfo->{'lservicemd5'}) {
    return sourcediff({%$cgi, 'expand' => 0, 'orev' => $linkinfo->{'lservicemd5'}, 'rev' => $rev->{'srcmd5'}}, $projid, $packid);
  } else {
    die("no service was run for this revision\n");
  }
}

sub isascii {
  my ($file) = @_;
  local *F;
  open(F, '<', $file) || die("$file: $!\n");
  my $buf = '';
  sysread(F, $buf, 4096);
  close F;
  return 1 unless $buf =~ /[\000-\010\016-\037]/s;
  return 0;
}

sub rundiff {
  my ($file1, $file2, $label, $outfile) = @_;
  my $pid;
  if (!($pid = xfork())) {
    if (!open(STDOUT, '>>', $outfile)) {
      print STDERR "$outfile: $!\n";
      exit(2);
    }
    exec('diff', '-up', '--label', "$label.orig", '--label', $label, $file1, $file2);
    exit(2);
  }
  waitpid($pid, 0) == $pid || die("waitpid $pid: $!\n");
  my $status = $?;
  return 1 if $status == 0 || $status == 0x100;
  return undef;
}

sub findprojectpatchname {
  my ($files) = @_;

  my $i = "";
  while ($files->{"project$i.diff"}) {
    $i = '0' unless $i;
    $i++;
  }
  return "project$i.diff";
}

#
# we are going to commit files to projid/packid, all data is already present
# in the src repository.
# if it was a link before, try to keep this link
# files: expanded file set
#
sub keeplink {
  my ($cgi, $projid, $packid, $files, $orev) = @_;

  my $repair = $cgi->{'repairlink'};
  return $files if !defined($files) || !%$files;
  return $files if $files->{'_link'};
  $orev ||= getrev($projid, $packid, 'latest');
  my $ofilesl = lsrev($orev);
  return $files unless $ofilesl && $ofilesl->{'_link'};
  my $l = repreadxml($orev, '_link', $ofilesl->{'_link'}, $BSXML::link);
  my $changedlink = 0;
  my %lignore;
  my $isbranch;

  if (@{$l->{'patches'}->{''} || []} == 1) {
    my $type = (keys %{$l->{'patches'}->{''}->[0]})[0];
    if ($type eq 'branch') {
      $isbranch = 1;
    }
  }
  undef $isbranch if $cgi->{'convertbranchtopatch'};

  if (!$isbranch && $l->{'patches'}) {
    if ($repair) {
      for (@{$l->{'patches'}->{''} || []}) {
        my $type = (keys %$_)[0];
        if ($type eq 'apply' || $type eq 'delete' || $changedlink) {
          $lignore{$_->{$type}->{'name'}} = 1 if $type ne 'topadd' && $type ne 'delete';
	  $_ = undef;
	  $changedlink = 1;
	}
      }
    } else {
      for (reverse @{$l->{'patches'}->{''} || []}) {
        my $type = (keys %$_)[0];
        if ($type eq 'apply' || $type eq 'delete' || $type eq 'branch') {
          $lignore{$_->{$type}->{'name'}} = 1 if $type eq 'apply';
	  $_ = undef;
	  $changedlink = 1;
	  next;
	}
	last;
      }
    }
    $l->{'patches'}->{''} = [ grep {defined($_)} @{$l->{'patches'}->{''}} ];
  }

  my $linkrev = $cgi->{'linkrev'};
  $linkrev = $l->{'baserev'} if $linkrev && $linkrev eq 'base';

  my $ltgtsrcmd5;
  my $ofiles;
  my $ofilesdir;
  if (!$repair) {
    # expand old link
    my %olrev = %$orev;
    my %li;
    $olrev{'linkrev'} = $linkrev if $linkrev;
    $ofiles = handlelinks(\%olrev, $ofilesl, \%li);
    die("bad link: $ofiles\n") unless ref $ofiles;
    $ltgtsrcmd5 = $li{'srcmd5'};
    $ofilesdir = "$srcrep/$packid";
  }

  # get link target file list
  my $ltgtprojid = defined($l->{'project'}) ? $l->{'project'} : $projid;
  my $ltgtpackid = defined($l->{'package'}) ? $l->{'package'} : $packid;
  my $ltgtfiles;
  if ($ltgtsrcmd5) {
    my $ltgtrev = {'project' => $ltgtprojid, 'package' => $ltgtpackid, 'srcmd5' => $ltgtsrcmd5};
    $ltgtfiles = lsrev($ltgtrev);
  } else {
    my $ltgtrev = getrev($ltgtprojid, $ltgtpackid, $linkrev || $l->{'rev'});
    $ltgtfiles = lsrev_expanded($ltgtrev);
    $ltgtsrcmd5 = $ltgtrev->{'srcmd5'};
  }

  if ($l->{'missingok'} && $ltgtfiles->{'srcmd5'} ne $emptysrcmd5) {
    # delete missingok flag as it's no longer needed
    eval {
      checksourceaccess($ltgtprojid, $ltgtpackid);
      delete $l->{'missingok'};
    };
  }
  # easy for branches: just copy file list and update baserev
  if ($isbranch) {
    my $nfiles = { %$files };
    $nfiles->{'_link'} = $ofilesl->{'_link'};
    my $lchanged;
    my $baserev = $linkrev || $ltgtsrcmd5;
    if (($l->{'baserev'} || '') ne $baserev) {
      $l->{'baserev'} = $baserev;
      $lchanged = 1;
    }
    $cgi->{'setrev'} = $baserev if $cgi->{'setrev'} && $cgi->{'setrev'} eq 'base';
    if ($cgi->{'setrev'} && ($l->{'rev'} || '') ne $cgi->{'setrev'}) {
      $l->{'rev'} = $cgi->{'setrev'};
      $lchanged = 1;
    }
    if ($lchanged) {
      $l->{'patches'}->{''} = [ { 'branch' => undef} ]; # work around xml problem
      mkdir_p($uploaddir);
      writexml("$uploaddir/$$", undef, $l, $BSXML::link);
      $nfiles->{'_link'} = addfile($projid, $packid, "$uploaddir/$$", '_link')
    }
    return $nfiles;
  }

  if ($cgi->{'convertbranchtopatch'}) {
    $ofilesl = {};
    $ofiles = $ltgtfiles;
    $ofilesdir = "$srcrep/$ltgtpackid";
  } elsif ($repair || $changedlink) {
    # apply changed link
    my $frominfo = {'project' => $ltgtprojid, 'package' => $ltgtpackid, 'srcmd5' => $ltgtsrcmd5};
    my $linkinfo = {'project' => $projid, 'package' => $packid, 'srcmd5' => $orev->{'srcmd5'}, 'link' => $l};
    $linkinfo->{'ignore'} = \%lignore;
    $ofiles = applylink(undef, $frominfo, $linkinfo);
    die("bad link: $ofiles\n") unless ref $ofiles;
    $ofilesdir = "$uploaddir/applylink$$";
  }

  #print "-- ofilesl:\n";
  #print "  $ofilesl->{$_}  $_\n" for sort keys %$ofilesl;
  #print "-- ofiles:\n";
  #print "  $ofiles->{$_}  $_\n" for sort keys %$ofiles;
  #print "-- files:\n";
  #print "  $files->{$_}  $_\n" for sort keys %$files;

  # now create diff between old $ofiles and $files
  my $nfiles = { %$ofilesl };
  delete $nfiles->{$_} for keys %lignore;	# no longer used in link
  mkdir_p($uploaddir);
  unlink("$uploaddir/$$");
  my @dfiles;
  for my $file (sort keys %{{%$files, %$ofiles}}) {
    if ($ofiles->{$file}) {
      if (!$files->{$file}) {
	if (!$ltgtfiles->{$file} && $ofilesl->{$file} && $ofilesl->{$file} eq ($ofiles->{$file} || '')) {
	  # local file no longer needed
	  delete $nfiles->{$file};
	}
	push @dfiles, $file;
	delete $nfiles->{$file};
	next;
      }
      if ($ofiles->{$file} eq $files->{$file}) {
	next;
      }
      if (!isascii("$srcrep/$packid/$files->{$file}-$file") || !isascii("$ofilesdir/$ofiles->{$file}-$file")) {
	$nfiles->{$file} = $files->{$file};
	next;
      }
    } else {
      if (!isascii("$srcrep/$packid/$files->{$file}-$file")) {
	$nfiles->{$file} = $files->{$file};
	next;
      }
    }
    if (($ofilesl->{$file} || '') eq ($ofiles->{$file} || '')) {
      # link did not change file, just record new content
      if ($files->{$file} eq ($ltgtfiles->{$file} || '')) {
	# local overwrite already in link target
	delete $nfiles->{$file};
	next;
      }
      $nfiles->{$file} = $files->{$file};
      next;
    }
    # both are ascii, create diff
    mkdir_p($uploaddir);
    if (!rundiff($ofiles->{$file} ? "$ofilesdir/$ofiles->{$file}-$file" : '/dev/null', "$srcrep/$packid/$files->{$file}-$file", $file, "$uploaddir/$$")) {
      $nfiles->{$file} = $files->{$file};
    }
  }
  my $lchanged;
  $lchanged = 1 if $changedlink;
  for (@dfiles) {
    push @{$l->{'patches'}->{''}}, {'delete' => {'name' => $_}};
    $lchanged = 1;
  }
  if (-s "$uploaddir/$$") {
    my $ppatch = findprojectpatchname($nfiles);
    $nfiles->{$ppatch} = addfile($projid, $packid, "$uploaddir/$$", $ppatch);
    push @{$l->{'patches'}->{''}}, {'apply' => {'name' => $ppatch}};
    $lchanged = 1;
  } else {
    unlink("$uploaddir/$$");
  }
  my $baserev = $linkrev || $ltgtsrcmd5;
  if (($l->{'baserev'} || '') ne $baserev) {
    $l->{'baserev'} = $baserev;
    $lchanged = 1;
  }
  $cgi->{'setrev'} = $baserev if $cgi->{'setrev'} && $cgi->{'setrev'} eq 'base';
  if ($cgi->{'setrev'} && ($l->{'rev'} || '') ne $cgi->{'setrev'}) {
    $l->{'rev'} = $cgi->{'setrev'};
    $lchanged = 1;
  }
  if ($lchanged) {
    writexml("$uploaddir/$$", undef, $l, $BSXML::link);
    $nfiles->{'_link'} = addfile($projid, $packid, "$uploaddir/$$", '_link')
  }
  if ($ofilesdir eq "$uploaddir/applylink$$") {
    BSUtil::cleandir("$uploaddir/applylink$$");
    rmdir("$uploaddir/applylink$$");
  }
  return $nfiles;
}

# integrate link from opackid to packid into packid
sub integratelink {
  my ($files, $projid, $packid, $rev, $ofiles, $oprojid, $opackid, $l, $orev) = @_;

  # append patches from link l to link nl
  my $nl = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link);

  # FIXME: remove hunks from patches that deal with replaced/deleted files
  my $nlchanged;
  my %dontcopy;
  $dontcopy{'_link'} = 1;
  my $nlisbranch;
  if ($nl->{'patches'}) {
    for (@{$nl->{'patches'}->{''} || []}) {
      my $type = (keys %$_)[0];
      if ($type eq 'add' || $type eq 'apply') {
	$dontcopy{$_->{$type}->{'name'}} = 1;
      }
      $nlisbranch = 1 if $type eq 'branch';
    }
  }
  my $lisbranch;
  if ($l->{'patches'}) {
    for (@{$l->{'patches'}->{''} || []}) {
      my $type = (keys %$_)[0];
      $lisbranch = 1 if $type eq 'branch';
    }
  }

  if ($nlisbranch) {
    # we linked/branched a branch. expand.
    #my %xrev = (%$rev, 'linkrev' => 'base');
    my %xrev = %$rev;
    my $linkinfo = {};
    lsrev_expanded(\%xrev, $linkinfo);
    my %oxrev = (%$orev, 'linkrev' => $xrev{'srcmd5'});
    $ofiles = lsrev_expanded(\%oxrev);
    copyfiles($projid, $packid, $oprojid, $opackid, $ofiles);
    # find new base
    if ($linkinfo->{'srcmd5'} ne $nl->{'baserev'}) {
      # update base rev
      $nl->{'baserev'} = $linkinfo->{'srcmd5'};
      $nlchanged = 1;
    }
    # delete everything but the link
    delete $files->{$_} for grep {$_ ne '_link'} keys %$files;
  }

  if ($lisbranch && !$nlisbranch) {
    # we branched a link. convert branch to link
    # and integrate
    delete $ofiles->{'_link'};
    $ofiles = keeplink({'convertbranchtopatch' => 1, 'linkrev' => 'base'}, $oprojid, $opackid, $ofiles, $orev);
    $l = repreadxml($orev, '_link', $ofiles->{'_link'}, $BSXML::link);
  }

  if (!$nlisbranch && $l->{'patches'}) {
    for (@{$l->{'patches'}->{''} || []}) {
      my $type = (keys %$_)[0];
      if ($type eq 'delete' && $files->{$_->{'delete'}->{'name'}} && !$dontcopy{$_->{'delete'}->{'name'}}) {
	delete $files->{$_->{'delete'}->{'name'}};
      } else {
	$nlchanged = 1;
	$nl->{'patches'} ||= {};
	if ($type eq 'apply') {
	  my $oppatch = $_->{'apply'}->{'name'};
	  if ($files->{$oppatch}) {
	    $dontcopy{$oppatch} = 1;
	    # argh, patch file already exists, rename...
	    my $ppatch = findprojectpatchname($files);
	    mkdir_p($uploaddir);
	    unlink("$uploaddir/$$");
	    link("$srcrep/$opackid/$ofiles->{$oppatch}-$oppatch", "$uploaddir/$$") || die("link $srcrep/$opackid/$ofiles->{$oppatch}-$oppatch $uploaddir/$$: $!\n");
            $files->{$ppatch} = addfile($projid, $packid, "$uploaddir/$$", $ppatch);
	    push @{$nl->{'patches'}->{''}}, {'apply' => {'name' => $ppatch}};
	    next;
	  }
	}
	if ($type eq 'add') {
	  my $oppatch = $_->{'add'}->{'name'};
	  die("cannot apply patch $oppatch twice\n") if $dontcopy{$oppatch};
	}
        push @{$nl->{'patches'}->{''}}, $_;
      }
    }
  }
  if ($nlchanged) {
    mkdir_p($uploaddir);
    writexml("$uploaddir/$$", undef, $nl, $BSXML::link);
    $files->{'_link'} = addfile($projid, $packid, "$uploaddir/$$", '_link');
  }
  for (sort keys %$ofiles) {
    next if $dontcopy{$_};
    $files->{$_} = $ofiles->{$_};
  }
  return $files;
}

sub sourcecommit {
  my ($cgi, $projid, $packid) = @_;
  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  my $files = lsrev($rev);
  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};
  $rev = addrev($cgi, $projid, $packid, $files);
  runservice($cgi, $rev, $files) unless $cgi->{'noservice'};
  delete $rev->{'project'};
  delete $rev->{'package'};
  return ($rev, $BSXML::revision);
}

sub sourcecommitfilelist {
  my ($cgi, $projid, $packid) = @_;
  BSVerify::verify_md5($cgi->{'servicemark'}) if $cgi->{'servicemark'};
  mkdir_p($uploaddir);
  my $uploaded = BSServer::read_file("$uploaddir/$$");
  die("upload failed\n") unless $uploaded;
  my $fl = readxml("$uploaddir/$$", $BSXML::dir);
  unlink("$srcrep/:upload/$$");
  # make sure we know every file
  my @missing;
  my $files = {};
  for my $entry (@{$fl->{'entry'} || []}) {
    BSVerify::verify_filename($entry->{'name'});
    BSVerify::verify_md5($entry->{'md5'});
    if (! -e "$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}") {
      push @missing, $entry;
    } else {
      die("duplicate file: $entry->{'name'}\n") if exists $files->{$entry->{'name'}};
      $files->{$entry->{'name'}} = $entry->{'md5'};
    }
  }
  if (@missing) {
    my $res = {'name' => $packid, 'error' => 'missing', 'entry' => \@missing};
    return ($res, $BSXML::dir);
  }
  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};
  if (-e "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS") {
    # autocommit old update revision so that it doesn't get lost
    my $uploadrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => 'upload'};
    my $uploadfiles = lsrev($uploadrev);
    addrev({ %$cgi, 'comment' => 'autocommit update revision'}, $projid, $packid, $uploadfiles);
  }
  my $rev = addrev($cgi, $projid, $packid, $files);
  runservice($cgi, $rev, $files) unless $cgi->{'noservice'};
  $cgi->{'rev'} = $rev->{'rev'};
  return getfilelist($cgi, $projid, $packid);
}

# admin only, move entire project
sub moveproject {
  my ($cgi, $projid) = @_;
  my $oprojid = $cgi->{'oproject'};
  return $BSStdServer::return_ok if $oprojid eq $projid;

  my $oproj = readproj($oprojid);

  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $oreposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;
  if ($reposerver ne $oreposerver) {
    die("cannot copy binaries between different reposiory servers yet\n");
  }
  if (-e "$projectsdir/$projid.pkg" || -e "$projectsdir/$projid.conf" || -e "$projectsdir/$projid.xml") {
    die("target project already exists\n");
  }

  rename("$projectsdir/$oprojid.xml", "$projectsdir/$projid.xml");
  rename("$projectsdir/$oprojid.pkg", "$projectsdir/$projid.pkg") if -e "$projectsdir/$oprojid.pkg";
  rename("$projectsdir/$oprojid.conf", "$projectsdir/$projid.conf") if -e "$projectsdir/$oprojid.conf";
  rename("$treesdir/$oprojid", "$treesdir/$projid") if $BSConfig::nosharedtrees && -e "$treesdir/$oprojid";

  # move entries in linkinfo database
  if (-d $sourcedb) {
    my $linkdb = BSDB::opendb($sourcedb, 'linkinfo');
    if ($linkdb) {
      my @packids = grep {s/\Q$oprojid\E\///} $linkdb->keys();
      for my $packid (@packids) {
	next unless -e "$projectsdir/$projid.pkg/$packid.xml";
	eval {
	  my $rev = getrev($projid, $packid);
	  updatelinkinfodb($projid, $packid, $rev, lsrev($rev)) if $rev;
	};
	warn($@) if $@;
	updatelinkinfodb($oprojid, $packid);
      }
    }
  }

  # move in the backend as well
  my @args;
  push @args, "cmd=move";
  push @args, "oproject=$oprojid";
  my $param = {
    'uri' => "$reposerver/build/$projid",
    'request' => 'POST',
  };
  eval {
    # ignore failures for now
    BSWatcher::rpc($param, undef, @args);
  };
  warn($@) if $@;

  # check all packages in project
  notify_repservers('package', $projid);
  notify_repservers('package', $oprojid);
  return $BSStdServer::return_ok;
}

# copy sources of entire project, project exists ensured by api.
sub copyproject {
  my ($cgi, $projid) = @_;
  my $oprojid = $cgi->{'oproject'};
  return $BSStdServer::return_ok if $oprojid eq $projid;

  my $proj = readproj($projid);
  my $oproj = readproj($oprojid);

  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $oreposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;
  if ($cgi->{'withbinaries'} && $reposerver ne $oreposerver) {
    die("cannot copy binaries between different reposiory servers yet\n");
  }

  my $user = defined($cgi->{'user'}) && $cgi->{'user'} ne '' ? $cgi->{'user'} : 'unknown';
  my $comment = defined($cgi->{'comment'}) ? $cgi->{'comment'} : '';
  $user = str2utf8xml($user);
  $comment = str2utf8xml($comment);

  # copy _project data
  if (-e "$projectsdir/$oprojid.pkg/_project.rev" || -e "$projectsdir/$oprojid.conf") {
    my $lastorev = getrev($oprojid, '_project');
    my $files = lsrev($lastorev);
    copyfiles($projid, '_project', $oprojid, '_project', $files);
    addrev($cgi, $projid, '_project', $files);
  }

  # use {} as we do not want to copy project linked packages
  my @pkgs = findpackages($oprojid, {});
  delete $cgi->{'servicemark'};		# just in case...
  for my $packid (@pkgs) {
    if (! -e "$projectsdir/$projid.pkg/$packid.xml") {
      # new package, create. hopefully the API can deal with this
      my $opack = readpack($oprojid, $packid);
      my $pack = {
	'project' => $projid,
	'name' => $packid,
      };
      # everything except person, group, devel and lock
      for (keys %$opack) {
        next if $_ eq 'project' || $_ eq 'name';
        next if $_ eq 'person' || $_ eq 'group' || $_ eq 'devel' || $_ eq 'lock';
        $pack->{$_} = $opack->{$_} if defined $opack->{$_};
      }
      mkdir_p($uploaddir);
      writexml("$uploaddir/copyproject$$", undef, $pack, $BSXML::pack);
      addrev_meta($cgi, $projid, $packid, "$uploaddir/copyproject$$", "$projectsdir/$projid.pkg/$packid.xml", '_meta');
      # need to do this now because the binary copy will fail otherwise
      notify_repservers('package', $projid, $packid) if $cgi->{'withbinaries'};
    }
    if ($cgi->{'makeolder'} || -s "$projectsdir/$oprojid.pkg/$packid.rev") {
      my $lastorev;
      if ($cgi->{'withhistory'}) {
	# FIXME: races ahead
	# history copying is a bit tricky, as it renumbers the revisions
	my @allrevs = BSFileDB::fdb_getall("$projectsdir/$oprojid.pkg/$packid.rev", $srcrevlay);
	if (-e "$projectsdir/$projid.pkg/$packid.rev") {
	  my $lastrev = BSFileDB::fdb_getlast("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay);
	  if ($lastrev && $lastrev->{'rev'}) {
	    for my $rev (@allrevs) {
	      $rev->{'rev'} += $lastrev->{'rev'};
	    }
	  }
	}
	# make trees available in new project
	my $treedir = $BSConfig::nosharedtrees ? "$treesdir/$projid/$packid" : "$treesdir/$packid";
	if ($BSConfig::nosharedtrees) {
	  my $treedir = "$treesdir/$projid/$packid";
	  for my $rev (@allrevs) {
	    next if -e "$treedir/$rev->{'srcmd5'}-MD5SUMS";
	    my $files = lsrev({ %$rev, 'project' => $oprojid, 'package' => $packid });
	    copyfiles($projid, $packid, $oprojid, $packid, $files);
	    addmeta($projid, $packid, $files);
	  }
	}
	BSFileDB::fdb_add_multiple("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay, @allrevs);
	$lastorev = $allrevs[-1];
      } else {
	$lastorev = BSFileDB::fdb_getlast("$projectsdir/$oprojid.pkg/$packid.rev", $srcrevlay);
      }
      if (!$lastorev || !$lastorev->{'rev'}) {
	next unless $cgi->{'makeolder'};
	# fake empty commit
	$lastorev = { 'version' => 'unknown', 'rev' => 0, 'vrev' => 0, 'srcmd5' => $emptysrcmd5 };
      }
      # always do one new commit, we don't use addrev to have full control over vrev
      my $linkinfo = {};
      my $frev = { %$lastorev, 'project' => $oprojid, 'package' => $packid };
      my $files = lsrev($frev, $linkinfo);

      my $servicemark;
      if ($linkinfo->{'xservicemd5'}) {
        if ($cgi->{'noservice'}) {
	  eval {
	    $files = handleservice($frev, $files, $linkinfo->{'xservicemd5'});
	  };
	  if ($@) {	
	    warn($@);	# hmm, could not expand service
	    $servicemark = genservicemark($projid, $packid, $files, undef, 1);
	  } else {
            copyfiles($projid, $packid, $oprojid, $packid, $files);
	    ($servicemark, $files) = servicemark_noservice($cgi, $projid, $packid, $files, undef, $linkinfo->{'xservicemd5'});
	  }
	} else {
	  $servicemark = genservicemark($projid, $packid, $files, undef, 1);
	}
      }
      copyfiles($projid, $packid, $oprojid, $packid, $files);
      $files->{'/SERVICE'} = $servicemark if $servicemark;
      my $newrev = { %$lastorev };
      $newrev->{'srcmd5'} = addmeta($projid, $packid, $files);
      $newrev->{'user'} = $user;
      $newrev->{'comment'} = $comment;
      $newrev->{'requestid'} = $cgi->{'requestid'};
      $newrev->{'time'} = time();
      if ($cgi->{'makeolder'}) {
	$newrev->{'vrev'} =~ s/(\d+)$/($1+1).".1"/e;
      } else {
	$newrev->{'vrev'} =~ s/(\d+)$/$1+1/e;
      }
      delete $newrev->{'rev'};
      $newrev = BSFileDB::fdb_add_i("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay, $newrev);
      updatelinkinfodb($projid, $packid, { %$newrev, 'project' => $oprojid, 'package' => $packid }, $files);
      if ($cgi->{'makeolder'}) {
	$lastorev->{'user'} = $user;
	$lastorev->{'comment'} = $comment;
	$lastorev->{'requestid'} = $cgi->{'requestid'};
	$lastorev->{'time'} = time();
	$lastorev->{'vrev'} =~ s/(\d+)$/$1+2/e;
	delete $lastorev->{'rev'};
	$lastorev = BSFileDB::fdb_add_i("$projectsdir/$oprojid.pkg/$packid.rev", $srcrevlay, $lastorev);
      }
    }
    # XXX: does this make any sense?
    if ($cgi->{'withbinaries'}) {
      for my $repo (@{$proj->{'repository'} || []}) {
	my $orepo = (grep {$_->{'name'} eq $repo->{'name'}} @{$oproj->{'repository'} || []})[0];
	next unless $orepo;
	for my $arch (@{$repo->{'arch'} || []}) {
	  next unless grep {$_ eq $arch} @{$orepo->{'arch'} || []};

	  # same source and target repo/arch in both projects exists
	  my @args;
	  push @args, "cmd=copy";
	  push @args, "oproject=$oprojid";
	  push @args, "opackage=$packid"; # same package name
	  push @args, "orepository=$repo->{'name'}"; # same repo name
	  push @args, 'resign=1' if $cgi->{'resign'};
	  my $param = {
	    'uri' => "$reposerver/build/$projid/$repo->{'name'}/$arch/$packid",
	    'request' => 'POST',
	  };
	  eval {
	    # ignore failures for now
	    BSWatcher::rpc($param, undef, @args);
	  };
          warn($@) if $@;
	}
      }
    }
  }
  # check all packages in project
  notify_repservers('package', $projid);
  return $BSStdServer::return_ok;
}

# we're going to auto-update a link. this means we must also
# auto-update the corresponding service result
sub update_link_in_service {
  my ($rev, $files, $xservicemd5, $isbranch) = @_;

  return undef unless defined $xservicemd5;
  return $xservicemd5 if $BSConfig::old_style_services;
  return $xservicemd5 unless $files->{'_link'};
  my $sfiles;
  eval {
    $sfiles = lsrev({%$rev, 'srcmd5' => $xservicemd5});
  };
  return $xservicemd5 unless $sfiles && $sfiles->{'_link'};
  return $xservicemd5 if $sfiles->{'_link'} && $sfiles->{'_link'} eq $files->{'_link'};	# nothing changed
  # okay, we need to generate a new service commit
  my $servicemark = genservicemark($rev->{'project'}, $rev->{'package'}, $files, undef, 1);
  return undef unless $servicemark;
  # delete all non-service files unless it's a branch
  if (!$isbranch) {
    delete $sfiles->{$_} for grep {!/^_service[_:]/} keys %$sfiles;
  }
  # copy new link
  $sfiles->{'_link'} = $files->{'_link'};
  # write back new service result
  fake_service_run($rev->{'project'}, $rev->{'package'}, $files, $sfiles, $servicemark);
  return $servicemark;
}

sub sourcecopy {
  my ($cgi, $projid, $packid) = @_;
  die("illegal rev parameter\n") if $cgi->{'rev'} && $cgi->{'rev'} ne 'upload';
  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;
  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;
  die("makeoriginolder only makes sense with withvrev\n") if $cgi->{'makeoriginolder'} && !$cgi->{'withvrev'};
  my $orev = $cgi->{'orev'};
  $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest');
  die("origin must not be virtual for makeoriginolder\n") if $cgi->{'makeoriginolder'} && $orev->{'originproject'};
  $orev->{'linkrev'} = $cgi->{'olinkrev'} if $cgi->{'olinkrev'};
  my $orev_srcmd5 = $orev->{'srcmd5'};  # so that we can restore it later
  my $files = $cgi->{'noservice'} || $cgi->{'expand'} ? lsrev_service($orev) : lsrev($orev);
  die("need a revision to copy\n") if !$cgi->{'rev'} && !$cgi->{'orev'} && $oprojid eq $projid && $opackid eq $packid && !($files->{'_link'} && $cgi->{'expand'});

  die("makeoriginolder currently does not work on links\n") if $cgi->{'makeoriginolder'} && $files->{'_link'};

  my $autosimplifylink;
  my $autosimplifylink_lrev;

  if ($files->{'_link'} && !$cgi->{'dontupdatesource'} && !$cgi->{'rev'}) {
    # fix me: do this in a more generic way
    my $ol = repreadxml($orev, '_link', $files->{'_link'}, $BSXML::link, 1);
    if ($ol) {
      my $lprojid = $oprojid;
      my $lpackid = $opackid;
      my $lrev = $ol->{'rev'};
      $lprojid = $ol->{'project'} if exists $ol->{'project'};
      $lpackid = $ol->{'package'} if exists $ol->{'package'};
      if ($lprojid eq $projid && $lpackid eq $packid) {
	# copy destination is target of link
	# we're integrating this link
	$lrev = getrev($lprojid, $lpackid, $lrev);
	$autosimplifylink_lrev = { %$lrev };
	my $lfiles = $cgi->{'noservice'} && !$cgi->{'expand'} ? lsrev_service({ %$lrev }) : lsrev($lrev);
	if ($lfiles->{'_link'} && !$cgi->{'expand'}) {
	  # link to a link, join
	  $files = integratelink($lfiles, $lprojid, $lpackid, $lrev, $files, $oprojid, $opackid, $ol, $orev);
	} else {
	  # auto expand
	  $cgi->{'expand'} = 1;
	}
	$autosimplifylink = $ol;
      }
    }
  }

  my $oldvrev = $orev->{'vrev'};
  if ($files->{'_link'} && $cgi->{'expand'}) {
    my %olrev = %$orev;		# copy so that orev still points to unexpanded sources
    $files = handlelinks(\%olrev, $files);
    die("broken link in $oprojid/$opackid: $files\n") unless ref $files;
    $oldvrev = $olrev{'vrev'};
  }

  copyfiles($projid, $packid, $oprojid, $opackid, $files);

  if ($cgi->{'withvrev'} && !$cgi->{'vrev'} && defined($oldvrev)) {
    $cgi->{'vrev'} = $oldvrev;
    # bump vrev so that new builds will have a bigger release number
    # (just like in copyproject)
    if ($cgi->{'makeoriginolder'}) {
      $cgi->{'vrev'} =~ s/(\d+)$/$1+2/e;
    } else {
      $cgi->{'vrev'} =~ s/(\d+)$/$1+1/e;
    }
  }
  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};
  my $rev = addrev($cgi, $projid, $packid, $files, $cgi->{'rev'});
  delete $cgi->{'vrev'};

  if ($cgi->{'makeoriginolder'}) {
    # add dummy commit
    my $lastline = BSFileDB::fdb_getlast("$projectsdir/$oprojid.pkg/$opackid.rev", $srcrevlay);
    die("makeoriginolder: $oprojid/$opackid does not exists?\n") unless defined $lastline;
    delete $lastline->{'requestid'};
    delete $lastline->{'rev'};
    $lastline->{'user'} = 'buildservice-autocommit';
    $lastline->{'comment'} = "makeolder vrev update for $projid/$packid";
    $lastline->{'requestid'} = $cgi->{'requestid'} if $cgi->{'requestid'};
    $lastline->{'vrev'} =~ s/(\d+)$/($1+1).".1"/e;
    BSFileDB::fdb_add_i("$projectsdir/$oprojid.pkg/$opackid.rev", $srcrevlay, $lastline);
    notify_repservers('package', $oprojid, $opackid);
  }

  if ($autosimplifylink && !defined($autosimplifylink->{'rev'})) {
    $orev->{'srcmd5'} = $orev_srcmd5;	# back to unexpanded

    # make sure that vrev doesn't decrease when copying to the
    # link target
    my $vrevbump = 0;
    if ($rev && $autosimplifylink_lrev && $rev->{'version'} ne $autosimplifylink_lrev->{'version'}) {
      # version change, check if vrev went down
      my $vrev1 = $rev->{'vrev'} || '0';
      my $vrev2 = $autosimplifylink_lrev->{'vrev'} || '0';
      $vrev1 =~ s/.*?(\d+)$/$1/;
      $vrev2 =~ s/.*?(\d+)$/$1/;
      $vrevbump = $vrev2 > $vrev1 ? $vrev2 - $vrev1 : 0;
    }

    my $isbranch = grep {(keys %$_)[0] eq 'branch'} @{$autosimplifylink->{'patches'}->{''} || []};
    if ($isbranch) {
      # update base rev so that there are no changes
      # FIXME: this is a gross hack...
      # we should not need to update the baserev, instead we should change
      # the way branches get applied

      my $ofiles = lsrev($orev);
      delete $ofiles->{'_link'};
      copyfiles($projid, $packid, $oprojid, $opackid, $ofiles);
      my $newbase = addmeta($projid, $packid, $ofiles);
      if ($autosimplifylink->{'baserev'} ne $newbase) {
	eval {
          my $latestorev = getrev($oprojid, $opackid);
	  my $latestlinkinfo = {};
          my $latestfiles = lsrev($latestorev, $latestlinkinfo);
          if ($latestfiles->{'_link'}) {
	    my $latestl = repreadxml($latestorev, '_link', $latestfiles->{'_link'}, $BSXML::link, 1);
	    my $latestisbranch = grep {(keys %$_)[0] eq 'branch'} @{$latestl->{'patches'}->{''} || []};
	    if ($latestisbranch && $latestl->{'baserev'} eq $autosimplifylink->{'baserev'}) {
	      $latestl->{'baserev'} = $newbase;
	      $latestl->{'patches'}->{''} = [ { 'branch' => undef} ]; # work around xml problem
	      if ($latestl->{'missingok'} &&
		(defined($latestl->{'project'}) ? $latestl->{'project'} : $oprojid) eq $projid &&
		(defined($latestl->{'package'}) ? $latestl->{'package'} : $opackid) eq $packid) {
		eval {
	          checksourceaccess($projid, $packid);
		  delete $latestl->{'missingok'};
		};
	      }
	      mkdir_p($uploaddir);
	      writexml("$uploaddir/$$", undef, $latestl, $BSXML::link);
              $latestfiles->{'_link'} = addfile($oprojid, $opackid, "$uploaddir/$$", '_link');
              my $servicemark = update_link_in_service($latestorev, $latestfiles, $latestlinkinfo->{'xservicemd5'}, 1);
	      if ($vrevbump) {
		$cgi->{'vrev'} = $latestorev->{'vrev'};
		$cgi->{'vrev'} =~ s/(\d+)$/$1 + $vrevbump/e;
	      }
              addrev({ %$cgi, 'user' => 'buildservice-autocommit', 'comment' => 'baserev update by copy to link target', 'servicemark' => $servicemark }, $oprojid, $opackid, $latestfiles);
	    }
	  }
	};
        warn($@) if $@;
      }
    } else {
      eval {
        my $latestorev = getrev($oprojid, $opackid);
        if ($latestorev->{'srcmd5'} eq $orev->{'srcmd5'}) {
          # simplify link
	  my $latestlinkinfo = {};
          my $latestfiles = lsrev($latestorev, $latestlinkinfo);
          my $nl = { %$autosimplifylink };
          delete $nl->{'patches'};
          delete $nl->{'baserev'};
	  mkdir_p($uploaddir);
          writexml("$uploaddir/$$", undef, $nl, $BSXML::link);
          my $ofiles = {};
          $ofiles->{'_link'} = addfile($oprojid, $opackid, "$uploaddir/$$", '_link');
          my $servicemark = update_link_in_service($latestorev, $ofiles, $latestlinkinfo->{'xservicemd5'}, 0);
	  if ($vrevbump) {
	    $cgi->{'vrev'} = $latestorev->{'vrev'};
	    $cgi->{'vrev'} =~ s/(\d+)$/$1 + $vrevbump/e;
	  }
          addrev({ %$cgi, 'user' => 'buildservice-autocommit', 'comment' => 'auto commit by copy to link target', 'servicemark' => $servicemark }, $oprojid, $opackid, $ofiles);
        }
      };
      warn($@) if $@;
    }
    delete $cgi->{'vrev'} if $vrevbump;
  }

  runservice($cgi, $rev, $files) unless $cgi->{'noservice'};

  delete $rev->{'project'};
  delete $rev->{'package'};
  return ($rev, $BSXML::revision_acceptinfo);
}

sub sourcebranch {
  my ($cgi, $projid, $packid) = @_;

  my $usebranch = 1;
  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;
  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;
  my $orev = $cgi->{'orev'};
  die("cannot branch myself\n") if $oprojid eq $projid && $opackid eq $packid;
  $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest', undef, $cgi->{'missingok'});
  $orev->{'linkrev'} = $cgi->{'olinkrev'} if $cgi->{'olinkrev'};
  print "SOURCEBRANCH $oprojid $opackid\n";
  my $files = lsrev_expanded($orev);	# modifies srcmd5, thus also needed for keepcontent case
  if ($cgi->{'keepcontent'}) {
    die("keepcontent is only supported for branches\n") unless $usebranch;
    my $nrev = getrev($projid, $packid, 'latest');
    $files = lsrev_expanded($nrev);
  }
  my $l = {};
  $l->{'project'} = $oprojid if $oprojid ne $projid;
  $l->{'package'} = $opackid if $opackid ne $packid;
  # a missing package entry is bad if the project has sourceaccess
  # disabled, so check if that's the case
  eval {
    checksourceaccess($oprojid, $opackid) if $opackid eq $packid && $oprojid ne $projid;
  };
  $l->{'package'} = $opackid if $@;
  $l->{'missingok'} = "true" if defined $cgi->{'missingok'} && $orev->{'srcmd5'} eq $emptysrcmd5;
  $l->{'rev'} = $cgi->{'orev'} if defined $cgi->{'orev'};
  $l->{'baserev'} = $orev->{'srcmd5'};
  my $lfiles = {};
  mkdir_p("$srcrep/$packid");
  if ($usebranch) {
    $l->{'patches'}->{''} = [ { 'branch' => undef} ];
    copyfiles($projid, $packid, $oprojid, $opackid, $files) unless $cgi->{'keepcontent'};
    $lfiles->{$_} = $files->{$_} for keys %$files;
  }
  mkdir_p($uploaddir);
  writexml("$uploaddir/$$", undef, $l, $BSXML::link);
  $lfiles->{'_link'} = addfile($projid, $packid, "$uploaddir/$$", '_link');
  my $rev = addrev($cgi, $projid, $packid, $lfiles);
  runservice($cgi, $rev, $lfiles) unless $cgi->{'noservice'};
  delete $rev->{'project'};
  delete $rev->{'package'};
  return ($rev, $BSXML::revision_acceptinfo);
}

sub linktobranch {
  my ($cgi, $projid, $packid) = @_;
  my $rev = getrev($projid, $packid);
  $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};
  my $files = lsrev($rev);
  die("package is not a link\n") unless $files->{'_link'};
  my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link);
  die("package is already a branch\n") if $l->{'patches'} && grep {(keys %$_)[0] eq 'branch'} @{$l->{'patches'}->{''} || []};
  my $linkinfo = {};
  $files = lsrev_expanded($rev, $linkinfo);
  $l->{'baserev'} = $linkinfo->{'srcmd5'};
  $l->{'patches'}->{''} = [ { 'branch' => undef} ];
  mkdir_p($uploaddir);
  writexml("$uploaddir/$$", undef, $l, $BSXML::link);
  $files->{'_link'} = addfile($projid, $packid, "$uploaddir/$$", '_link');
  $cgi->{'comment'} ||= 'converted link to branch';
  $rev = addrev($cgi, $projid, $packid, $files);
  runservice($cgi, $rev, $files);
  delete $rev->{'project'};
  delete $rev->{'package'};
  return ($rev, $BSXML::revision);
}

sub sourcecollectbuildenv {
  my ($cgi, $projid, $packid) = @_;
  my $oprojid = $cgi->{'oproject'} || $projid;
  my $opackid = $cgi->{'opackage'} || $packid;
  die("cannot collect from myself\n") if $oprojid eq $projid && $opackid eq $packid;
  my $proj = checkprojrepoarch($projid);
  my $oproj = checkprojrepoarch($oprojid);
  my %orepoids;
  for (@{$oproj->{'repository'} || []}) {
    $orepoids{"$oprojid/$_->{'name'}"} = $_;
  }
  for (@{$oproj->{'repository'} || []}) {
    for my $rt (@{$_->{'releasetarget'} || []}) {
      $orepoids{"$rt->{'project'}/$rt->{'repository'}"} ||= $_;
    }
  }
  my %buildenvs;
  for my $repo (@{$proj->{'repository'} || []}) {
    next unless @{$repo->{'arch'} || []};
    my $repoid = $repo->{'name'};
    my @xpath = expandsearchpath($projid, $repoid);
    my $orepo;
    for my $xr (@xpath) {
      $orepo = $orepoids{$xr};
      last if $orepo;
    }
    if ($orepo) {
      my $orepoid = $orepo->{'name'};
      my %oarchs = map {$_ => 1} @{$orepo->{'arch'} || []};
      for my $arch (@{$repo->{'arch'}}) {
	my $be;
	if (!$oarchs{$arch}) {
	  # arch not included, use error buildenv
	  $be = { 'error', "$arch missing in $oprojid/$orepoid" };
	} else {
	  my $reposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;
	  eval {
	    $be = BSRPC::rpc("$reposerver/build/$oprojid/$orepoid/$arch/$opackid/_buildenv", $BSXML::buildinfo);
	  };
	  if ($@) {
	    die($@) if $@ !~ /^404/;
	    $be = { 'error', "_buildenv missing in $oprojid/$orepoid" };
	  }
	  $be ||= { 'error', "could not get _buildenv in $oprojid/$orepoid" };
	}
        $buildenvs{"_buildenv.$repoid.$arch"} = BSUtil::toxml($be, $BSXML::buildinfo);
      }
    }
  }
  die("could not get any buildenv, something is wrong\n") unless %buildenvs;
  # add master buildenv, in our case a "fallback error" buildenv
  my $be = { 'error', "no buildenv for this repo/arch" };
  $buildenvs{'_buildenv'} = BSUtil::toxml($be, $BSXML::buildinfo);
  # now add all the buildenvs to the last commit (unexpanded is enough for us)
  my $rev = getrev($projid, $packid);
  my $files = lsrev($rev);
  delete $files->{$_} for grep {/^_buildenv/} keys %$files;
  mkdir_p($uploaddir);
  for my $file (sort keys %buildenvs) {
    writestr("$uploaddir/_be$$", undef, $buildenvs{$file});
    $files->{$file} = addfile($projid, $packid, "$uploaddir/_be$$", $file);
  }
  $rev = addrev($cgi, $projid, $packid, $files);
  runservice($cgi, $rev, $files);
  delete $rev->{'project'};
  delete $rev->{'package'};
  return ($rev, $BSXML::revision);
}

sub deleteuploadrev {
  my ($cgi, $projid, $packid) = @_;
  unlink("$projectsdir/$projid.pkg/$packid.upload-MD5SUMS");
  return $BSStdServer::return_ok;
}

sub unknowncmd {
  my ($cgi, $projid, $packid) = @_;
  die("unknown command \"$cgi->{'cmd'}\"\n");
}

sub delfile {
  my ($cgi, $projid, $packid, $filename) = @_;
  die("no filename\n") unless defined($filename) && $filename ne '';
  die("bad filename\n") if $filename =~ /\// || $filename =~ /^\./;
  if ($cgi->{'meta'}) {
    if ($filename ne '_attribute' && $filename ne '_frozenlinks') {
      die("unsupported meta operation\n");
    }
    my $rev = addrev_meta($cgi, $projid, $packid, undef, undef, $filename);
    notify_repservers('package', $projid) if $filename eq '_frozenlinks';
    delete $rev->{'project'};
    delete $rev->{'package'};
    return ($rev, $BSXML::revision);
  }
  die("file '$filename' is read-only\n") if ($filename =~ /^_service:/) && !$cgi->{'force'};
  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  my $files;
  if ($cgi->{'keeplink'}) {
    $files = lsrev_expanded($rev);
  } else {
    $files = lsrev($rev);
  }
  die("404 file '$filename' does not exist\n") unless $files->{$filename};
  delete $files->{$filename};
  $files = keeplink($projid, $packid, $files) if $cgi->{'keeplink'};
  $rev = addrev($cgi, $projid, $packid, $files, $cgi->{'rev'});
  runservice($cgi, $rev, $files);
  delete $rev->{'project'};
  delete $rev->{'package'};
  return ($rev, $BSXML::revision);
}

sub getrepositorylist {
  my ($cgi, $projid) = @_;
  my $proj = checkprojrepoarch($projid, undef, undef, 1);
  if ($proj->{'remoteurl'}) {
    return (BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/build/$proj->{'remoteproject'}", 'proxy' => $proxy}, $BSXML::dir), $BSXML::dir);
  }
  my @res = map {{'name' => $_->{'name'}}} @{$proj->{'repository'} || []};
  return ({'entry' => \@res}, $BSXML::dir);
}

sub getrepository {
  my ($cgi, $projid, $repoid) = @_;
  my $proj = readproj($projid);
  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];
  die("404 $repoid: no such repository\n") unless $repo;
  return ($repo, $BSXML::repo);
}

sub getarchlist {
  my ($cgi, $projid, $repoid) = @_;
  my $proj = checkprojrepoarch($projid, $repoid, undef, 1);
  if ($proj->{'remoteurl'}) {
    return (BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid", 'proxy' => $proxy}, $BSXML::dir), $BSXML::dir);
  }
  my @repo = grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []};
  die("404 $repoid: no such repository\n") unless @repo;
  my @res = map {{'name' => $_}} @{$repo[0]->{'arch'} || []};
  return ({'entry' => \@res}, $BSXML::dir);
}

sub getresult {
  my ($cgi, $projid) = @_;

  my $proj = checkprojrepoarch($projid, undef, undef, 1);
  if ($proj->{'remoteurl'}) {
    die("oldstate not supported for remote projects\n") if $cgi->{'oldstate'};
    my @args;
    push @args, "lastbuild" if $cgi->{'lastbuild'};
    push @args, map {"view=$_"} @{$cgi->{'view'} || []};
    push @args, map {"repository=$_"} @{$cgi->{'repository'} || []};
    push @args, map {"arch=$_"} @{$cgi->{'arch'} || []};
    push @args, map {"package=$_"} @{$cgi->{'package'} || []};
    push @args, map {"code=$_"} @{$cgi->{'code'} || []};
    return (BSRPC::rpc({'uri' => "$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/_result", 'proxy' => $proxy}, $BSXML::resultlist, @args), $BSXML::resultlist);
  }
  if ($cgi->{'oldstate'} && !$BSStdServer::isajax) {
    my @args = "oldstate=$cgi->{'oldstate'}";
    push @args, "lastbuild" if $cgi->{'lastbuild'};
    push @args, map {"view=$_"} @{$cgi->{'view'} || []};
    push @args, map {"repository=$_"} @{$cgi->{'repository'} || []};
    push @args, map {"arch=$_"} @{$cgi->{'arch'} || []};
    push @args, map {"package=$_"} @{$cgi->{'package'} || []};
    push @args, map {"code=$_"} @{$cgi->{'code'} || []};
    BSHandoff::handoff($ajaxsocket, "/build/$projid/_result", undef, @args);
    exit(0);
  }

  my %repoidfilter = map {$_ => 1} @{$cgi->{'repository'} || []};
  my %archfilter = map {$_ => 1} @{$cgi->{'arch'} || []};
  my %view = map {$_ => 1} @{$cgi->{'view'} || ['status']};
  my %code = map {$_ => 1} @{$cgi->{'code'} || []};

  if ($cgi->{'repository'}) {
    my %knownrepoids = map {$_->{'name'} => 1} @{$proj->{'repository'} || []};
    for (@{$cgi->{'repository'}}) {
      die("404 unknown repository '$_'\n") if !$knownrepoids{$_};
    }
  }
  if ($cgi->{'package'}) {
    my %knownpackids = map {$_ => 1} findpackages($projid, $proj, 1);
    for (@{$cgi->{'package'}}) {
      die("404 unknown package '$_'\n") if !$knownpackids{$_};
    }
  }
  my @prpas;
  for my $repo (@{$proj->{'repository'} || []}) {
    next if %repoidfilter && !$repoidfilter{$repo->{'name'}};
    my @archs = @{$repo->{'arch'} || []};
    @archs = grep {$archfilter{$_}} @archs if %archfilter;
    push @prpas, map {"$projid/$repo->{'name'}/$_"} @archs;
  }

  BSWatcher::addfilewatcher("$projectsdir/$projid.xml") if $BSStdServer::isajax;

  if (!@prpas) {
    my $state = "00000000000000000000000000000000";
    return undef if $BSStdServer::isajax && $cgi->{'oldstate'} && $state eq $cgi->{'oldstate'};
    return ({'state' => $state}, $BSXML::resultlist);
  }

  my $ps = {};
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my @args;
  push @args, 'lastbuild' if $cgi->{'lastbuild'};
  push @args, "oldstate=$cgi->{'oldstate'}" if $cgi->{'oldstate'};
  push @args, map {"prpa=$_"} @prpas;
  push @args, map {"package=$_"} @{$cgi->{'package'} || []};
  push @args, map {"code=$_"} @{$cgi->{'code'} || []};
  push @args, 'withbinarylist' if $view{'binarylist'};
  push @args, 'withstats' if $view{'stats'};
  push @args, 'summary' if $view{'summary'} && !$view{'status'};
  eval {
    $ps = BSWatcher::rpc("$reposerver/_result", $BSXML::resultlist, @args);
  };
  if ($@) {
    print "warning: $reposerver: $@";
    $ps = {};
  }
  return if $BSStdServer::isajax && !defined($ps);
  if ($view{'summary'} && $view{'status'}) {
    my @order = ('succeeded', 'failed', 'unresolvable', 'broken', 'scheduled');
    my %order = map {$_ => 1} @order;
    for my $p (@{$ps->{'result'} || []}) {
      my %sum;
      for my $pp (@{$p->{'status'} || []}) {
        $sum{$pp->{'code'}}++ if $pp->{'code'};
      }
      my @sum = grep {exists $sum{$_}} @order;
      push @sum, grep {!$order{$_}} sort keys %sum;
      $p->{'summary'} = {'statuscount' => [ map {{'code' => $_, 'count' => $sum{$_}}} @sum ] };
    }
  }
  if (!$view{'status'}) {
    for my $p (@{$ps->{'result'} || []}) {
      delete $p->{'status'};
    }
  }
  return ($ps, $BSXML::resultlist);
}

sub docommand {
  my ($cgi, $projid) = @_;

  my %repoidfilter = map {$_ => 1} @{$cgi->{'repository'} || []};
  my %archfilter = map {$_ => 1} @{$cgi->{'arch'} || []};

  my $proj = readproj($projid);
  my @prpas;
  for my $repo (@{$proj->{'repository'} || []}) {
    next if %repoidfilter && !$repoidfilter{$repo->{'name'}};
    my @archs = @{$repo->{'arch'} || []};
    @archs = grep {$archfilter{$_}} @archs if %archfilter;
    push @prpas, map {"$projid/$repo->{'name'}/$_"} @archs;
  }
  die("no repository defined\n") unless @prpas;
  my @packids = @{$cgi->{'package'} || []};
  if ($cgi->{'cmd'} eq 'wipepublishedlocked') {
    die("wipepublishedlocked can only wipe complete repos\n") if $cgi->{'arch'} || $cgi->{'code'} || @packids;
  } else {
    if (@packids) {
      my %packids = map {$_ => 1} findpackages($projid, $proj, 1);
      my @badpacks = grep {!$packids{$_}} @packids;
      die("404 unknown package: @badpacks\n") if @badpacks;
    } else {
      @packids = findpackages($projid, $proj);
    }
    die("no packages defined\n") unless @packids;
  }
  die("illegal wipe parameter\n") if $cgi->{'wipe'} && $cgi->{'cmd'} ne 'wipe';
  
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $res;
  my @args;
  push @args, map {"prpa=$_"} @prpas;
  push @args, map {"package=$_"} @packids;
  push @args, map {"code=$_"} @{$cgi->{'code'} || []};
  push @args, map {"wipe=$_"} @{$cgi->{'wipe'} || []};
  push @args, "cmd=$cgi->{'cmd'}";
  my $param = {
    'uri' => "$reposerver/_command",
    'request' => 'POST',
  };
  $res = BSWatcher::rpc($param, undef, @args);
  return $res;
}

sub checkprojrepoarch {
  my ($projid, $repoid, $arch, $remoteok) = @_;
  my $proj = readproj($projid, 1);
  $proj = remoteprojid($projid) if $remoteok && (!$proj || $proj->{'remoteurl'});
  die("404 project '$projid' does not exist\n") if !$proj;
  die("404 project '$projid' is remote\n") if $proj->{'remoteurl'} && !$remoteok;
  return $proj if $proj->{'remoteurl'};
  return $proj unless defined $repoid;
  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];
  die("404 project '$projid' has no repository '$repoid'\n") unless $repo;
  return $proj unless defined $arch;
  die("404 repository '$projid/$repoid' has no architecture '$arch'\n") unless grep {$_ eq $arch} @{$repo->{'arch'} || []};
  return $proj;
}

sub getbuilddepinfo {
  my ($cgi, $projid, $repoid, $arch) = @_;

  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my @args;
  push @args, map {"package=$_"} @{$cgi->{'package'} || []};
  push @args, "view=$cgi->{'view'}" if $cgi->{'view'};
  my $res = BSWatcher::rpc("$reposerver/build/$projid/$repoid/$arch/_builddepinfo", $BSXML::builddepinfo, @args);
  return ($res, $BSXML::builddepinfo);
}

sub getjobhistory {
  my ($cgi, $projid, $repoid, $arch) = @_;

  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my @args;
  push @args, "limit=$cgi->{'limit'}" if $cgi->{'limit'};
  push @args, map {"package=$_"} @{$cgi->{'package'} || []};
  push @args, map {"code=$_"} @{$cgi->{'code'} || []};
  my $res = BSWatcher::rpc("$reposerver/build/$projid/$repoid/$arch/_jobhistory", $BSXML::jobhistlist, @args);
  return ($res, $BSXML::jobhistlist);
}

sub getpackagelist_build {
  my ($cgi, $projid, $repoid, $arch) = @_;
  if ($cgi->{'view'}) {
    die("unknown view '$cgi->{'view'}'\n") unless $cgi->{'view'} eq 'binaryversions' || $cgi->{'view'} eq 'binaryversionscode';
    my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);
    my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
    my @args = ("view=$cgi->{'view'}");
    push @args, map {"package=$_"} @{$cgi->{'package'} || []};
    my $param = {
      'uri' => "$reposerver/build/$projid/$repoid/$arch",
      'ignorestatus' => 1,
      'receiver' => \&BSServer::reply_receiver,
    };
    if ($proj->{'remoteurl'}) {
      if (!$BSStdServer::isajax) {
	BSHandoff::handoff($ajaxsocket, "/build/$projid/$repoid/$arch", undef, @args);
	exit(0);
      }
      $param->{'uri'} = "$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch";
      $param->{'proxy'} = $proxy;
    }
    BSWatcher::rpc($param, undef, @args);
    return undef;
  }
  return getpackagelist({ %$cgi, 'expand' => 1, 'noorigins' => 1 }, $projid, $repoid, $arch);
}

sub getbinarylist {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;

  my $view = $cgi->{'view'};
  my $nosource = $cgi->{'nosource'};
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my @args;
  push @args, "view=$view" if $view;
  push @args, "nosource=1" if $nosource;
  push @args, "withmd5=1" if $cgi->{'withmd5'};
  push @args, map {"binary=$_"} @{$cgi->{'binary'} || []};
  if ($view && ($view eq 'cache' || $view eq 'cpio' || $view eq 'solv' || $view eq 'solvstate')) {
    # do not check arch in interconnect mode
    my $proj = checkprojrepoarch($projid, $repoid, undef, 1);
    if (!$BSStdServer::isajax) {
      if ($proj->{'remoteurl'} && $view eq 'cpio' && $packid eq '_repository' && !$nosource && @{$cgi->{'binary'} || []}) {
	# hand over to worker_getbinaries to get the answer cached
	@args = ();
	push @args, "project=$projid";
	push @args, "repository=$repoid";
	push @args, "arch=$arch";
	push @args, "binaries=".join(',', @{$cgi->{'binary'} || []});
	BSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);
	exit(0);
      }
      BSHandoff::handoff($ajaxsocket, "/build/$projid/$repoid/$arch/$packid", undef, @args);
      exit(0);
    }
    my $param = {
      'uri' => "$reposerver/build/$projid/$repoid/$arch/$packid",
      'ignorestatus' => 1,
      'receiver' => \&BSServer::reply_receiver,
    };
    if ($proj->{'remoteurl'}) {
      $param->{'uri'} = "$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch/$packid";
      $param->{'proxy'} = $proxy;
    }
    BSWatcher::rpc($param, undef, @args);
    return undef;
  }
  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/$packid",
  };
  if ($proj->{'remoteurl'}) {
    $param->{'uri'} = "$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch/$packid";
    $param->{'proxy'} = $proxy;
  }
  if ($view && $view eq 'binaryversions') {
    push @args, 'nometa=1' if $cgi->{'nometa'};
    my $bvl = BSWatcher::rpc($param, $BSXML::binaryversionlist, @args);
    return ($bvl, $BSXML::binaryversionlist);
  }
  if ($view && $view eq 'cpioheaders') {
     $param->{'ignorestatus'} = 1;
     $param->{'receiver'} = \&BSServer::reply_receiver;
     BSWatcher::rpc($param, undef, @args);
     return undef;
  }
  my $bl = BSWatcher::rpc($param, $BSXML::binarylist, @args);
  return ($bl, $BSXML::binarylist);
}

sub getbinary {
  my ($cgi, $projid, $repoid, $arch, $packid, $filename) = @_;
  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);
  my $view = $cgi->{'view'} || '';
  if ($proj->{'remoteurl'} && $packid eq '_repository' && !$view) {
    # hack: reroute to /getbinaries so that our local cache is used
    die("need the raw package name as filename for remote repository access\n") if $filename =~ /\.(?:$binsufsre)$/;
    my @args;
    push @args, "project=$projid";
    push @args, "repository=$repoid";
    push @args, "arch=$arch";
    push @args, "binaries=$filename";
    push @args, "raw=1";
    BSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);
    exit(0);
  }
  if ($view eq 'publishedpath') {
    die("publishedpath does not work for _repository\n") if $packid eq '_repository';
    return published_path($cgi, $projid, $repoid);
  }
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my @args;
  push @args, "view=$view" if $view;
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/$packid/$filename",
    'ignorestatus' => 1,
    'receiver' => \&BSServer::reply_receiver,
  };
  if ($view && $view eq 'fileinfo_ext') {
    my $partition = projid2partition($projid);
    my $projpack = (getprojpack({'nopackages' => 1, 'withrepos' => 1, 'expandedrepos' => 1, 'withremotemap' => 1, 'withconfig' => 1, 'partition' => $partition}, [ $projid ], [ $repoid ], undef, $arch))[0];
    if ($projpack) {
      if ($projpack->{'project'} && $projpack->{'project'}->[0]->{'name'} eq $projid) {
        my $config = (getbuildconfig({}, $projid, $repoid))[0];
	$projpack->{'project'}->[0]->{'config'} = $config if $config;
      }
      $param->{'request'} = 'POST';
      $param->{'data'} = BSUtil::toxml($projpack, $BSXML::projpack);
      $param->{'headers'} = [ 'Content-Type: application/octet-stream' ];
    }
  }
  if ($proj->{'remoteurl'}) {
    $param->{'uri'} = "$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch/$packid/$filename";
    $param->{'proxy'} = $proxy;
  }
  BSWatcher::rpc($param, undef, @args);
  return undef;
}

sub putbinary {
  my ($cgi, $projid, $repoid, $arch, $filename) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my @args;
  push @args, 'ignoreolder=1' if $cgi->{'ignoreolder'};
  push @args, 'wipe=1' if $cgi->{'wipe'};
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/_repository/$filename",
    'request' => 'PUT',
    'data' => \&BSServer::forward_sender,
    'chunked' => 1,
  };
  # XXX add return type checking
  return BSWatcher::rpc($param, undef, @args);
}

sub delbinary {
  my ($cgi, $projid, $repoid, $arch, $filename) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/_repository/$filename",
    'request' => 'DELETE',
  };
  return BSWatcher::rpc($param, undef);
}

sub copybuild {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  die("illegal package '$packid'\n") if $packid =~ /^_/ && !($packid =~ /^_product:/);
  checkprojrepoarch($projid, $repoid, $arch);
  my $oprojid = defined($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;
  my $opackid = defined($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;
  my $orepoid = defined($cgi->{'orepository'}) ? $cgi->{'orepository'} : $repoid;
  die("nothing to do\n") if "$oprojid/$opackid/$orepoid" eq "$projid/$packid/$repoid";
  checkprojrepoarch($oprojid, $orepoid, $arch);
  # make sure the packages exist. not cheap, but does everything we need
  getrev($projid, $packid);
  getrev($oprojid, $opackid);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $oreposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;
  if ($reposerver ne $oreposerver) {
    die("cannot copy binaries between different reposiory servers yet\n");
  }
  my @args;
  push @args, "cmd=copy";
  push @args, "oproject=$oprojid";
  push @args, "opackage=$opackid";
  push @args, "orepository=$orepoid";
  push @args, "setupdateinfoid=$cgi->{'setupdateinfoid'}" if $cgi->{'setupdateinfoid'};
  push @args, "setrelease=$cgi->{'setrelease'}" if $cgi->{'setrelease'};
  push @args, 'resign=1' if $cgi->{'resign'};
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/$packid",
    'request' => 'POST',
  };
  # XXX add return type checking
  return BSWatcher::rpc($param, undef, @args);
}

sub uploadbuild {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  die("illegal package '$packid'\n") if $packid =~ /^_/ && !($packid =~ /^_product:/);
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/$packid",
    'request' => 'POST',
    'data' => \&BSServer::forward_sender,
    'chunked' => 1,
  };
  # XXX add return type checking
  return BSWatcher::rpc($param, undef);
}


sub getlogfile {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);

  if (!$cgi->{'start'}) {
    # check if the package is broken
    my $rev = getrev($projid, $packid, 'build');
    eval {
      lsrev_expanded($rev);
    };
    if ($@) {
      my $error = $@;
      if ($rev->{'srcmd5'}) {
        my $files = lsrev($rev);
	if ($files->{'_serviceerror'}) {
	  $error = repreadstr($rev, '_serviceerror', $files->{'_serviceerror'});
	} elsif ($files->{'_linkerror'}) {
	  $error = repreadstr($rev, '_linkerror', $files->{'_linkerror'});
	}
      }
      if ($cgi->{'view'} && $cgi->{'view'} eq 'entry') {
        my $entry = {'name' => '_log', 'size' => length($error)};
        return ({'entry' => [ $entry ]}, $BSXML::dir);
      }
      return $error;
    }
  }

  my @args;
  push @args, 'last' if $cgi->{'last'};
  push @args, 'nostream' if $cgi->{'nostream'};
  push @args, "start=$cgi->{'start'}" if defined $cgi->{'start'};
  push @args, "end=$cgi->{'end'}" if defined $cgi->{'end'};
  push @args, "view=$cgi->{'view'}" if $cgi->{'view'};
  if (!$BSStdServer::isajax && !$cgi->{'view'}) {
    my $url = "/build/$projid/$repoid/$arch/$packid/_log";
    BSHandoff::handoff($ajaxsocket, $url, undef, @args);
    exit(0);
  }
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/$packid/_log",
    'ignorestatus' => 1,
    'receiver' => \&BSServer::reply_receiver,
    'joinable' => 1,
  };
  BSWatcher::rpc($param, undef, @args);
  return undef; # always streams result
}

sub getjobstatus {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $jobstatus = BSWatcher::rpc("$reposerver/build/$projid/$repoid/$arch/$packid/_jobstatus", $BSXML::jobstatus);
  return ($jobstatus, $BSXML::jobstatus);
}

sub getbuildhistory {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my @args;
  push @args, "limit=$cgi->{'limit'}" if $cgi->{'limit'};
  my $buildhist = BSWatcher::rpc("$reposerver/build/$projid/$repoid/$arch/$packid/_history", $BSXML::buildhist, @args);
  return ($buildhist, $BSXML::buildhist);
}

sub getbuildinfo {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  $arch = $BSConfig::localarch if $arch eq 'local' && defined($BSConfig::localarch);
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my @args;
  push @args, 'internal=1' if $cgi->{'internal'};
  push @args, 'debug=1' if $cgi->{'debug'};
  push @args, map {"add=$_"} @{$cgi->{'add'} || []};
  my $buildinfo = BSWatcher::rpc("$reposerver/build/$projid/$repoid/$arch/$packid/_buildinfo", $BSXML::buildinfo, @args);
  return ($buildinfo, $BSXML::buildinfo);
}

sub getbuildinfo_post {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  $arch = $BSConfig::localarch if $arch eq 'local' && defined($BSConfig::localarch);
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my @args;
  push @args, 'debug=1' if $cgi->{'debug'};
  push @args, map {"add=$_"} @{$cgi->{'add'} || []};
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/$packid/_buildinfo",
    'request' => 'POST',
    'data' => \&BSServer::forward_sender,
    'chunked' => 1,
  };
  my $buildinfo = BSWatcher::rpc($param, $BSXML::buildinfo, @args);
  return ($buildinfo, $BSXML::buildinfo);
}

sub getbuildreason {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $reason = BSWatcher::rpc("$reposerver/build/$projid/$repoid/$arch/$packid/_reason", $BSXML::buildreason);
  return ($reason, $BSXML::buildreason);
}

sub getbuildstatus {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $status = BSWatcher::rpc("$reposerver/build/$projid/$repoid/$arch/$packid/_status", $BSXML::buildstatus);
  return ($status, $BSXML::buildstatus);
}

sub getworkerstatus {
  my ($cgi) = @_;
  # compat
  if ($cgi->{'scheduleronly'} && !$cgi->{'daemonsonly'}) {
    $cgi->{'daemonsonly'} = delete $cgi->{'scheduleronly'};
  }
  my @args;
  push @args, 'daemonsonly' if $cgi->{'daemonsonly'};
  push @args, map {"arch=$_"} @{$cgi->{'arch'} || []};

  if (!$BSConfig::partitioning || !$BSConfig::partitionservers) {
    my $reposerver = $BSConfig::reposerver;
    my $ws = BSWatcher::rpc("$reposerver/workerstatus", $BSXML::workerstatus, @args);
    delete $_->{'uri'} for @{$ws->{'idle'} || []};
    delete $_->{'uri'} for @{$ws->{'building'} || []};
    return ($ws, $BSXML::workerstatus);
  }

  # cummulated worker status
  my $cws;
  if (!$cgi->{'daemonsonly'}) {
    $cws->{'clients'} = 0;
    $cws->{'building'} = [];
    $cws->{'waiting'} = [];
    $cws->{'blocked'} = [];
    $cws->{'buildavg'} = [];
    $cws->{'idle'} = [];
  }
  $cws->{'partition'} = [];

  my %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);
  for my $reposerver (sort keys %reposervers) {
    my $ws = BSWatcher::rpc("$reposerver/workerstatus", $BSXML::workerstatus, @args);

    push @{$cws->{'partition'}}, @{$ws->{'partition'}};
    next if $cgi->{'daemonsonly'};

    delete $_->{'uri'} for @{$ws->{'idle'} || []};
    delete $_->{'uri'} for @{$ws->{'building'} || []};
    push @{$cws->{'idle'}}, @{$ws->{'idle'} || []};
    push @{$cws->{'building'}}, @{$ws->{'building'} || []};
    for my $b (@{$ws->{'waiting'} || []}) {
      my $ob = (grep {$_->{'arch'} eq $b->{'arch'}} @{$cws->{'waiting'} || []})[0];
      if (!$ob) {
        $ob = {'arch' => $b->{'arch'}, 'jobs' => 0};
        push @{$cws->{'waiting'}}, $ob;
      }
      $ob->{'jobs'} += $b->{'jobs'};
    }
    for my $b (@{$ws->{'blocked'} || []}) {
      my $ob = (grep {$_->{'arch'} eq $b->{'arch'}} @{$cws->{'blocked'} || []})[0];
      if (!$ob) {
        $ob = {'arch' => $b->{'arch'}, 'jobs' => 0};
        push @{$cws->{'blocked'}}, $ob;
      }
      $ob->{'jobs'} += $b->{'jobs'};
    }
    for my $b (@{$ws->{'buildavg'} || []}) {
      my $ob = (grep {$_->{'arch'} eq $b->{'arch'}} @{$cws->{'buildavg'} || []})[0];
      if (!$ob) {
        $ob = {'arch' => $b->{'arch'}, 'buildavg' => 0, 'count' => 0};
        push @{$cws->{'buildavg'}}, $ob;
      }
      $ob->{'buildavg'} += $b->{'buildavg'};
      $ob->{'count'} += 1;
    }
    $cws->{'clients'} += $ws->{'clients'} if $ws->{'clients'};
  }
  for my $b (@{$cws->{'buildavg'} || []}) {
    $b->{'buildavg'} /= delete $b->{'count'};
  }

  # sort
  if (!$cgi->{'daemonsonly'}) {
    $cws->{'idle'} = [ sort {$a->{'workerid'} cmp $b->{'workerid'} || $a->{'uri'} cmp $b->{'uri'} || $a cmp $b} @{$cws->{'idle'}} ];
    $cws->{'building'} = [ sort {$a->{'workerid'} cmp $b->{'workerid'} || $a->{'uri'} cmp $b->{'uri'} || $a cmp $b} @{$cws->{'building'}} ];
    $cws->{'waiting'} = [ sort {$a->{'arch'} cmp $b->{'arch'} || $a cmp $b}  @{$cws->{'waiting'}} ];
    $cws->{'blocked'} = [ sort {$a->{'arch'} cmp $b->{'arch'} || $a cmp $b}  @{$cws->{'blocked'}} ];
    $cws->{'buildavg'} = [ sort {$a->{'arch'} cmp $b->{'arch'} || $a cmp $b}  @{$cws->{'buildavg'}} ];
  }
  
  return ($cws, $BSXML::workerstatus);
}

sub getajaxstatus {
  my ($cgi) = @_;
  if (!$BSStdServer::isajax) {
    BSHandoff::handoff($ajaxsocket, '/ajaxstatus');
    exit(0);
  }
  my $r = BSWatcher::getstatus();
  return ($r, $BSXML::ajaxstatus);
}

sub search_proj {
  my ($cgi, $match, $id) = @_;
  $match =~ s/^\[(.*)\]$/$1/s;
  my $data = [];
  for my $projid (findprojects()) {
    my $proj = readproj($projid);
    push @$data, $proj;
  }
  $data = BSXPath::match($data, $match);
  if ($id) {
    for (@{$data || []}) {
      $_ = {'name' => $_->{'name'}};
    }
  }
  my $res = {'project' => $data};
  return ($res, $BSXML::collection);
}

sub pkgsearch_fetch {
  my ($db, $k) = @_;
  my ($projid, $packid) = split('/', $k, 2);
  my $pack = readpack($projid, $packid, 1) || {'name' => $packid};
  $pack->{'project'} = $projid;
  #my @linkinfo = BSDBIndex::getvalues($db, 'linkinfo', $k);
  #$pack->{'linkinfo'} = $linkinfo[0] if @linkinfo;
  return $pack;
}

sub pkgsearch_indexfunc {
  my ($db, $path, $value, $lkeys) = @_;
  if (!defined($path)) {
    return @{$db->{'_allkeys'}} if $db->{'_allkeys'};
    my @projids = findprojects();
    my @r;
    for my $projid (@projids) {
      push @r, map {"$projid/$_"} findpackages($projid, {}, 1);
    }
    $db->{'_allkeys'} = \@r;
    return @r;
  } elsif (!defined($value)) {
    return BSDBIndex::getkeys($db, "$db->{'index'}$path") if $path =~ /^linkinfo\//;
    return findprojects() if $path eq 'project';
    if ($path eq 'name') {
      $lkeys = [ pkgsearch_indexfunc($db) ] unless $lkeys;
      my %v = map {$_ => 1} grep {s/^.*\///} map {$_} @$lkeys;
      return sort keys %v;
    }
  } else {
    return BSDBIndex::getvalues($db, "$db->{'index'}$path", $value) if $path =~ /^linkinfo\//;
    return map {"$value/$_"} findpackages($value, {}, 1) if $path eq 'project';
    if ($path eq 'name') {
      $lkeys = [ pkgsearch_indexfunc($db) ] unless $lkeys;
      return grep {/\Q$value\E$/} @$lkeys;
    }
  }
  return ();
}

sub search_pack {
  my ($cgi, $match, $id) = @_;
  $match =~ s/^\[(.*)\]$/$1/s;
  # really ugly hack to speed up needed api call
  if ($match =~ /^\@project='(.+)' and starts-with\(\@name,'(.+)'\)$/) {
    my $projid = $1;
    my $startswith = $2;
    $projid =~ s/''/'/g;
    $startswith =~ s/''/'/g;
    my @packages = findpackages($projid, {});
    my $data = [];
    for my $packid (grep {/^\Q$startswith\E/} @packages) {
      my ($pack, undef) = getpackage($cgi, $projid, $packid);
      $pack->{'project'} = $projid;
      push @$data, $pack;
    }
    my $res = {'package' => $data};
    return ($res, $BSXML::collection);
  }
  my $db = BSDB::opendb($sourcedb, '');
  $db->{'indexfunc'} = {
    'project' => \&pkgsearch_indexfunc,
    'name' => \&pkgsearch_indexfunc,
    'linkinfo/project' => \&pkgsearch_indexfunc,
    'linkinfo/package' => \&pkgsearch_indexfunc,
    'linkinfo/rev' => \&pkgsearch_indexfunc,
  };
  $db->{'noindexatall'} = 1;
  $db->{'fetch'} = \&pkgsearch_fetch;
  my $data = BSXPathKeys::node($db, '');
  if ($id) {
    $data = $data->keymatch($match);
    for (@$data) {
      my @p = split('/', $_, 2);
      $_ = {'name' => $p[1], 'project' => $p[0]};
    }
  } else {
    $data = BSXPath::match($data, $match);
    delete $_->{'linkinfo'} for @$data;
  }
  my $res = {'package' => $data};
  return ($res, $BSXML::collection);
}

sub search_proj_id {
  return search_proj(@_, 1);
}

sub search_pack_id {
  return search_pack(@_, 1);
}

#############################################################################

sub search_published_updatedb {
  my ($cgi) = @_;
  die("unknown command '$cgi->{'cmd'}'\n") unless $cgi->{'cmd'} eq 'updatedb';
  my $data = BSServer::read_data();
  $data = Storable::thaw($data);
  die("no data\n") unless $data && @$data;
  my $patterndb;
  my $binarydb;
  my $repoinfodb;
  mkdir_p($extrepodb) unless -d $extrepodb;
  while (@$data) {
    my ($w, $k, $v) = splice(@$data, 0, 3);
    if ($w eq 'binary') {
      $binarydb = BSDB::opendb($extrepodb, 'binary') unless $binarydb;
      $binarydb->updateindex_rel($k || [], $v || []);
    } elsif ($w eq 'pattern') {
      $patterndb = BSDB::opendb($extrepodb, 'pattern') unless $patterndb;
      $patterndb->store($k, $v);
    } elsif ($w eq 'repoinfo') {
      if (!$repoinfodb) {
        $repoinfodb = BSDB::opendb($extrepodb, 'repoinfo');
        $repoinfodb->{'noindexatall'} = 1;
      }
      $repoinfodb->store($k, $v);
    } else {
      die("bad data type: '$w'\n");
    }
  }
  return $BSStdServer::return_ok;
}

#sub search_published_id {
#  my ($cgi, $what, $match) = @_;
#  my $res;
#  for my $rrserver ($BSConfig::reposerver) {
#    $res = BSRPC::rpc("$rrserver/search/published/$what/id", $BSXML::collection, "match=$match");
#    last if $res;
#  }
#  return ($res, $BSXML::collection);
#}
#
#sub search_published_binary_id {
#  return search_published_id($_[0], 'binary', $_[1]);
#}
#
#sub search_published_pattern_id {
#  return search_published_id($_[0], 'pattern', $_[1]);
#}

my %prp_to_repoinfo;

sub prp_to_repoinfo {
  my ($prp) = @_;

  my $repoinfo = $prp_to_repoinfo{$prp};
  if (!$repoinfo) {
    my $repoinfodb = BSDB::opendb($extrepodb, 'repoinfo');
    $repoinfo = $repoinfodb->fetch($prp);
    if ($repoinfo) {
      for (@{$repoinfo->{'prpsearchpath'} || []}) {
	next if ref($_);	# legacy
	my ($p, $r) = split('/', $_, 2);
	$_ = {'project' => $p, 'repository' => $r};
      }
    } else {
      $repoinfo = {'binaryorigins' => {}};
    }
    $prp_to_repoinfo{$prp} = $repoinfo;
  }
  return $repoinfo;
}

sub binary_key_to_data {
  my ($db, $key) = @_; 
  my @p = split('/', $key);
  my $binary = pop(@p);
  my $name = $binary;
  my $versrel = '';
  if ($name =~ s/-([^-]+-[^-]+)\.[^\.]+\.rpm$//) {
    $versrel = $1;
  } elsif ($name =~ s/_([^_]+)_[^_]+\.deb$//) {
    $versrel = $1;
  } elsif ($name =~ s/-([^-]+-[^-]+)-[^-]+\.pkg\.tar\..z$//) {
    $versrel = $1;
  }
  my ($version, $release) = ($versrel, undef);
  ($version, $release) = ($1, $2) if $version =~ /^(.*)-(.*?)$/;
  my $arch = pop(@p);
  while (@p > 1 && $p[0] =~ /:$/) {
    splice(@p, 0, 2, "$p[0]$p[1]");
  }
  my $project = shift(@p);
  while (@p > 1 && $p[0] =~ /:$/) {
    splice(@p, 0, 2, "$p[0]$p[1]");
  }
  my $repository = shift(@p);
  my $prp = "$project/$repository";
  my $repoinfo = $prp_to_repoinfo{$prp} || prp_to_repoinfo($prp);
  my $type;
  $type = 'rpm' if $binary =~ /\.rpm$/;
  $type = 'deb' if $binary =~ /\.deb$/;
  $type = 'arch' if $binary =~ /\.pkg\.tar\..z$/;
  my $res = {
    'name' => $name,
    'versrel' => $versrel,
    'version' => $version,
    'arch' => $arch,
    'type' => $type,
    'project' => $project,
    'repository' => $repository,
    'filename' => $binary,
    'filepath' => $key,
  };
  $res->{'release'} = $release if defined $release;
  $res->{'path'} = $repoinfo->{'prpsearchpath'} if $repoinfo->{'prpsearchpath'};
  my $location = join('/', @p, $arch, $binary);
  $res->{'package'} = $repoinfo->{'binaryorigins'}->{$location} if defined $repoinfo->{'binaryorigins'}->{$location};
  if ($repoinfo->{'base'}) {
    $res->{'baseproject'} = $repoinfo->{'base'}->{'project'};
  } elsif ($res->{'path'}) {
    $res->{'baseproject'} = $res->{'path'}->[-1]->{'project'};
  }
  return $res;
}

sub binary_key_to_project {
  my ($db, $key) = @_;  
  my @p = split('/', $key);
  while (@p > 1 && $p[0] =~ /:$/) {
    splice(@p, 0, 2, "$p[0]$p[1]");
  }
  return shift @p;
}

sub pattern_key_to_data {
  my ($db, $key) = @_; 
  my @p = split('/', $key);
  my $filename = pop(@p);
  while (@p > 1 && $p[0] =~ /:$/) {
    splice(@p, 0, 2, "$p[0]$p[1]");
  }
  my $project = shift(@p);
  while (@p > 1 && $p[0] =~ /:$/) {
    splice(@p, 0, 2, "$p[0]$p[1]");
  }
  my $repository = shift(@p);
  my @v = BSDBIndex::getvalues($db, $db->{'table'}, $key);
  return {} unless @v;
  my $res = $v[0];
  $res->{'baseproject'} = $res->{'path'}->[-1]->{'project'} if $res->{'path'};
  $res->{'project'} = $project;
  $res->{'repository'} = $repository;
  $res->{'filename'} = $filename;
  $res->{'filepath'} = $key;
  return $res;
}

sub published_projectindexfunc {
  my ($db, $path, $value) = @_;
  return findprojects() unless defined $value;
  my $proj = readproj($value);
  return () unless $proj;
  my @repoids = map {$_->{'name'}} @{$proj->{'repository'} || []};
  my %bins;
  for my $repoid (@repoids) {
    my $prp = "$value/$repoid";
    my $prp_ext = $prp;
    $prp_ext =~ s/:/:\//g;
    my $repoinfo = $prp_to_repoinfo{$prp} || prp_to_repoinfo($prp);
    for (keys %{$repoinfo->{'binaryorigins'} || {}}) {
      next unless /\//;
      # keep in sync with updatebinaryindex in bs_publish
      next unless /\.(?:rpm|deb|pkg\.tar\..z)$/;
      $bins{"$prp_ext/$_"} = 1;
    }
  }
  return sort keys %bins;
}

sub search_published_binary_id {
  my ($cgi, $match) = @_;
  my $binarydb = BSDB::opendb($extrepodb, 'binary');
  $binarydb->{'allkeyspath'} = 'name';
  $binarydb->{'noindex'} = {'version' => 1, 'release' => 1, 'versrel' => 1, 'arch' => 1, 'project' => 1, 'repository' => 1, 'package' => 1, 'type' => 1, 'path/project' => 1, 'path/repository' => 1, 'baseproject' => 1};
  $binarydb->{'indexfunc'} = {'project' => \&published_projectindexfunc };
  $binarydb->{'fetch'} = \&binary_key_to_data;
  $binarydb->{'fetch_project'} = \&binary_key_to_project;
  $binarydb->{'cheapfetch'} = 1;
  my $limit = defined($cgi->{'limit'}) ? $cgi->{'limit'} : 1000;
  my $rootnode = BSXPathKeys::node($binarydb, '', $limit && $limit < 10 ? 1000 : $limit * 100);
  my $data = BSXPath::match($rootnode, $match) || [];
  # epoch?
  @$data = sort {Build::Rpm::verscmp($b->{'version'}, $a->{'version'}) || $a->{'name'} cmp $b->{'name'} || $a->{'arch'} cmp $b->{'arch'}} @$data;
  delete $_->{'versrel'} for @$data;
  my $res = {};
  $res->{'matches'} = @$data;
  $res->{'limited'} = 'true' if $limit && @$data > $limit;
  splice(@$data, $limit) if $limit && @$data > $limit;
  delete $_->{'path'} for @$data;
  $res->{'binary'} = $data;
  return ($res, $BSXML::collection);
}

sub search_published_pattern_id {
  my ($cgi, $match) = @_;
  my $patterndb = BSDB::opendb($extrepodb, 'pattern');
  $patterndb->{'noindex'} = {'project' => 1, 'repository' => 1};
  $patterndb->{'fetch'} = \&pattern_key_to_data;
  my $limit = defined($cgi->{'limit'}) ? $cgi->{'limit'} : 1000;
  my $rootnode = BSXPathKeys::node($patterndb, '', $limit && $limit < 10 ? 1000 : $limit * 100);
  my $data = BSXPath::match($rootnode, $match) || [];
  my $res = {};
  $res->{'matches'} = @$data;
  $res->{'limited'} = 'true' if $limit && @$data > $limit;
  splice(@$data, $limit) if $limit && @$data > $limit;
  for (@$data) {
    delete $_->{'path'};
    delete $_->{'description'};
    delete $_->{'summary'};
  }
  $res->{'pattern'} = $data;
  return ($res, $BSXML::collection);
}

#############################################################################

sub search {
  my ($cgi, $in, $match) = @_;
  # gather all data
  my $data = [];
  if ($in eq 'projects') {
    for my $projid (findprojects()) {
      my $proj = readproj($projid);
      push @$data, $proj;
    }
  } elsif ($in eq 'packages') {
    for my $projid (findprojects()) {
      my @packages = findpackages($projid, {});
      for my $packid (@packages) {
        my ($pack, undef) = getpackage($cgi, $projid, $packid);
	$pack->{'project'} = $projid;
        push @$data, $pack;
      }
    }
  } else {
    die("'in' parameter needs to be either 'projects' or 'packages'\n");
  }
  my $res;
  if ($cgi->{'values'}) {
    $data = BSXPath::valuematch($data, $match);
    $res = {'value' => $data};
  } else {
    $data = BSXPath::match($data, $match);
    if (exists $cgi->{'return'}) {
      $data = BSXPath::valuematch($data, $cgi->{'return'});
      $res = {'value' => $data};
    } elsif ($in eq 'projects') {
      $res = {'project' => $data};
    } else {
      $res = {'package' => $data};
    }
  }
  return ($res, $BSXML::collection);
}

sub postrepo {
  my ($cgi, $projid, $repoid, $arch) = @_;
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/_repository",
    'request' => 'POST',
  };
  my $res = BSWatcher::rpc($param, $BSXML::collection, "match=$cgi->{'match'}");
  return ($res, $BSXML::collection);
}

sub service {
  my ($cgi, $service) = @_;
  die("404 no such service '$service'\n") unless $BSConfig::serviceserver;
  return BSWatcher::rpc("$BSConfig::serviceserver/service/$service", undef);
}

sub listservices {
  my ($cgi) = @_;
  return "<servicelist/>\n" unless $BSConfig::serviceserver;
  return BSWatcher::rpc("$BSConfig::serviceserver/service", undef);
}

sub published {
  my ($cgi, $projid, $repoid, $arch, $filename, $subfilename) = @_;
  my @args;
  my $projpack;
  die("unknown view '$cgi->{'view'}'\n") if $cgi->{'view'} && $cgi->{'view'} ne 'ymp' && $cgi->{'view'} ne 'fileinfo';
  if (defined($projid) && defined($repoid) && $cgi->{'view'} && $cgi->{'view'} eq 'ymp') {
    # attach projpack data so that the repo server does not need to
    # reconnect us
    $projpack = (getprojpack({'nopackages' => 1, 'withrepos' => 1, 'expandedrepos' => 1}, [ $projid ], [ $repoid ], undef, 'noarch'))[0];
    my $proj = $projpack->{'project'}->[0];
    die("no such project\n") unless $proj && $proj->{'name'} eq $projid;
    my $repo = $proj->{'repository'}->[0];
    die("no such repository\n") unless $repo && $repo->{'name'} eq $repoid;
    $projpack->{'project'} = [ $proj ];
    my @nprojids = grep {$_ ne $projid} map {$_->{'project'}} @{$repo->{'path'} || []};
    @nprojids = unify(@nprojids);
    for my $nprojid (@nprojids) {
      my $nproj = (getproject({}, $nprojid))[0];
      push @{$projpack->{'project'}}, {
	'name' => $nprojid,
	'title' => $nproj->{'title'} || '',
	'description' => $nproj->{'description'} || '',
      };
    }
  }
  push @args, "view=$cgi->{'view'}" if $cgi->{'view'};
  my $p = "/published";
  $p .= "/$projid" if defined $projid;
  $p .= "/$repoid" if defined $repoid;
  $p .= "/$arch" if defined $arch;
  $p .= "/$filename" if defined $filename;
  $p .= "/$subfilename" if defined $subfilename;
  if (defined($projid) || !$BSConfig::partitioning || !$BSConfig::partitionservers) {
    my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
    my $param = {
      'uri' => "$reposerver$p",
      'ignorestatus' => 1,
      'receiver' => \&BSServer::reply_receiver,
    };
    if ($projpack) {
      $param->{'request'} = 'POST';
      $param->{'data'} = BSUtil::toxml($projpack, $BSXML::projpack);
      $param->{'headers'} = [ 'Content-Type: application/octet-stream' ];
    }
    BSWatcher::rpc($param, undef, @args);
    return undef;
  }
  my %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);
  my %pubprojids;
  for my $reposerver (sort keys %reposervers) {
    my $res;
    eval {
      $res = BSWatcher::rpc("$reposerver/published", $BSXML::dir, @args);
    };
    warn($@) if $@;
    next unless $res;
    $pubprojids{$_->{'name'}} = 1 for @{$res->{'entry'} || []};
  }
  my @res = sort(keys %pubprojids);
  @res = map {{'name' => $_}} @res;
  return ({'entry' => \@res}, $BSXML::dir);
}

my $extrepodir = "$BSConfig::bsdir/repos";

sub map_to_extrep {
  my ($prp, $prp_ext) = @_;
  
  my $extrep = "$BSConfig::bsdir/repos/$prp_ext";
  return $extrep unless $BSConfig::publishredirect;
  if ($BSConfig::publishedredirect_use_regex || $BSConfig::publishedredirect_use_regex) {
    for my $key (sort {$b cmp $a} keys %{$BSConfig::publishredirect}) {
      if ($prp =~ /^$key/) {
        $extrep = $BSConfig::publishredirect->{$key};
        last;
      }    
    }    
  } elsif (exists($BSConfig::publishredirect->{$prp})) {
    $extrep = $BSConfig::publishredirect->{$prp};
  }
  $extrep = $extrep->($prp, $prp_ext) if $extrep && ref($extrep) eq 'CODE';
  return $extrep;
}

sub published_path {
  my ($cgi, $projid, $repoid) = @_;
  my $medium = $cgi->{'medium'};
  my $prp = "$projid/$repoid";
  my $prp_ext = $prp;
  my $ret = {'project' => $projid, 'repository' => $repoid};
  $ret->{'medium'} = $medium if $medium;
  $prp_ext =~ s/:/:\//g;
  my $extrep = map_to_extrep($prp, $prp_ext);
  $extrep = [ $extrep ] unless ref $extrep;
  my ($path, $url) = ($extrep->[1], $extrep->[2]);
  # update to get fresh version of repodownload
  BSConfiguration::update_from_configuration();
  if ($BSConfig::prp_ext_map && $BSConfig::prp_ext_map->{$prp}) {
    $url = $BSConfig::prp_ext_map->{$prp} unless defined $url;
  }
  if ($extrep->[0] =~ /^\Q$BSConfig::bsdir\E\/repos\/(.*)$/) {
    $path = $1 unless defined $path;
    if ($BSConfig::repodownload) {
      $url = "$BSConfig::repodownload/".BSRPC::urlencode($1) unless defined $url;
    }
  }
  if ($cgi->{'filename'}) {
    # called from getbinary
    my $bin = $cgi->{'filename'};
    my $p;
    if ($bin =~ /^.+-[^-]+-[^-]+\.([a-zA-Z][^\/\.\-]*)\.d?rpm$/) {
      $p = "$1/$bin";
    } elsif ($bin =~ /^.+_[^_]+_([^_\.]+)\.deb$/) {
      $p = "$1/$bin";
    } elsif ($bin =~ /\.exe$/) {
      $p = $bin;
    } elsif ($bin =~ /\.(?:pkg\.tar\.gz|pkg\.tar\.xz)$/) {
      $p = ($cgi->{'arch'} eq 'i586' ? 'i686' : $cgi->{'arch'})."/$bin";
    } elsif ($bin =~ /\.iso(?:\.report)$/) {
      $p = "iso/$bin";
    } elsif ($bin =~ /-Media\d+$/) {
      $medium = $bin;
    }
    if (defined $p) {
      $path .= "/$p" if defined $path;
      $url .= "/".BSRPC::urlencode($p) if defined $url;
    }
  }
  if ($medium && $medium =~ /\.iso$/) {
    $medium = "iso/$medium";
  } elsif ($medium) {
    my @path = expandsearchpath($projid, $repoid);
    my $c = concatconfigs($projid, $cgi->{'repository'}, undef, @path);
    my $bconf = Build::read_config('noarch', [ split("\n", $c) ]);
    my %repotype;
    for (@{$bconf->{'repotype'} || []}) {
      if (/^(.*?):(.*)$/) {
        $repotype{$1} = [ split(':', $2) ];
      } else {
        $repotype{$_} = [];
      }    
    }
    if ($repotype{'slepool'}) {
      my $name = $repotype{'slepool'}->[0] || 'product';
      if ($medium =~ /-Media1$/) {
	$medium = $name;
      } elsif ($medium =~ /-Media3$/) {
	$medium = "${name}_debug";
      } elsif ($medium =~ /-Media2$/) {
        my $repoinfo;
	eval {
	  $repoinfo = $prp_to_repoinfo{$prp};
	};
	my $binaryorigins = ($repoinfo || {})->{'binaryorigins'};
	$medium = $binaryorigins->{"${name}_source"} ? "${name}_source" : "${name}_debug";
      }
    } else {
      $medium = "repo/$medium";
    }
  }
  if ($medium) {
    $path .= "/$medium" if defined $path;
    $url .= "/".BSRPC::urlencode($medium) if defined $url;
  }
  $ret->{'path'} = $path if defined $path;
  $ret->{'url'} = $url if defined $url;
  return ($ret, $BSXML::publishedpath);
}
  

sub pkdecodetaglenoff {
  my ($pkg) = @_;
  my $tag = unpack('C', $pkg);
  die("not a gpg packet\n") unless $tag & 128;
  my $len;
  my $off = 1;
  if ($tag & 64) {
    # new packet format
    $tag &= 63; 
    $len = unpack('C', substr($pkg, 1));
    if ($len < 192) {
      $off = 2;
    } elsif ($len != 255) {
      $len = (($len - 192) << 8) + unpack('C', substr($pkg, 2)) + 192;
      $off = 3;
    } else {
      $len = unpack('N', substr($pkg, 2));
      $off = 5;
    }   
  } else {
    # old packet format
    if (($tag & 3) == 0) {
      $len = unpack('C', substr($pkg, 1));
      $off = 2;
    } elsif (($tag & 3) == 1) {
      $len = unpack('n', substr($pkg, 1));
      $off = 3;
    } elsif (($tag & 3) == 1) {
      $len = unpack('N', substr($pkg, 1));
      $off = 6;
    } else {
      die("can't deal with not specified packet length\n");
    }   
    $tag = ($tag & 60) >> 2;
  }
  return ($tag, $len, $off);
}

sub pk2expire {
  my ($pk) = @_;
  # oh my! hard work!
  $pk =~ s/.*\n\n//s;
  $pk =~ s/\n=.*/\n/s;
  $pk = MIME::Base64::decode($pk);
  return 0 unless $pk;
  my ($rex, $rct);
  eval {
    while ($pk ne '') {
      my ($tag, $len, $off) = pkdecodetaglenoff($pk);
      my $pack = substr($pk, $off, $len);
      $pk = substr($pk, $len + $off);
      next if $tag != 2;
      my $sver = unpack('C', substr($pack, 0, 1));
      next unless $sver == 4;
      my $stype = unpack('C', substr($pack, 1, 1));
      next unless $stype == 19; # positive certification of userid and pubkey
      my $plen = unpack('n', substr($pack, 4, 2));
      $pack = substr($pack, 6, $plen);
      my ($ct, $ex);
      while ($pack ne '') {
        $pack = pack('C', 0xc0).$pack;
        my ($stag, $slen, $soff) = pkdecodetaglenoff($pack);
        my $spack = substr($pack, $soff, $slen);
        $pack = substr($pack, $slen + $soff);
        $stag = unpack('C', substr($spack, 0, 1));
        $ct = unpack('N', substr($spack, 1, 4)) if $stag == 2;
        $ex = unpack('N', substr($spack, 1, 4)) if $stag == 9;
      }
      $rex = $ex if defined($ex) && (!defined($rex) || $rex > $ex);
      $rct = $ct if defined($ct) && (!defined($rct) || $rct > $ct);
    }
  };
  return 0 if $@;
  return defined($rct) && defined($rex) ? $rct + $rex : undef;
}

sub getsignkey {
  my ($cgi, $projid) = @_;

  while ($projid ne '') {
    my $sk = readstr("$projectsdir/$projid.pkg/_signkey", 1);
    if ($sk) {
      if ($cgi->{'withpubkey'}) {
        my $pk = readstr("$projectsdir/$projid.pkg/_pubkey", 1);
        if ($pk && $cgi->{'autoextend'}) {
	  my $expiredate = pk2expire($pk);
	  if ($expiredate && $expiredate < time() + 24 * 3600) {
	    extendkey({'comment' => 'auto-extend public key expiry date'}, $projid);
            $pk = readstr("$projectsdir/$projid.pkg/_pubkey", 1);
	  }
	}
        $sk .= "\n" unless $sk =~ /\n$/s;
        $sk .= $pk;
      }
      return ($sk, 'Content-Type: text/plain') if $sk;
    }
    $projid =~ s/[^:]*$//;
    $projid =~ s/:$//;
  }
  return ('', 'Content-Type: text/plain');
}

sub getsslcert {
  my ($cgi, $projid) = @_;

  my $origprojid = $projid;
  while ($projid ne '') {
    my $sk = readstr("$projectsdir/$projid.pkg/_signkey", 1);
    if (!$sk) {
      $projid =~ s/[^:]*$//;
      $projid =~ s/:$//;
      next;
    }
    my $pk = readstr("$projectsdir/$projid.pkg/_pubkey", 1);
    if ($pk && $cgi->{'autoextend'}) {
      my $expiredate = pk2expire($pk);
      if ($expiredate && $expiredate < time() + 24 * 3600) {
        extendkey({'comment' => 'auto-extend public key expiry date'}, $projid);
      }
    }
    my $rev = getrev_meta($projid, undef);
    my $files = lsrev($rev);
    my $cert;
    if (!$files->{'_sslcert'}) {
      # length(signkey) <= 2 means special handling, don't commit it
      if (length($sk) <= 2) {
        $cert = pubkey2sslcert($origprojid, "$projectsdir/$projid.pkg/_pubkey");
        return ($cert, 'Content-Type: text/plain');
      }
      $cert = pubkey2sslcert($projid);
      mkdir_p($uploaddir);
      writestr("$uploaddir/sslcert.$$", undef, $cert);
      addrev_meta({'comment' => 'automatic cert creation'}, $projid, undef, "$uploaddir/sslcert.$$", undef, '_sslcert');
    } else {
      $cert = repreadstr($rev, '_sslcert', $files->{'_sslcert'});
    }
    return ($cert, 'Content-Type: text/plain');
  }
  if ($BSConfig::sign_project && $BSConfig::sign) {
    # request default cert
    my $cert = '';
    local *F;
    open(F, '-|', $BSConfig::sign, '--project', $origprojid, '-C') || die("$BSConfig::sign: $!\n");
    1 while sysread(F, $cert, 4096, length($cert));
    close(F) || die("$BSConfig::sign: $?\n");
    return ($cert, 'Content-Type: text/plain');
  }
  return ('', 'Content-Type: text/plain');
}

####################################################################

# needed for migrations to 2.4
sub getlastidrequest {
  my $lastid = readstr("$requestsdir/.nextid", 1) - 1;
  
  return ("$lastid", 'Content-Type: text/plain');
}

# needed for migrations to 2.4
sub getrequest {
  my ($cgi, $id) = @_;
  local *F;
  my $rdir = $requestsdir;
  if (!open(F, '<', "$rdir/$id")) {
    $rdir = $oldrequestsdir;
    if (!open(F, '<', "$rdir/$id")) {
      die("404 no such request '$id'\n");
    }
  }
  my $reqxml = '';
  1 while sysread(F, $reqxml, 8192, length($reqxml));
  my @s = stat(F);
  close F;
  die unless @s;
  my $req = XMLin($BSXML::request, $reqxml);
  return ($req, $BSXML::request);
}

####################################################################

sub findremote {
  my ($projid) = @_;

  my $proj = readproj($projid, 1);
  if ($proj) {
    if (!$proj->{'remoteurl'}) {
      my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
      return ($reposerver, $projid, undef);
    }
    die("no remoteproject specified\n") unless $proj->{'remoteproject'};
    return ($proj->{'remoteurl'}, $proj->{'remoteproject'}, $proxy);
  }
  my $origprojid = $projid;
  my $rsuf = '';
  while ($projid =~ /^(.*)(:.*?)$/) {
    $projid = $1;
    $rsuf = "$2$rsuf";
    $proj = readproj($projid, 1);
    next unless $proj;
    die("404 project '$origprojid' does not exist\n") unless $proj->{'remoteurl'};
    if ($proj->{'remoteproject'}) {
      return ($proj->{'remoteurl'}, "$proj->{'remoteproject'}$rsuf", $proxy);
    }
    $rsuf =~ s/^://;
    return ($proj->{'remoteurl'}, $rsuf, $proxy);
  }
  die("404 project '$origprojid' does not exist\n");
}

sub worker_getbinaries {
  my ($cgi, $projid, $repoid, $arch) = @_;

  if (!$BSStdServer::isajax) {
    my @args;
    push @args, "project=$projid";
    push @args, "repository=$repoid";
    push @args, "arch=$arch";
    push @args, "binaries=$cgi->{'binaries'}";
    BSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);
    exit(0);
  }
  my @binaries = split(',', $cgi->{'binaries'});
  my ($remoteurl, $remoteprojid, $remoteproxy) = findremote($projid);

  my $jev = $BSServerEvents::gev;
  my $binarylist;
  $binarylist = $jev->{'binarylist'} if $BSStdServer::isajax;
  $binarylist ||= {};
  $jev->{'binarylist'} = $binarylist if $BSStdServer::isajax;

  # fill binarylist
  my @missing = grep {!exists $binarylist->{$_}} @binaries;
  while (@missing) {
    my $param = {
      'uri' => "$remoteurl/build/$remoteprojid/$repoid/$arch/_repository",
      'proxy' => $remoteproxy,
    };
    # chunk it
    my $binchunkl = 0;
    for (splice @missing) {
      $binchunkl += 10 + length($_);
      last if @missing && $binchunkl > 1900;
      push @missing, $_;
    }
    my $binarylistcpio = BSWatcher::rpc($param, $BSXML::binarylist, "view=names", map {"binary=$_"} @missing);
    return undef if $BSStdServer::isajax && !$binarylistcpio;
    for my $b (@{$binarylistcpio->{'binary'} || []}) {
      my $bin = $b->{'filename'};
      $bin =~ s/\.(?:$binsufsre)$//;
      $binarylist->{$bin} = $b;
    }
    # make sure that we don't loop forever if the server returns incomplete data
    for (@missing) {
      $binarylist->{$_} = {'filename' => $_, 'size' => 0} unless $binarylist->{$_};
    }
    @missing = grep {!exists $binarylist->{$_}} @binaries;
  }

  my @fetch;
  my @reply;
  local *LOCK;
  mkdir_p($remotecache);
  BSUtil::lockopen(\*LOCK, '>>', "$remotecache/lock");
  for my $bin (@binaries) {
    my $b = $binarylist->{$bin};
    if (!$b || !$b->{'size'} || !$b->{'mtime'}) {
      push @reply, {'name' => $bin, 'error' => 'not available'};
      next;
    }
    my $cachemd5 = Digest::MD5::md5_hex("$projid/$repoid/$arch/$bin");
    substr($cachemd5, 2, 0, '/');
    my @s = stat("$remotecache/$cachemd5");
    if (!@s || $s[9] != $b->{'mtime'} || $s[7] != $b->{'size'}) {
      push @fetch, $bin;
    } else {
      utime time(), $s[9], "$remotecache/$cachemd5";
      push @reply, {'name' => $b->{'filename'}, 'filename' => "$remotecache/$cachemd5"};
    }
  }
  my $slot = sprintf("%02x", (int(rand(256))));
  print "cleaning slot $slot\n";
  if (-d "$remotecache/$slot") {
    my $now = time();
    my $num = 0;
    for my $f (ls("$remotecache/$slot")) {
      my @s = stat("$remotecache/$slot/$f");
      next if $s[8] >= $now - 24*3600;
      unlink("$remotecache/$slot/$f");
      $num++;
    }
    print "removed $num unused files\n" if $num;
  }
  close(LOCK);

  if (@fetch) {
    my $serialmd5 = Digest::MD5::md5_hex("$projid/$repoid/$arch");

    # serialize this upload
    my $serial = BSWatcher::serialize("$remotecache/$serialmd5.lock");
    return undef unless $serial;

    print "fetch: @fetch\n";
    my %fetch = map {$_ => $binarylist->{$_}} @fetch;
    my $param = {
      'uri' => "$remoteurl/build/$remoteprojid/$repoid/$arch/_repository",
      'receiver' => \&BSHTTP::cpio_receiver,
      'tmpcpiofile' => "$remotecache/upload$serialmd5.cpio",
      'directory' => $remotecache,
      'map' => "upload$serialmd5:",
      'proxy' => $remoteproxy,
    };
    # work around api bug: only get 50 packages at a time
    @fetch = splice(@fetch, 0, 50) if @fetch > 50;
    my $cpio = BSWatcher::rpc($param, undef, "view=cpio", map {"binary=$_"} @fetch);
    return undef if $BSStdServer::isajax && !$cpio;
    for my $f (@{$cpio || []}) {
      my $bin = $f->{'name'};
      $bin =~ s/^upload.*?://;
      $bin =~ s/\.(?:$binsufsre)$//;
      if (!$fetch{$bin}) {
        unlink("$remotecache/$f->{'name'}");
	next;
      }
      $binarylist->{$bin}->{'size'} = $f->{'size'};
      $binarylist->{$bin}->{'mtime'} = $f->{'mtime'};
      my $cachemd5 = Digest::MD5::md5_hex("$projid/$repoid/$arch/$bin");
      substr($cachemd5, 2, 0, '/');
      mkdir_p("$remotecache/".substr($cachemd5, 0, 2));
      rename("$remotecache/$f->{'name'}", "$remotecache/$cachemd5");
      push @reply, {'name' => $fetch{$bin}->{'filename'}, 'filename' => "$remotecache/$cachemd5"};
      delete $fetch{$bin};
    }
    BSWatcher::serialize_end($serial);

    if (@{$cpio || []} >= 50) {
      # work around api bug: get rest
      delete $jev->{'binarylist'} if $BSStdServer::isajax;
      return worker_getbinaries($cgi, $projid, $repoid, $arch);
    }

    for (sort keys %fetch) {
      push @reply, {'name' => $_, 'error' => 'not available'};
    }
  }
  if ($cgi->{'raw'}) {
    die("can only transport one binary in raw mode\n") unless @reply == 1;
    my $f = $reply[0];
    die("$f->{'name'}: $f->{'error'}\n") if $f->{'error'};
    die("$f->{'name'}: not found\n") unless $f->{'filename'};
    BSWatcher::reply_file($f->{'filename'});
    return undef;
  }
  BSWatcher::reply_cpio(\@reply);
  return undef;
}

sub worker_getbinaryversions {
  my ($cgi, $projid, $repoid, $arch) = @_;

  if (0 && !$BSStdServer::isajax) {
    my @args;
    push @args, "project=$projid";
    push @args, "repository=$repoid";
    push @args, "arch=$arch";
    push @args, "binaries=$cgi->{'binaries'}";
    push @args, "nometa=1" if $cgi->{'nometa'};
    BSHandoff::handoff($ajaxsocket, '/getbinaryversions', undef, @args);
    exit(0);
  }
  my @binaries = split(',', $cgi->{'binaries'});
  my ($remoteurl, $remoteprojid, $remoteproxy) = findremote($projid);

  my $jev = $BSServerEvents::gev;
  my $binaryversions;
  $binaryversions = $jev->{'binaryversions'} if $BSStdServer::isajax;
  $binaryversions ||= {};
  $jev->{'binaryversions'} = $binaryversions if $BSStdServer::isajax;

  # fill binaryversions
  my @missing = grep {!exists $binaryversions->{$_}} @binaries;
  while (@missing) {
    # chunk it
    my $binchunkl = 0;
    for (splice @missing) {
      $binchunkl += 10 + length($_);
      last if @missing && $binchunkl > 1900;
      push @missing, $_;
    }
    my $param = {
      'uri' => "$remoteurl/build/$remoteprojid/$repoid/$arch/_repository",
      'proxy' => $remoteproxy,
    };
    my $bvl = BSWatcher::rpc($param, $BSXML::binaryversionlist, 'view=binaryversions', 'nometa=1', map {"binary=$_"} @missing);
    return undef if $BSStdServer::isajax && !$bvl;
    for (@{$bvl->{'binary'} || []}) {
      my $bin = $_->{'name'};
      $bin =~ s/\.(?:$binsufsre)$//;
      $binaryversions->{$bin} = $_;
    }
    # make sure that we don't loop forever if the server returns incomplete data
    for (@missing) {
      $binaryversions->{$_} = {'name' => $_, 'error' => 'not available'} unless $binaryversions->{$_};
    }
    @missing = grep {!exists $binaryversions->{$_}} @binaries;
  }
  my $bvl = {};
  $bvl->{'binary'} = [ map {$binaryversions->{$_}} @binaries];
  return ($bvl, $BSXML::binaryversionlist);
}

# this is shared for AJAX requests
my @lastev_cache;
my @lastev_stat;

sub lastevents {
  my ($cgi, $filter) = @_;
  if (!$cgi->{'start'}) {
    # just fetch the current event number
    my $lastev = BSFileDB::fdb_getlast("$eventdir/lastevents", $eventlay);
    my $lastno = $lastev ? $lastev->{'number'} : 0;
    my $ret = {'next' => $lastno, 'sync' => 'lost'};
    return ($ret, $BSXML::events);
  }
  if (!$BSStdServer::isajax) {
    my @args;
    push @args, "obsname=$cgi->{'obsname'}" if $cgi->{'obsname'};
    push @args, map {"filter=$_"} @{$filter || []};
    push @args, "start=$cgi->{'start'}";
    BSHandoff::handoff($ajaxsocket, '/lastevents', undef, @args);
    exit(0);
  }
  BSWatcher::addfilewatcher("$eventdir/lastevents");

  my @s = stat("$eventdir/lastevents");
  my @events;
  my ($firstno, $nextno);
  if (@s && @lastev_stat && "$s[9]/$s[7]/$s[1]" eq "$lastev_stat[9]/$lastev_stat[7]/$lastev_stat[1]") {
    @events = @lastev_cache;
  } else {
    my $lastev = BSFileDB::fdb_getlast("$eventdir/lastevents", $eventlay);
    push @events, $lastev if $lastev;
    @lastev_cache = @events;
    @lastev_stat = @s;
  }
  $firstno = @events ? $events[0]->{'number'} : 0;
  $nextno = @events ? $events[-1]->{'number'} + 1 : 1;

  if ($cgi->{'start'} < $firstno) {
    # get last 5
    @events = BSFileDB::fdb_getall_reverse("$eventdir/lastevents", $eventlay, 5);
    @events = reverse @events;
    @lastev_cache = @events;
    @lastev_stat = @s;
    $firstno = @events ? $events[0]->{'number'} : 0;
    $nextno = @events ? $events[-1]->{'number'} + 1 : 1;
  }

  if ($cgi->{'start'} < $firstno) {
    my $cnt = $nextno - $cgi->{'start'};
    if ($cnt > 5) {
      @events = BSFileDB::fdb_getall_reverse("$eventdir/lastevents", $eventlay, $cnt);
      @events = reverse @events;
      if (@events < 20) {
        @lastev_cache = @events;
        @lastev_stat = @s;
      }
      $firstno = @events ? $events[0]->{'number'} : 0;
      $nextno = @events ? $events[-1]->{'number'} + 1 : 1;
    }
  }

  if ($cgi->{'start'} < $firstno) {
    # we have to get them all
    @events = BSFileDB::fdb_getall("$eventdir/lastevents", $eventlay);
    # re-calculate in case something has changed
    $firstno = @events ? $events[0]->{'number'} : 0;
    $nextno = @events ? $events[-1]->{'number'} + 1 : 1;
    if ($firstno > $cgi->{'start'}) {
      # out of sync!
      return ({'next' => $nextno, 'sync' => 'lost'}, $BSXML::events);
    }
  }

  # filter
  @events = grep {$_->{'number'} >= $cgi->{'start'}} @events;
  if ($filter && @events) {
    my %filter = map {$_ => 1} @$filter;
    for my $ev (splice @events) {
      if ($ev->{'type'} eq 'package') {
        next unless defined $ev->{'package'};
        next unless $filter{"package/$ev->{'project'}/$ev->{'package'}"} || $filter{"package/$ev->{'project'}"};
      } elsif ($ev->{'type'} eq 'project') {
        next unless $filter{"project/$ev->{'project'}"};
      } elsif ($ev->{'type'} eq 'repository') {
        next unless $filter{"repository/$ev->{'project'}/$ev->{'repository'}/$ev->{'arch'}"};
      } else {
	next;
      }
      push @events, $ev;
    }
  }
  # return a sync reply every 100 events / 5 minutes for two reasons
  # - get rid of old peers
  # - survive history truncation
  $cgi->{'start_orig'} ||= $cgi->{'start'};
  $cgi->{'req_time'} ||= time();
  if ($BSStdServer::isajax && !@events && $nextno < $cgi->{'start_orig'} + 100 && $s[9] < $cgi->{'req_time'} + 300) {
    # small hack: update cgi to the next event number
    $cgi->{'start'} = $nextno if $cgi->{'start'} < $nextno;
    return undef;
  }
  for (@events) {
    $_ = { %$_ };	# clone em
    # delete unwanted fields
    delete $_->{'time'};
    delete $_->{'number'};
    # clean up a bit
    delete $_->{'package'} unless defined($_->{'package'}) && $_->{'package'} ne '';
  }
  my $ret = {'next' => $nextno};
  $ret->{'event'} = \@events if @events;
  return ($ret, $BSXML::events);
}

#
# add an event to the "lastevents" queue used in the build service
# interconnect implementation
#
sub addevent {
  my ($ev) = @_;

  # check the "access" flag. if the project has access turned
  # off, do not add it to lastevents.
  # XXX: maybe better to add a "noaccess" marker to the event
  # and filter in the request
  if (defined($ev->{'project'})) {
    my $access = 1;
    my $proj = readproj($ev->{'project'}, 1);
    if ($proj && $proj->{'access'}) {
      $access = BSUtil::enabled('', $proj->{'access'}, $access, '');
    }
    # XXX: may also check packages in the future
    return unless $access;
  }
  $ev->{'time'} = time();
  mkdir_p($eventdir);
  my $size = 262144;	#keep at least 256k of data
  if (-s "$eventdir/lastevents" && -s _ >= $size * 2) {
    local *F;
    BSUtil::lockopen(\*F, '+>>', "$eventdir/lastevents");
    my $events = readstr("$eventdir/lastevents");
    if (length($events) >= $size * 2) {
      $events = substr($events, -$size);
      $events =~ s/^[^\n]*\n//s;
      writestr("$eventdir/.lastevents", "$eventdir/lastevents", $events);
    }
    close F;
  }
  BSFileDB::fdb_add_i("$eventdir/lastevents", $eventlay, $ev);
}

sub newevent {
  my ($cgi) = @_;
  my $ev = {};
  for ('type', 'project', 'package', 'repository', 'arch', 'job') {
    $ev->{$_} = $cgi->{$_} if defined $cgi->{$_};
  }
  addevent($ev);
  return $BSStdServer::return_ok;
}

sub getrelsync {
  my ($cgi, $projid, $repoid, $arch) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
  my $param = {
    'uri' => "$reposerver/build/$projid/$repoid/$arch/_relsync",
    'ignorestatus' => 1,
    'receiver' => \&BSServer::reply_receiver,
  };
  BSWatcher::rpc($param, undef);
  return undef;
}

sub postrelsync {
  my ($cgi, $projid, $repoid, $arch) = @_;

  my $proj = checkprojrepoarch($projid, $repoid, $arch);
  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];
  my $relsyncdata = BSServer::read_data(10000000);
  for my $a (@{$repo->{'arch'} || []}) {
    next if $a eq $arch;
    next if $BSConfig::relsync_pool && ($BSConfig::relsync_pool->{$arch} || '') ne ($BSConfig::relsync_pool->{$a} || '');
    my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;
    my $param = {
      'uri' => "$reposerver/build/$projid/$repoid/$a/_relsync",
      'request' => 'POST',
      'data' => $relsyncdata,
    };
    eval {
      BSRPC::rpc($param);
    };
    if ($@) {
      warn($@);
    }
  }
  return $BSStdServer::return_ok;
}

# XXX: support multiple dispatchers
sub putdispatchprios {
  my ($cgi) = @_;
  my $dispatcher = $BSConfig::masterdispatcher || $BSConfig::reposerver;
  my $param = {
    'uri' => "$dispatcher/build/_dispatchprios",
    'request' => 'PUT',
    'data' => \&BSServer::forward_sender,
    'chunked' => 1,
  };
  return BSWatcher::rpc($param, undef);
}

sub getdispatchprios {
  my ($cgi) = @_;
  my $dispatcher = $BSConfig::masterdispatcher || $BSConfig::reposerver;
  my $param = {
    'uri' => "$dispatcher/build/_dispatchprios",
    'ignorestatus' => 1,
    'receiver' => \&BSServer::reply_receiver,
  };
  BSWatcher::rpc($param, undef);
  return undef;
}

sub sourceinfo {
  my ($cgi, $projid, $packid, $bconf) = @_;
  my $r = {'package' => $packid};
  my $linked = [];
  my $rev;
  my $files;
  eval {
    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'build', $linked);
    $r->{'srcmd5'} = $rev->{'srcmd5'} if $rev->{'srcmd5'} ne 'empty';
    $r->{'rev'} = $rev->{'rev'} if $rev->{'rev'};
    $r->{'vrev'} = $rev->{'vrev'} if $rev->{'vrev'};
    if (!$rev || $rev->{'srcmd5'} eq 'empty' || $rev->{'srcmd5'} eq $emptysrcmd5) {
      die("no source uploaded\n") unless $cgi->{'nofilename'};
      $rev = {'srcmd5' => $emptysrcmd5, 'project' => $projid, 'package' => $packid };
    }
    my $linkinfo = {};
    $files = lsrev($rev, $linkinfo);
    if ($linkinfo->{'xservicemd5'}) {
      $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'});
      $r->{'srcmd5'} = $rev->{'srcmd5'};
    }
    my $meta = '';
    $meta .= "$files->{$_}  $_\n" for sort keys %$files;
    $r->{'verifymd5'} = Digest::MD5::md5_hex($meta);
    die("source update running\n") if $files->{'_service'} && -e "$eventdir/service/${projid}::$packid";
    die("source update failed\n") if $files->{'_service_error'};
  };
  $r->{'originproject'} = $rev->{'originproject'} if $rev && $rev->{'originproject'};
  $r->{'linked'} = $linked if @$linked;
  if ($@) {
    $r->{'error'} = $@;
    $r->{'error'} =~ s/\n$//s;
    return $r;
  }
  if ($files->{'_link'}) {
    $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};
    eval {
      $files = handlelinks($rev, $files, {'linked' => $linked});
    };
    if ($@) {
      $files = "$@";
      $files =~ s/\n$//;
    }
    $r->{'linked'} = $linked if @$linked;
    $r->{'vrev'} = $rev->{'vrev'} if $rev->{'vrev'};
    if (!ref $files) {
      $r->{'error'} = $files || 'could not get file list';
      return $r;
    }
    $r->{'lsrcmd5'} = $r->{'srcmd5'};
    $r->{'srcmd5'} = $rev->{'srcmd5'};
    my $meta = '';
    $meta .= "$files->{$_}  $_\n" for sort keys %$files;
    $r->{'verifymd5'} = Digest::MD5::md5_hex($meta);
  }
  if ($cgi->{'withchangesmd5'}) {
    $r->{'revtime'} = $rev->{'time'};
    $r->{'changesmd5'} = $files->{"$packid.changes"} if $files->{"$packid.changes"};
  }
  return $r if $cgi->{'nofilename'};
  return $r if $packid eq '_pattern';
  if ($files->{'_aggregate'}) {
    $r->{'filename'} = '_aggregate';
    return $r;
  } elsif ($files->{'_patchinfo'}) {
    $r->{'filename'} = '_patchinfo';
    return $r;
  }
  my $type = $bconf->{'type'};
  my $file;
  if (!$type || $type eq 'UNDEFINED') {
    undef $type;
    for my $t ('spec', 'dsc', 'kiwi') {
      (undef, $file) = findfile($rev, $cgi->{'repository'}, $t, $files);
      next unless defined $file;
      $type = $t;
      last;
    }
  } else {
    (undef, $file) = findfile($rev, $cgi->{'repository'}, $type, $files);
  }
  if (!$type) {
    $r->{'error'} = 'bad build configuration, no build type defined or detected';
    return $r;
  }
  if (!$file) {
    $r->{'error'} = "no file found for build type '$type'";
    return $r;
  }
  $r->{'filename'} = $file;
  return $r unless $cgi->{'parse'};
  my $buildtype = Build::recipe2buildtype($file);
  if (!$buildtype) {
    $r->{'error'} = "don't know how to build $file";
    return $r;
  }
  my $d = Build::parse_typed($bconf, "$srcrep/$packid/$files->{$file}-$file", $buildtype);
  if (!$d) {
    $r->{'error'} = "parse error";
    return $r;
  }
  for (qw{name version release subpacks deps prereqs exclarch badarch}) {
    $r->{$_} = $d->{$_} if defined $d->{$_};
  }
  return $r;
}

sub getprojectsourceinfo {
  my ($cgi, $projid) = @_;
  my $proj = checkprojrepoarch($projid, $cgi->{'repository'}, $cgi->{'arch'}, 1);
  my @packages = @{$cgi->{'package'} || []};
  $frozenlinks_cache = {};
  @packages = findpackages($projid, $proj) unless @packages;
  my $bconf;
  if (!$cgi->{'nofilename'}) {
    if (!$cgi->{'repository'}) {
      my $cfile;
      $cfile = "$projectsdir/$projid.conf" if -e "$projectsdir/$projid.conf";
      $bconf = Build::read_config($cgi->{'arch'} || 'noarch', $cfile);
    } else {
      my @path = expandsearchpath($projid, $cgi->{'repository'});
      my $c = concatconfigs($projid, $cgi->{'repository'}, undef, @path);
      $bconf = Build::read_config($cgi->{'arch'} || 'noarch', [ split("\n", $c) ]);
    }
  }
  my @res;
  if (@packages > 1) {
    $collect_remote_getrev = 1;
    for my $packid (splice @packages) {
      my $r = sourceinfo($cgi, $projid, $packid, $bconf);
      if ($r->{'error'} && $r->{'error'} =~ /collect_remote_getrev$/) {
	push @packages, $packid;
	next;
      }
      push @res, $r;
    }
    $collect_remote_getrev = 0;
    fill_remote_getrev_cache();
  }
  for my $packid (@packages) {
    push @res, sourceinfo($cgi, $projid, $packid, $bconf);
  }
  $frozenlinks_cache = undef;
  return ({'sourceinfo' => \@res}, $BSXML::sourceinfolist);
}

sub getpackagesourceinfo {
  my ($cgi, $projid, $packid) = @_;
  checkprojrepoarch($projid, $cgi->{'repository'}, $cgi->{'arch'}, 1); #remoteok
  my $bconf;
  if (!$cgi->{'nofilename'}) {
    my $cfile;
    if (!$cgi->{'repository'}) {
      $cfile = "$projectsdir/$projid.conf" if -e "$projectsdir/$projid.conf";
    } else {
      print "expandsearchpath $projid $cgi->{'repository'}...\n";
      my @path = expandsearchpath($projid, $cgi->{'repository'});
      my $c = concatconfigs($projid, $cgi->{'repository'}, undef, @path);
      $cfile = [ split("\n", $c) ];
    }
    $bconf = Build::read_config($cgi->{'arch'} || 'noarch', $cfile);
  }
  my $res = sourceinfo($cgi, $projid, $packid, $bconf);
  return ($res, $BSXML::sourceinfo);
}

####################################################################

sub putconfiguration {
  my ($cgi) = @_;
  mkdir_p($uploaddir);
  my $uploaded = BSServer::read_file("$uploaddir/$$");
  die("upload failed\n") unless $uploaded;
  my $configuration = readxml("$uploaddir/$$", $BSXML::configuration);
  unlink("$uploaddir/$$");
  my $configurationxml = BSUtil::toxml($configuration, $BSXML::configuration);
  writestr("$BSConfig::bsdir/.configuration.xml", "$BSConfig::bsdir/configuration.xml", $configurationxml);
  # distribute to repo servers
  my %reposervers;
  if ($BSConfig::partitionservers) {
    %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);
  } else {
    $reposervers{$BSConfig::reposerver} = 1;
  }
  for my $server (sort keys %reposervers) {
    my $param = {
      'uri' => "$server/configuration",
      'request' => 'PUT',
      'data' => $configurationxml,
    };
    eval {
      BSRPC::rpc($param, undef);
    };
    warn($@) if $@;	# XXX: what now?
  }
  return $BSStdServer::return_ok;
}

sub getconfiguration {
  my $configuration = readxml("$BSConfig::bsdir/configuration.xml", $BSXML::configuration, 1) || {};
  return ($configuration, $BSXML::configuration);
}

####################################################################

sub putissuetrackers {
  my ($cgi) = @_;
  mkdir_p($uploaddir);
  my $uploaded = BSServer::read_file("$uploaddir/$$");
  die("upload failed\n") unless $uploaded;
  my $trackers = readxml("$uploaddir/$$", $BSXML::issue_trackers);
  unlink("$uploaddir/$$");
  writexml("$BSConfig::bsdir/.issuetrackers.xml", "$BSConfig::bsdir/issuetrackers.xml", $trackers, $BSXML::issue_trackers);
  return $BSStdServer::return_ok;
}

sub getissuetrackers {
  my $trackers = readxml("$BSConfig::bsdir/issuetrackers.xml", $BSXML::issue_trackers, 1) || {};
  return ($trackers, $BSXML::issue_trackers);
}

####################################################################

sub external_notification {
  my ($cgi, $type) = @_;
  my $param = {};
  for (keys %$cgi) {
    $param->{$_} = $cgi->{$_} unless $_ eq '_type' || /^\./;
  }
  notify($type, $param);
  return $BSStdServer::return_ok;
}

sub notify_plugins {
  my ($cgi, $type) = @_;
  my $param = {};
  if (BSServer::have_content()) {
    my $jsonbody = BSServer::read_data(10000000);
    $param = JSON::XS::decode_json($jsonbody);
  } else {
    for (keys %$cgi) {
      $param->{$_} = $cgi->{$_} unless $_ eq '_type' || /^\./;
    }
  }

  BSNotify::notify_plugins($type, $param);
  return $BSStdServer::return_ok;
}


####################################################################

sub hello {
  my ($cgi) = @_;
  return "<hello name=\"Source Repository Ajax Server\" repoid=\"$repoid\" />\n" if $BSStdServer::isajax;
  return "<hello name=\"Source Repository Server\" repoid=\"$repoid\" />\n";
}

####################################################################

my $dispatches = [
  '/' => \&hello,

  '!rw :' => undef,
  '!- GET:' => undef,
  '!- HEAD:' => undef,

  # /source name space: manage project and package data
  '/source deleted:bool?' => \&getprojectlist,

  'POST:/source/$project cmd=createkey user:? comment:?' => \&createkey,
  'POST:/source/$project cmd=extendkey user:? comment:?' => \&extendkey,
  'POST:/source/$project cmd=undelete user:? comment:?' => \&undeleteproject,
  'POST:/source/$project cmd=copy user:? comment:? oproject:project withbinaries:bool? withhistory:bool? makeolder:bool? resign:bool? noservice:bool?' => \&copyproject,
  'POST:/source/$project cmd=move oproject:project' => \&moveproject,
  'POST:/source/$project cmd: *:*' => \&unknowncmd,
  '/source/$project view=info parse:bool? nofilename:bool? repository? arch? package* withchangesmd5:bool?' => \&getprojectsourceinfo,
  '/source/$project deleted:bool? expand:bool? noorigins:bool?' => \&getpackagelist,

  'DELETE:/source/$project user:? comment:? requestid:num?' => \&delproject,
  '/source/$project/_meta rev?' => \&getproject,
  'PUT:/source/$project/_meta user:? comment:? requestid:num? lowprio:bool?' => \&putproject,

  '/source/$project/_pubkey rev?' => \&getpubkey,
  'DELETE:/source/$project/_pubkey user:? comment:?' => \&deletekey,

  '/source/$project/_config rev?' => \&getprojectconfig,
  'PUT:/source/$project/_config user:? comment:?' => \&putprojectconfig,
  'DELETE:/source/$project/_config user:? comment:?' => \&delprojectconfig,

  '/source/$project/_history rev? meta:bool? deleted:bool? limit:num?' => \&getpackagehistory,

  'POST:/source/$project/$package cmd=diff rev? orev:rev? oproject:project? opackage:package? expand:bool? linkrev? olinkrev:? unified:bool? missingok:bool? meta:bool? file:filename* filelimit:num? tarlimit:num? view:? withissues:bool? onlyissues:bool?' => \&sourcediff,
  'POST:/source/$project/$package cmd=linkdiff rev? linkrev? unified:bool? file:filename* filelimit:num? tarlimit:num? view:? withissues:bool? onlyissues:bool?' => \&linkdiff,
  'POST:/source/$project/$package cmd=servicediff rev? unified:bool? file:filename* filelimit:num? tarlimit:num? view:? withissues:bool? onlyissues:bool?' => \&servicediff,
  'POST:/source/$project/$package cmd=commit rev? user:? comment:? keeplink:bool? repairlink:bool? linkrev? setrev:bool? requestid:num? noservice:bool?' => \&sourcecommit,
  'POST:/source/$project/$package cmd=commitfilelist rev? user:? comment:? keeplink:bool? repairlink:bool? linkrev? setrev:bool? requestid:num? time:num? version:? vrev:? noservice:bool? servicemark:?' => \&sourcecommitfilelist,
  'POST:/source/$project/$package cmd=copy rev? user:? comment:? orev:rev? oproject:project? opackage:package? expand:bool? keeplink:bool? repairlink:bool? linkrev? setrev:linkrev? olinkrev:linkrev? requestid:num? dontupdatesource:bool? noservice:bool? withvrev:bool? withacceptinfo:bool? makeoriginolder:bool?' => \&sourcecopy,
  'POST:/source/$project/$package cmd=collectbuildenv user:? comment:? orev:rev? oproject:project? opackage:package?' => \&sourcecollectbuildenv,
  'POST:/source/$project/$package cmd=branch rev? user:? comment:? orev:rev? oproject:project? opackage:package? olinkrev:linkrev? requestid:num? force:bool? keepcontent:bool? missingok:bool? noservice:bool? withacceptinfo:bool?' => \&sourcebranch,
  'POST:/source/$project/$package cmd=linktobranch rev? user:? comment:? linkrev?' => \&linktobranch,
  'POST:/source/$project/$package cmd=deleteuploadrev' => \&deleteuploadrev,
  'POST:/source/$project/$package cmd=undelete user:? comment:? time:num?' => \&undeletepackage,
  'POST:/source/$project/$package cmd=runservice user:? comment:?' => \&triggerservicerun,
  'POST:/source/$project/$package cmd=getprojectservices' => \&getprojectservices,
  'POST:/source/$project/$package cmd: *:*' => \&unknowncmd,

  'PUT:/source/$project/$package cmd: rev? user:? comment:?' => \&sourcecommitfilelist,	# obsolete

  '/source/$project/$package view=info rev? linkrev? parse:bool? nofilename:bool? repository? arch? withchangesmd5:bool?' => \&getpackagesourceinfo,
  '/source/$project/$package rev? linkrev? emptylink:bool? deleted:bool? expand:bool? view:? extension:? lastworking:bool? withlinked:bool? meta:bool? product:?' => \&getfilelist,
  '/source/$project/$package/_history rev? meta:bool? deleted:bool? limit:num?' => \&getpackagehistory,
  '/source/$project/$package/_meta rev? expand:bool? meta:bool? deleted:bool?' => \&getpackage,
  'PUT:/source/$project/$package/_meta user:? comment:? requestid:num?' => \&putpackage,
  'DELETE:/source/$project/$package user:? comment:? requestid:num?' => \&delpackage,
  '/source/$project/$package/$filename rev? expand:bool? meta:bool? deleted:bool?' => \&getfile,
  'PUT:/source/$project/$package/$filename rev? user:? comment:? keeplink:bool? force:bool? meta:bool?' => \&putfile,
  'DELETE:/source/$project/$package/$filename rev? user:? comment:? keeplink:bool? force:bool? meta:bool?' => \&delfile,

  # /published name spec: access published binaries
  '/published' => \&published,
  '/published/$project' => \&published,
  '/published/$project/$repository view=publishedpath medium:?' => \&published_path,
  '/published/$project/$repository' => \&published,
  '/published/$project/$repository/$arch:filename view:?' => \&published,
  '/published/$project/$repository/$arch:filename/$filename view:?' => \&published,
  '/published/$project/$repository/$arch:filename/$filename/$subfilename:filename view:?' => \&published,

  # scheduler calls
  '/getprojpack $project* $repository* $package* $arch? withrepos:bool? withsrcmd5:bool? withdeps:bool? withconfig:bool? expandedrepos:bool? ignoredisable:bool? nopackages:bool? withremotemap:bool? noremote:bool? partition:? view:?' => \&getprojpack,
  'POST:/relsync $project $repository $arch' => \&postrelsync,
  '/relsync $project $repository $arch' => \&getrelsync,

  # worker calls
  '/getsources $project $package $srcmd5:md5' => \&getsources,
  '/getconfig $project $repository path:prp*' => \&getbuildconfig,

  '/getsignkey $project withpubkey:bool? autoextend:bool?' => \&getsignkey,
  '/getsslcert $project autoextend:bool?' => \&getsslcert,
  '/getbinaries $project $repository $arch binaries: nometa:bool?' => \&worker_getbinaries,
  '/getbinaryversions $project $repository $arch binaries: nometa:bool?' => \&worker_getbinaryversions,
  '!- /lastevents $filter:* start:num? obsname:?' => \&lastevents,
  '/lastnotifications start:num? view:? block:bool? noprune:bool?' => \&lastnotifications,
  '/notificationpayload/$payloadkey:filename' => \&getnotificationpayload,
  'DELETE:/notificationpayload/$payloadkey:filename' => \&deletenotificationpayload,
  'POST:/event type: project: package:? repository:? arch:? job:?' => \&newevent,
  # tmp until lightty gets fixed
  '/public/lastevents $filter:* start:num? obsname:?' => \&lastevents,

  # search interface
  '/search $in: $match: return:? values:bool?' => \&search,
  '/search/project $match:' => \&search_proj,
  '/search/project/id $match:' => \&search_proj_id,
  '/search/package $match:' => \&search_pack,
  '/search/package/id $match:' => \&search_pack_id,

  'POST:/search/published cmd:' => \&search_published_updatedb,
  '/search/published/binary/id $match: limit:num?' => \&search_published_binary_id,
  '/search/published/pattern/id $match: limit:num?' => \&search_published_pattern_id,

  # service interface, just for listing for now
  '/service' => \&listservices,
#  '/service/$service' => \&service,

  # configuration
  'PUT:/configuration' => \&putconfiguration,
  '/configuration' => \&getconfiguration,

  # issue trackers
  'PUT:/issue_trackers' => \&putissuetrackers,
  '/issue_trackers' => \&getissuetrackers,

  # build calls for binary files
  '/build' => \&getprojectlist,
  '/build/_workerstatus scheduleronly:bool? daemonsonly:bool? arch*' => \&getworkerstatus,
  'PUT:/build/_dispatchprios' => \&putdispatchprios,
  '/build/_dispatchprios' => \&getdispatchprios,
  'POST:/build/$project cmd: repository* arch* package* code:* wipe:*' => \&docommand,
  '/build/$project' => \&getrepositorylist,
  '/build/$project/_result oldstate:md5? view:resultview* lastbuild:bool? repository* arch* package* code:*' => \&getresult,
  '/build/$project/$repository' => \&getarchlist,
  '/build/$project/$repository/_buildconfig path:prp*' => \&getbuildconfig,
  '/build/$project/$repository/$arch package* view:?' => \&getpackagelist_build,
  '/build/$project/$repository/$arch/_builddepinfo package* view:?' => \&getbuilddepinfo,
  '/build/$project/$repository/$arch/_jobhistory package* code:* limit:num?' => \&getjobhistory,
  'POST:/build/$project/$repository/$arch/_repository match:' =>  \&postrepo,
  'POST:/build/$project/$repository/$arch/$package cmd=copy oproject:project? opackage:package? orepository:repository? setupdateinfoid:? resign:bool? setrelease:?' => \&copybuild,
  'POST:/build/$project/$repository/$arch/$package' => \&uploadbuild,
  '/build/$project/$repository/$arch/$package_repository view:? binary:filename* nometa:bool? nosource:bool? withmd5:bool?' => \&getbinarylist,
  'POST:/build/$project/$repository/$arch/$package_repository/_buildinfo add:* debug:bool?' => \&getbuildinfo_post,
  '/build/$project/$repository/$arch/$package/_buildinfo add:* internal:bool? debug:bool?' => \&getbuildinfo,
  '/build/$project/$repository/$arch/$package/_jobstatus' => \&getjobstatus,
  '/build/$project/$repository/$arch/$package/_log nostream:bool? last:bool? start:intnum? end:num? view:?' => \&getlogfile,
  '/build/$project/$repository/$arch/$package/_reason' => \&getbuildreason,
  '/build/$project/$repository/$arch/$package/_status' => \&getbuildstatus,
  '/build/$project/$repository/$arch/$package/_history limit:num?' => \&getbuildhistory,
  '/build/$project/$repository/$arch/$package_repository/$filename view:?' => \&getbinary,
  'PUT:/build/$project/$repository/$arch/_repository/$filename ignoreolder:bool? wipe:bool?' => \&putbinary,
  'DELETE:/build/$project/$repository/$arch/_repository/$filename' => \&delbinary,

  'POST:/request cmd: user:?' => \&createrequest,
  '/request' => \&getrequestlist,
  'POST:/request/$id:num cmd: newstate:? user:? comment:? by_user:? by_group:? by_project:? by_package:? superseded_by:?' => \&postrequest,
  '/request/_lastid' => \&getlastidrequest,                     # just required for migration into api
  '/request/$id:num' => \&getrequest, # just required for migration into api

  # notifications from publisher/repserver - CGI
  'POST:/notify/$_type: *:?' => \&external_notification,
  # called from the API to notify hermes/rabbitmq
  'POST:/notify_plugins/$_type:' => \&notify_plugins,

  '/ajaxstatus' => \&getajaxstatus,
  '/serverstatus' => \&BSStdServer::serverstatus,
];

####################################################################

my $dispatches_ajax = [
  '/' => \&hello,
  '/ajaxstatus' => \&getajaxstatus,
  '/build/$project/_result oldstate:md5? view:resultview* repository* arch* package* code:*' => \&getresult,
  '/build/$project/$repository/$arch package* view:?' => \&getpackagelist_build,
  '/build/$project/$repository/$arch/$package/_log nostream:bool? last:bool? start:intnum? end:num?' => \&getlogfile,
  '/build/$project/$repository/$arch/$package_repository view:? binary:filename* nometa:bool? nosource:bool? withmd5:bool?' => \&getbinarylist,
  '/getbinaries $project $repository $arch binaries: nometa:bool? raw:bool?' => \&worker_getbinaries,
  '/getbinaryversions $project $repository $arch binaries: nometa:bool?' => \&worker_getbinaryversions,
  '/lastevents $filter:* start:num? obsname:?' => \&lastevents,
  '/lastnotifications start:num? view:? block:bool?' => \&lastnotifications,
  '/source/$project/$package rev view:' => \&getfilelist_ajax,
  '/source/$project/$package:package/$filename rev?' => \&getfile,
  '/request/$id:num withkey:bool? oldkey:md5?' => \&getrequest,
  '/sourcediffcache/$cacheid:md5 view:?' => \&getsourcediffcache,
];

####################################################################

my $conf = {
  'port' => $port,
  'dispatches' => $dispatches,
  'setkeepalive' => 1,
  'maxchild' => 20,
  'maxchild2' => 20,
};

my $aconf = {
  'socketpath' => $ajaxsocket,
  'dispatches' => $dispatches_ajax,
  'getrequest_timeout' => 10,
  'replrequest_timeout' => 10,
  'getrequest_recvfd' => \&BSHandoff::receive,
  'setkeepalive' => 1,
};

if ($BSConfig::workersrcserver) {
  my $wport = $port;
  $wport = $1 if $BSConfig::workersrcserver =~ /:(\d+)$/;
  $conf->{'port2'} = $wport if $wport != $port;
}

# set a repoid for identification of this data repository
BSUtil::mkdir_p_chown("$projectsdir", $BSConfig::bsuser, $BSConfig::bsgroup) unless -d "$projectsdir";
if (! -e "$projectsdir/_repoid") {
  my $randomid = int(rand(1000000000));
  writestr("$projectsdir/._repoid", "$projectsdir/_repoid", sprintf("%09d", $randomid));
}
$repoid = readstr("$projectsdir/_repoid");

BSStdServer::server('bs_srcserver', \@ARGV, $conf, $aconf);

